{"pages":[{"title":"关于我们","text":"ACE_xW 简介 联系方式 Blog: http://bapuqln.github.io GitHub: https://github.com/bapuqln","link":"/about/index.html"},{"title":"404 Not Found","text":"ACE_xW","link":"/404/index.html"},{"title":"Clang学习笔记","text":"Clang 学习笔记 什么是 Clang Clang 是 LLVM 的前端，可以分析 C 语言家族的所有源代码。 Clang 是如何工作的 预处理：展开所有的宏，将代码解析成抽象语法树 Clang AST 几乎所有的编译器 &amp; 静态分析工具 都是用 AST 来表示原本的代码。 一般来说， Clang AST 由两个类组成：Decl &amp; bStmt。 &gt; FunctionDecl：函数原型或者函数定义 &gt; BinaryOperator：二元表达式，（a+b） &gt; CallExpr：函数调用，foo（x） 怎么使用 Clang Clang Plugin 使用 Clang Plugin，写出的代码本身就是插件。在使用 Clang Plugin 的时候，我们不可以保留不同文件之间的全局信息和其他横跨多个文件的上下文信息。插件的运行是通过传递命令行参数给 build system（Clang/Make），在源文件分析前后，我们不能进行任何的 custom task。插件的存在形式是一个动态链接库。 LibTooling(Clang Tool) 使用 LibTooling，代码本身就是一个正常的 C++ 程序，已正常的 main() 函数作为入口。LibTooling 一般用来把程序构建的过程和程序的分析过程分开。针对每个源程序都会生成分析代码以及对应的 AST，但同时还可以维护不同源代码文件的全局信息。由于程序有 main()函数，我们还可以在分析源代码前后运行其他的任务。 LibClang 当我们想要一个稳定的 API 的时候，LibClang 是一个很好的选择，Clang 变化很块，如果使用 Plugin 或者 LibTooling，我们可能需要更新代码以应对 Clang 的变化。但如果需要在 C++ 以外的地方调用 Clang 的 API 的时候，必须要使用 LibClang。 LibClang 不可以使用完整的 AST（只能使用高层次的 AST），而另外两个选择（Plugin 与 LibTooling）则可以。如果还是无法选择，推荐使用 LibTooling interface，简单好用。LibTooling能够像 Plugin 一样完整的使用 AST，同时还不会丢掉源代码的全局信息。另外设置 LibTooling 比 Plugin 更容易。 开始使用 Clang 编译安装 LLVM 12cd where-you-want-llvm-to-livesvn co http://llvm.org/svn/llvm-project/llvm/trunk llvm Clang 123cd where-you-want-llvm-to-livecd llvm/toolssvn co http://llvm.org/svn/llvm-project/cfe/trunk clang Compile-RT 123cd where-you-want-llvm-to-livecd llvm/projectssvn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt 构建 1234cd where you want to build llvmmkdir buildcd buildcmake -G &lt;generator&gt; [options] &lt;path to llvm sources&gt; LibTooling 假如我们要分析一个 C 语言文件如下： 12345678910#No header, because it needs additional effortsvoid do_math(int *x) { *x += 5;}int main(void) { int result = -1, val = 4; do_math(&amp;val); return result;} 我们想要对上述函数进行重构。 * 把函数名do_math 改为 addFive * 把所有的对 do_math 的调用都改为 addFive * 把返回值改为 val 从 main 函数开始 1234567891011121314int main(int argc, const char **argv) { // parse the command-line args passed to your code CommonOptionsParser op(argc, argv, StatSampleCategory); // create a new Clang Tool instance (a LibTooling environment) ClangTool Tool(op.getCompilations(), op.getSourcePathList()); // run the Clang Tool, creating a new FrontendAction (explained below) int result = Tool.run(newFrontendActionFactory&lt;ExampleFrontendAction&gt;().get()); errs() &lt;&lt; &quot;\\nFound &quot; &lt;&lt; numFunctions &lt;&lt; &quot; functions.\\n\\n&quot;; // print out the rewritten source code (&quot;rewriter&quot; is a global var.) rewriter.getEditBuffer(rewriter.getSourceMgr().getMainFileID()).write(errs()); return result;} 首先设置一个 ClangTool，将命令行参数：op.getCompilations() 以及源文件列表 op.getSourcePathList() 传给它，然后就运行这个工具就好了。 LibTooling 的优点在于，可以再工具运行前后做其他的事情，比如说打印出修改前后的代码以及统计函数的个数。 创建 FrontendAction 现在创建自己的 FrontendAction，创建的原因：想要分析 test.c 的 AST 表示。 123456789class ExampleFrontendAction : public ASTFrontendAction {public: ExampleFrontendAction() {} //Note that unique pointer is used. virtual std::unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI, StringRef file) { return llvm::make_unique&lt;ExampleASTConsumer&gt;(&amp;CI); // pass CI pointer to ASTConsumer }}; 这里不是很复杂，我们创建了一个ASTFrontendAction的子类，改写了CreateASTConsumer函数以返回我们自己的ASTConsumer。我们还将指向CompileInstance的指针传入，因为这里面包含很多我们需要分析的上下文信息。 构建 ASTConsumer ASTConsumer 由Clang parser产生的AST。我们可以任意地重载ASTConsumer的成员函数，这样解析AST后我们的代码就可以被调用。首先，我们重载函数HandleTopLevelDecl，这在Clang解析完顶级的声明（像全局变量，函数定义等）后就可以被调用了。 1234567891011121314151617181920class ExampleASTConsumer : public ASTConsumer {private: ExampleVisitor *visitor; // doesn't have to be privatepublic: // override the constructor in order to pass CI explicit ExampleASTConsumer(CompilerInstance *CI) : visitor(new ExampleVisitor(CI)) // initialize the visitor { } // override this to call our ExampleVisitor on each top-level Decl virtual bool HandleTopLevelDecl(DeclGroupRef DG) { // a DeclGroupRef may have multiple Decls, so we iterate through each one for (DeclGroupRef::iterator i = DG.begin(), e = DG.end(); i != e; i++) { Decl *D = *i; visitor-&gt;TraverseDecl(D); // recursively visit each AST node in Decl &quot;D&quot; } return true; }}; 以上代码使用了ExampleVisitor（见下文），来访问整个源文件顶级声明（top-level declaration）的AST节点。对于test.c而言，两个FunctionDecl将会被访问，do_math()以及main()。 更好的 ASTConsumer 实现 重载HandleTopLevelDecl()意味着每当一个新的Decl出现的时候，函数中的代码就会被调用，而不是等到整个源文件被解析完成后。从parser的角度看，当访问do_math()的时候，它将完全不知道main()的存在，也就是说我们不能access到当前分析的函数之后的函数。 但是，这个功能很重要！ 不过，ASTConsumer还有一个更好的函数用来重载，HandelTranslationUnit()，该函数只有在整个文件都解析完才被调用。这样的话，一个translation单元就是一整个源文件。ASTContext类用来表示那个源文件的AST，并且包含许多很有用的成员（去读文档吧！）。 所以，下面的代码重载了HandelTranslationUnit(): 123456// override this to call our ExampleVisitor on the entire source file virtual void HandleTranslationUnit(ASTContext &amp;Context) { /* we can use ASTContext to get the TranslationUnitDecl, which is a single Decl that collectively represents the entire source file */ visitor-&gt;TraverseDecl(Context.getTranslationUnitDecl()); } 大多数情况下，我们都应该使用HandelTranslationUnit(), 尤其在使用RecursiveASTVisitor的时候。 创建一个 RecursiveASTVisitor 前面两部分只不过在设置架构，现在到了正文部分了。RecursiveASTVisitor是一个特别有用的类，使用它可以访问任意类型的AST节点，比如FunctionDecl以及Stmt, 只要重载那个函数（比如VisitFunctionDecl以及VisitStmt）就可以了。当然，其它AST类也同样适用这样的规则。Clang提供了一个官方的文档，虽然很短，但是很全面。 像Visit..(表示Visit任意节点的函数，如VisitStmt）这样的函数，我们必须返回true以继续遍历AST或者返回false以终止遍历，退出Clang。我们不可以直接调用Visit..，而是应该调用TraverseDecl（正如我们前面的那个例子一样），调用Visit..函数则是在背后调用的。 由于我们只需要改写函数定义和一些statement，我们只需要重载VisitFunctionDecl和VisitStmt。下面是部分代码： 12345678910111213141516171819202122232425262728293031class ExampleVisitor : public RecursiveASTVisitor&lt;ExampleVisitor&gt; {private: ASTContext *astContext; // used for getting additional AST infopublic: explicit ExampleVisitor(CompilerInstance *CI): astContext(&amp;(CI-&gt;getASTContext())) { // initialize private members rewriter.setSourceMgr(astContext-&gt;getSourceManager(), astContext-&gt;getLangOpts()); } virtual bool VisitFunctionDecl(FunctionDecl *func) { numFunctions++; string funcName = func-&gt;getNameInfo().getName().getAsString(); if (funcName == &quot;do_math&quot;) { rewriter.ReplaceText(func-&gt;getLocation(), funcName.length(), &quot;add5&quot;); errs() &lt;&lt; &quot;** Rewrote function def: &quot; &lt;&lt; funcName &lt;&lt; &quot;\\n&quot;; } return true; } virtual bool VisitStmt(Stmt *st) { if (ReturnStmt *ret = dyn_cast&lt;ReturnStmt&gt;(st)) { rewriter.ReplaceText(ret-&gt;getRetValue()-&gt;getLocStart(), 6, &quot;val&quot;); errs() &lt;&lt; &quot;** Rewrote ReturnStmt\\n&quot;; } if (CallExpr *call = dyn_cast&lt;CallExpr&gt;(st)) { rewriter.ReplaceText(call-&gt;getLocStart(), 7, &quot;add5&quot;); errs() &lt;&lt; &quot;** Rewrote function call\\n&quot;; } return true; }}; 以上的代码引入了Rewriter类，可以让我们对源代码进行修改，这在代码重构或者小规模的代码修改里面很常见。我们还在main()函数的末尾用它打印出了修改后的代码。 使用Rewriter意味着我们需要找到正确SourceLocation来插入或者替换相关的代码。同时，我们还使用了dyn_cast，来检查Stmt st是一个ReturnStmt还是CallExpr。而errs()是一个stderr流，在LLVM/Clang里面打印debug信息 写一个更具体的Visit..函数 除了更一般化地重载VisitStmt，我们可以更具体化地重载VisitReturnStme以及VisitCallExpr。VisitReturnStme和VisitCallExpr都是Stmt的子类。这就是Clang AST和RecursiveASTVisitor的美妙之处：我们可以选择一般化或者是具体化，下面就是代码 1234567891011// this replaces the VisitStmt function abovevirtual bool VisitReturnStmt(ReturnStmt *ret) { rewriter.ReplaceText(ret-&gt;getLocStart(), 6, &quot;val&quot;); errs() &lt;&lt; &quot;** Rewrote ReturnStmt\\n&quot;; return true;}virtual bool VisitCallExpr(CallExpr *call) { rewriter.ReplaceText(call-&gt;getLocStart(), 7, &quot;add5&quot;); errs() &lt;&lt; &quot;** Rewrote function call\\n&quot;; return true;}","link":"/back/Clang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"Clang plugin with Xcode","text":"Creating and using Clang plugin with Xcode 环境设置 plugin 设置 Xcode 工程设置 warnning error Xcode 集成 与 error/warning 的交互 环境设置 需要 llvm/clang，源码 12345cd /optsudo mkdir llvmsudo chown `whoami` llvmcd llvmexport LLVM_HOME=`pwd` 根据本机的 clang 版本来编译,本机3.3.1 为例 123456789git clone -b release_33 https://github.com/llvm-mirror/llvm.git llvmgit clone -b release_33 https://github.com/llvm-mirror/clang.git llvm/tools/clanggit clone -b release_33 https://github.com/llvm-mirror/clang-tools-extra.git llvm/tools/clang/tools/extragit clone -b release_33 https://github.com/llvm-mirror/compiler-rt.git llvm/projects/compiler-rt mkdir llvm_buildcd llvm_buildcmake ../llvm -DCMAKE_BUILD_TYPE:STRING=Releasemake -j`sysctl -n hw.logicalcpu` plugin 设置 创建 plugin 的文件夹 12cd $LLVM_HOMEmkdir toy_clang_plugin; cd toy_clang_plugin 基于 plugin 的例子结构如下 ToyClangPlugin.exports CMakeLists.txt ToyClangPlugin.cpp 文件内容 ToyClangPlugin.cpp 12345678910111213141516171819202122232425262728293031#include &quot;clang/Frontend/FrontendPluginRegistry.h&quot;#include &quot;clang/AST/AST.h&quot;#include &quot;clang/AST/ASTConsumer.h&quot;#include &quot;clang/Frontend/CompilerInstance.h&quot; using namespace clang; namespace{ class ToyConsumer : public ASTConsumer { }; class ToyASTAction : public PluginASTAction { public: virtual clang::ASTConsumer *CreateASTConsumer(CompilerInstance &amp;Compiler, llvm::StringRef InFile) { return new ToyConsumer; } bool ParseArgs(const CompilerInstance &amp;CI, const std::vector&lt;std::string&gt;&amp; args) { return true; } };} static clang::FrontendPluginRegistry::Add&lt;ToyASTAction&gt;X(&quot;ToyClangPlugin&quot;, &quot;Toy Clang Plugin&quot;); CMakeLists.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124cmake_minimum_required (VERSION 2.6)project (ToyClangPlugin) set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin )set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib )set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib ) set( LLVM_HOME /opt/llvm )set( LLVM_SRC_DIR ${LLVM_HOME}/llvm )set( CLANG_SRC_DIR ${LLVM_HOME}/llvm/tools/clang )set( LLVM_BUILD_DIR ${LLVM_HOME}/llvm_build )set( CLANG_BUILD_DIR ${LLVM_HOME}/llvm_build/tools/clang) add_definitions (-D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS)add_definitions (-D_GNU_SOURCE -DHAVE_CLANG_CONFIG_H) set (CMAKE_CXX_COMPILER &quot;${LLVM_BUILD_DIR}/bin/clang++&quot;)set (CMAKE_CC_COMPILER &quot;${LLVM_BUILD_DIR}/bin/clang&quot;) set (CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fPIC -fno-common -Woverloaded-virtual -Wcast-qual -fno-strict-aliasing -pedantic -Wno-long-long -Wall -Wno-unused-parameter -Wwrite-strings -fno-exceptions -fno-rtti&quot;) set (CMAKE_MODULE_LINKER_FLAGS &quot;-Wl,-flat_namespace -Wl,-undefined -Wl,suppress&quot;) set (LLVM_LIBS LLVMJIT LLVMX86CodeGen LLVMX86AsmParser LLVMX86Disassembler LLVMExecutionEngine LLVMAsmPrinter LLVMSelectionDAG LLVMX86AsmPrinter LLVMX86Info LLVMMCParser LLVMCodeGen LLVMX86Utils LLVMScalarOpts LLVMInstCombine LLVMTransformUtils LLVMipa LLVMAnalysis LLVMTarget LLVMCore LLVMMC LLVMSupport LLVMBitReader LLVMOption) macro(add_clang_plugin name) set (srcs ${ARGN}) include_directories( &quot;${LLVM_SRC_DIR}/include&quot; &quot;${CLANG_SRC_DIR}/include&quot; &quot;${LLVM_BUILD_DIR}/include&quot; &quot;${CLANG_BUILD_DIR}/include&quot; ) link_directories( &quot;${LLVM_BUILD_DIR}/lib&quot; ) add_library( ${name} SHARED ${srcs} ) if (SYMBOL_FILE) set_target_properties( ${name} PROPERTIES LINK_FlAGS &quot;-exported_symbols_list ${SYMBOL_FILE}&quot;) endif() foreach (clang_lib ${CLANG_LIBS}) target_link_libraries( ${name} ${clang_lib} ) endforeach() foreach (llvm_lib ${LLVM_LIBS}) target_link_libraries( ${name} ${llvm_lib} ) endforeach() foreach (user_lib ${USER_LIBS}) target_link_libraries( ${name} ${user_lib} ) endforeach() endmacro(add_clang_plugin) set(SYMBOL_FILE ToyClangPlugin.exports) set (CLANG_LIBS clang clangFrontend clangAST clangAnalysis clangBasic clangCodeGen clangDriver clangFrontendTool clangLex clangParse clangSema clangEdit clangSerialization clangStaticAnalyzerCheckers clangStaticAnalyzerCore clangStaticAnalyzerFrontend) set (USER_LIBS pthread curses) add_clang_plugin(ToyClangPlugin ToyClangPlugin.cpp) set_target_properties(ToyClangPlugin PROPERTIES LINKER_LANGUAGE CXX PREFIX &quot;&quot;) ToyClangPlugin.exports 1__ZN4llvm8Registry* 现在我们能够基于 CMakeLists.txt 生成 Xcode-project， 123mkdir build; cd buildcmake -G Xcode ..open ToyClangPlugin.xcodeproj 运行 ALL_BUILD target ，然后就能看到动态库：lib/Debug/ToyClangPlugin.dylib RecuresiveASTVisitor Clang 的 AST 模块提供了RecuresiveASTVisitor，他能够让你编译整个 AST，我们只需要创建一个子类并且实现我们感兴趣的方法就行。为了测试一下，现在只是打印所有发现的类名。 12345678910111213141516171819class ToyClassVisitor : public RecursiveASTVisitor&lt;ToyClassVisitor&gt;{public: bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration) { printf(&quot;ObjClass: %s\\n&quot;, declaration-&gt;getNameAsString().c_str()); return true; }}; class ToyConsumer : public ASTConsumer{public: void HandleTranslationUnit(ASTContext &amp;context) { visitor.TraverseDecl(context.getTranslationUnitDecl()); }private: ToyClassVisitor visitor;}; 下面我们就来创建测试的文件并且看看 plugin 是如何工作的。 123456789#import &lt;Foundation/Foundation.h&gt; @interface ToyObject : NSObject @end @implementation ToyObject @end rebuild &amp; 运行 插件 12345/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin 报警告 下面我们试试这个情况：类名是以小写字母开始。 在 ToyClassVisitor 中增加 ASTContext 123456789101112131415161718class ToyClassVisitor : public RecursiveASTVisitor&lt;ToyClassVisitor&gt;{private: ASTContext *context;public: void setContext(ASTContext &amp;context) { this-&gt;context = &amp;context; }// ...}; // ...void HandleTranslationUnit(ASTContext &amp;context) { visitor.setContext(context); visitor.TraverseDecl(context.getTranslationUnitDecl());} // ... 增加检测 1234567891011121314151617bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration){ checkForLowercasedName(declaration); return true;}// ...void checkForLowercasedName(ObjCInterfaceDecl *declaration){ StringRef name = declaration-&gt;getName(); char c = name[0]; if (isLowercase(c)) { DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Warning, &quot;Class name should not start with lowercase letter&quot;); SourceLocation location = declaration-&gt;getLocation(); diagEngine.Report(location, diagID); }} 测一下 1234567@interface bad_ToyObject : NSObject @end @implementation bad_ToyObject @end rebuild &amp; run 12345678910/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin ../test.m:11:12: warning: Class name should not start with lowercase letter@interface bad_ToyObject : NSObject ^1 warning generated. 报错误 试一下如果类名里面包含下划线 123456789101112131415161718void checkForUnderscoreInName(ObjCInterfaceDecl *declaration){ size_t underscorePos = declaration-&gt;getName().find('_'); if (underscorePos != StringRef::npos) { DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Error, &quot;Class name with `_` forbidden&quot;); SourceLocation location = declaration-&gt;getLocation().getLocWithOffset(underscorePos); diagEngine.Report(location, diagID); }} bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration){ // disable this check temporary // checkForLowercasedName(declaration); checkForUnderscoreInName(declaration); return true;} 看看运行后的输出 12345678910/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin ../test.m:11:15: error: Class name with `_` forbidden@interface bad_ToyObject : NSObject ^1 error generated. 我们试试两个监测都打开的时候的样子 12345678910111213/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin ../test.m:11:12: warning: Class name should not start with lowercase letter@interface bad_ToyObject : NSObject ^../test.m:11:15: error: Class name with `_` forbidden@interface bad_ToyObject : NSObject ^1 warning and 1 error generated. Xcode 集成 很遗憾，Xcode 的 clang 并不支持插件，所以我们要这么做。 在 Xcode 中启用自定义编译工具 12sudo mv HackedClang.xcplugin `xcode-select -print-path`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-inssudo mv HackedBuildSystem.xcspec `xcode-select -print-path`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications 这样就能在 build option 里面找到编译器了 在 OTHER_CFLAGS 中增加 1-Xclang -load -Xclang /opt/llvm/toy_clang_plugin/build/lib/Debug/ToyClangPlugin.dylib -Xclang -add-plugin -Xclang ToyClangPlugin 注意：这个地方使用 -add-plugin，因为我们想用自己的 ASTAction，而不是替换掉现存的 在 Module - CLANG_ENABLE_MODULES 设置为 NO 把之前新建的 test.m 增加到工程中。即可见到 增加交互 针对 warning &amp; error 增加 FixItHints 123456789101112131415161718192021222324252627282930313233343536373839404142void checkForLowercasedName(ObjCInterfaceDecl *declaration){ StringRef name = declaration-&gt;getName(); char c = name[0]; if (isLowercase(c)) { std::string tempName = name; tempName[0] = toUppercase(c); StringRef replacement(tempName); SourceLocation nameStart = declaration-&gt;getLocation(); SourceLocation nameEnd = nameStart.getLocWithOffset(name.size()); FixItHint fixItHint = FixItHint::CreateReplacement(SourceRange(nameStart, nameEnd), replacement); DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Warning, &quot;Class name should not start with lowercase letter&quot;); SourceLocation location = declaration-&gt;getLocation(); diagEngine.Report(location, diagID).AddFixItHint(fixItHint); }} void checkForUnderscoreInName(ObjCInterfaceDecl *declaration){ StringRef name = declaration-&gt;getName(); size_t underscorePos = name.find('_'); if (underscorePos != StringRef::npos) { std::string tempName = name; std::string::iterator end_pos = std::remove(tempName.begin(), tempName.end(), '_'); tempName.erase(end_pos, tempName.end()); StringRef replacement(tempName); SourceLocation nameStart = declaration-&gt;getLocation(); SourceLocation nameEnd = nameStart.getLocWithOffset(name.size()); FixItHint fixItHint = FixItHint::CreateReplacement(SourceRange(nameStart, nameEnd), replacement); DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Error, &quot;Class name with `_` forbidden&quot;); SourceLocation location = declaration-&gt;getLocation().getLocWithOffset(underscorePos); diagEngine.Report(location, diagID).AddFixItHint(fixItHint); }}","link":"/back/Creating_and_using_Clang_plugin_with_Xcode.html"},{"title":"ARM 汇编","text":"ARM 汇编 Layout label: instruction ;comment &gt;label 字母、下划线和 $ 组成. &gt;comment 所有在;后面的都认为是注释 &gt;instruction 指令 1234567 .textstart: MOV r1, #20 ;puts the value 20 into register r1 MOV r2, #22 ;puts the value 22 into register r2 ADD r0, r1, r2 ;adds r1 and r2, r0 contains 42end: b end ;infinite loop, always jump back to end Instruction Format &lt;op&gt;{cond}{flags} Rd, Rn, Operand2 例如: ADD r0, r1, r2 三个字母的指令 {cond} 可选，两个字母的状态码(condition code) {flags} 可选，附加标志位 Rd 目标寄存器 Rn 第一个寄存器 Operand2 第二个寄存器或者操作数 Condition Code 在指令后面添加，允许指令在特定条件下执行。 AL - always 无条件执行，因此可以不用写 ADDAL 和 ADD 是等价的 NV - never。 AL 的反义词，带有该标记的指令不会执行。已经废弃。 EQ - equal 当 Z 标志为被设置过后，才会执行，如果 Z 标志位被清除，该行指令被忽略. MOV r0, #42 ;Write the value 42 into the register r0MOV r1, #41 ;Write the value 41 into the register r1CMP r0, r1 ;Compare the registers r0 and r1, update CPSR register BEQ label ;This command will not be run, since Z = 0MOV r1, #42 ;Write the value 42 into the register r1CMP r0, r1 ;Compare r0 and r1, update the CPSRBEQ label ;This command will be run, since Z = 1 1234* NE - not equal &gt; EQ 的反义词，如果 Z 标志位被清除，则执行。如果 Z 标志位被设置过，该行指令被忽略 MOV r0, #42 ;Write the value 42 into the register r0MOV r1, #42 ;Write the value 42 into the register r1CMP r0, r1 ;Compare the registers r0 and r1, update CPSR register BNE label ;This command will not be run, since Z = 1MOV r1, #41 ;Write the value 42 into the register r1CMP r0, r1 ;Compare r0 and r1, update the CPSRBNE label ;This command will be run, since Z = 0 12345678910111213* VS - overflow set &gt; 如果 overflow(v) 位被设置，该条件为 true。两个32位有符号数相加，可能会出一个33位的有符号数* VC - overflow clear &gt; 如果 overflow(v) 位被清除，该条件为 true。 * MI - minus &gt; 如果 negative(N) 为被设置，该条件为 true MOV r0, #40MOV r1, #42SUBS r2, r0, r1 ; 40 – 42, the result is negative BMI destination ; this portion of code is never executed PL - plus 如果 negative(N) 位被清除，该条件为 true。(&lt;= 0) CS - Carry Set 当一个在32位无符号数上的操作超出了32位的范围的时候，carry set 标志位设为 true CC - Carry Clear 如果 Carry Flag(C) 被清除了，该条语句执行 HI - Higher 如果 Carry Flag(C) 被设置，并且结果非0(Z)，该语句执行 LS - Lower or Same 如果 Carry Flag(C) 被清除，并且结果为0(Z)，该语句执行 GE - Greater than or Equal 当有符号数，并且当 Negative(N) 和 Overflow(V) 相等的时候，该语句才有效 LT - Less Than 有符号数，并且当 Negative(V) 和 Overflow(V) 不相等的时候，该语句才有效。 LE - Less Than or Equal 像 LT， 如果 Negative(V) 和 Overflow(V) 不相等，或者 Zero(Z)标志位被设置了的时候，该语句才执行。 CODE MEANING FLAGS EQ Equal equals Zero Z NE Not Equal !Z VS Overflow V VC No overflow !V MI Minus/negative N PL Plus/positive or zero !N CS Carryset/unsigned higher or same C CC Carry clear/unsigned lower !C HI Unsigned higher C and !Z LS Unsigned lower or same !C or Z GE Signed greater than or equal N == V LT Signed less than N != V GT Signed greater than !Z and (N == V) LE Signed less than or equal Z or (N != V) AL Always(default) Any Updating Condition Flags 默认情况下，指令不更新条件标志。 &gt; 当 S (ADDS, SBCS...) 标志位被设置后，指令才能更新标志位。 &gt; 例外：比较指令会自动更新 Objective-C MOV r0, # 80 00 00 0F ; r0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I I I IMOV r1, r0, LSL #1 ; r1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I I I I 0","link":"/back/ARM%E6%B1%87%E7%BC%96.html"},{"title":"LLVM &amp; Clang","text":"LLVM &amp; Clang LLVM DragonMediu LLVM（Low Level Virtual Machine） 是一个底层虚拟机，但是现在是一系列编译器和工具链的合集，而且是模块化和可重用的。 #### LLVM 的结构 传统的编译器分为三个阶段：前端，优化，后端 Untitled LLVM 也是三段式结构。 如果要支持一个新的硬件设备，只需要实现一个新的后端。要支持一个新的语言，只需要实现一个新的前端。 优化阶段 针对了统一的 LLVM IR，LLVM IR 主要有三种格式（完全等价） * 在内存中的编译中间语言 * 硬盘上存储的二进制中间语言（.bc） * 可读的中间格式（.ll） Demo - hello.c 1 生成一个二进制的 .bc 文件 生成一个 .ll 文件","link":"/back/LLVM_Clang.html"},{"title":"Mesh Transforms","text":"Mesh Transforms 先上源代码 本文很简单粗暴，在 layer 中引入了一些点，然后通过移动点来改变整体的形状。 CAMeshVertex CAMeshVertex 是相当简单的一个结构体 1234typedef struct CAMeshVertex { CGPoint from; CAPoint3D to;} CAMeshVertex; CAPoint3D 看上去和 CGPoint 很类似，只不过拓展了 z 轴 12345typedef struct CAPoint3D { CGFloat x; CGFloat y; CGFloat z;} CAPoint3D; CAMeshVertex 的想法是相当简单：他描述了平面点和3D 空间的映射， CAMeshFace 1234typedef struct CAMeshFace { unsigned int indices[4]; float w[4];} CAMeshFace;","link":"/back/Mesh_Transform.html"},{"title":"MVC、MVP、MVVM","text":"MVC. MVP. MVVM 架构模式 MVX 中的 Model 在大多数的iOS项目中，Model 层只是一个单纯的数据结构，大部分的模型都是这样的 12345678910struct User { enum Gender: String { case male = &quot;male&quot; case female = &quot;female&quot; } let name: String let email: String let age: Int let gender: Gender} 模型起到了定义一堆坑的作用，只是一个简单的模板，并没有参与到实际的业务逻辑，只是在模型层进行了一些抽象，将服务器端发回的JSON或者说NSDictionary 对象中的字段一一取出并填装到预先定义好的模型中。 可以将这种模型层中提供的对象理解为即开即用的NSDictionary实例，在使用时，可以直接从模型中取出属性，省去了从NSDictionary中抽出属性以及验证是否合法的过程. JSON -&gt; Model 使用 Swift 将 Dictionary 转换成模型，在笔者看来其实是一件比较麻烦的事情，主要原因是 Swift 作为一个号称类型安全的语言，有着使用体验非常差的 Optional 特性，从 Dictionary 中取出的值都是不一定存在的，所以如果需要纯手写这个过程其实还是比较麻烦的. 123456789extension User { init(json: [String: Any]) { let name = json[&quot;name&quot;] as! String let email = json[&quot;email&quot;] as! String let age = json[&quot;age&quot;] as! Int let gender = Gender(rawValue: json[&quot;gender&quot;] as! String)! self.init(name: name, email: email, age: age, gender: gender) }} 这里为 User 模型创建了一个 extension 并写了一个简单的模型转换的初始化方法，当我们从 JSON 对象中取值时，得到的都是 Optional 对象；而在大多数情况下，我们都没有办法直接对 Optional 对象进行操作，这就非常麻烦了。 麻烦的 Optional 在 Swift 中遇到无法立即使用的 Optional 对象时，我们可以会使用 ! 默认将字典中取出的值当作非 Optional 处理，但是如果服务端发回的数据为空，这里就会直接崩溃；当然，也可使用更加安全的 if let 对 Optional 对象进行解包（unwrap）。 123456789101112extension User { init?(json: [String: Any]) { if let name = json[&quot;name&quot;] as? String, let email = json[&quot;email&quot;] as? String, let age = json[&quot;age&quot;] as? Int, let genderString = json[&quot;gender&quot;] as? String, let gender = Gender(rawValue: genderString) { self.init(name: name, email: email, age: age, gender: gender) } return nil }} 上面的代码看起来非常的丑陋，而正是因为上面的情况在 Swift 中非常常见，所以社区在 Swift 2.0 中引入了 guard 关键字来优化代码的结构。 123456789101112extension User { init?(json: [String: Any]) { guard let name = json[&quot;name&quot;] as? String, let email = json[&quot;email&quot;] as? String, let age = json[&quot;age&quot;] as? Int, let genderString = json[&quot;gender&quot;] as? String, let gender = Gender(rawValue: genderString) else { return nil } self.init(name: name, email: email, age: age, gender: gender) }} 不过，上面的代码在笔者看来，并没有什么本质的区别，不过使用 guard 对错误的情况进行提前返回确实是一个非常好的编程习惯。 不关心空值的 Objective-C 为什么 Objective-C 中没有这种问题呢？主要原因是在 OC 中所有的对象其实都是 Optional 的，我们也并不在乎对象是否为空，因为在 OC 中向 nil 对象发送消息并不会造成崩溃，Objective-C 运行时仍然会返回 nil 对象。 OC 作为动态语言，这种设计思路其实还是非常优秀的，它避免了大量由于对象不存在导致无法完成方法调用造成的崩溃；同时，作为开发者，我们往往都不需要考虑 nil 的存在，所以使用 OC 时写出的模型转换的代码都相对好看很多。 1234567891011121314151617181920212223242526272829// User.htypedef NS_ENUM(NSUInteger, Gender) { Male = 0, Female = 1,};@interface User: NSObject@property (nonatomic, strong) NSString *email;@property (nonatomic, strong) NSString *name;@property (nonatomic, assign) NSUInteger age;@property (nonatomic, assign) Gender gender;@end// User.m@implementation User- (instancetype)initWithJSON:(NSDictionary *)json { if (self = [super init]) { self.email = json[@&quot;email&quot;]; self.name = json[@&quot;name&quot;]; self.age = [json[@&quot;age&quot;] integerValue]; self.gender = [json[@&quot;gender&quot;] integerValue]; } return self;}@end 元编程能力 从上面的代码，我们可以看出：Objective-C 和 Swift 对于相同功能的处理，却有较大差别的实现。这种情况的出现主要原因是语言的设计思路导致的；Swift 一直鼓吹自己有着较强的安全性，能够写出更加稳定可靠的应用程序，而安全性来自于 Swift 语言的设计哲学；由此看来静态类型、安全和动态类型、元编程能力（？）看起来是比较难以共存的。 OC 中对于 nil 的处理能够减少我们在编码时的工作量，不过也对工程师的代码质量提出了考验。我们需要思考 nil 的出现会不会带来崩溃，是否会导致行为的异常、增加应用崩溃的风险以及不确定性，而这也是 Swift 引入 Optional 这一概念来避免上述问题的初衷。 相比而言，笔者还是更喜欢强大的元编程能力，这样可以减少大量的重复工作并且提供更多的可能性，与提升工作效率相比，牺牲一些安全性还是可以接受的。 网络服务Service 层 现有的大多数应用都会将网路服务组织成单独的一层，所以有时候你会看到所谓的 MVCS 架构模式，它其实只是在 MVC 的基础上加上了一个服务层（Service），而在 iOS 中常见的 MVC 架构模式也都可以理解为 MVCS 的形式，当引入了 Service 层之后，整个数据的获取以及处理的流程是这样的： 大多数情况下服务的发起都是在 Controller 中进行的； 然后会在 HTTP 请求的回调中交给模型层处理 JSON 数据； 返回开箱即用的对象交还给 Controller 控制器； 最后由 View 层展示服务端返回的数据； 不过按理来说服务层并不属于模型层，为什么要在这里进行介绍呢？这是因为 Service 层其实与 Model 层之间的联系非常紧密；网络请求返回的结果决定了 Model 层该如何设计以及该有哪些功能模块，而 Service 层的设计是与后端的 API 接口的设计强关联的，这也是我们谈模型层的设计无法绕过的坑。 iOS 中的 Service 层大体上有两种常见的组织方式，其中一种是命令式的，另一种是声明式的。 命令式 命令式的 Service 层一般都会为每一个或者一组 API 写一个专门用于 HTTP 请求的 Manager 类，在这个类中，我们会在每一个静态方法中使用 AFNetworking 或者 Alamofire 等网络框架发出 HTTP 请求。 123456789101112131415161718192021222324252627import Foundationimport Alamofirefinal class UserManager { static let baseURL = &quot;http://localhost:3000&quot; static let usersBaseURL = &quot;\\(baseURL)/users&quot; static func allUsers(completion: @escaping ([User]) -&gt; ()) { let url = &quot;\\(usersBaseURL)&quot; Alamofire.request(url).responseJSON { response in if let jsons = response.result.value as? [[String: Any]] { let users = User.users(jsons: jsons) completion(users) } } } static func user(id: Int, completion: @escaping (User) -&gt; ()) { let url = &quot;\\(usersBaseURL)/\\(id)&quot; Alamofire.request(url).responseJSON { response in if let json = response.result.value as? [String: Any], let user = User(json: json) { completion(user) } } }} 在这个方法中，我们完成了网络请求、数据转换 JSON、JSON 转换到模型以及最终使用 completion 回调的过程，调用 Service 服务的 Controller 可以直接从回调中使用构建好的 Model 对象。 123456UserManager.user(id: 1) { user in self.nameLabel.text = user.name self.emailLabel.text = user.email self.ageLabel.text = &quot;\\(user.age)&quot; self.genderLabel.text = user.gender.rawValue} 声明式 使用声明式的网络服务层与命令式的方法并没有本质的不同，它们最终都调用了底层的一些网络库的 API，这种网络服务层中的请求都是以配置的形式实现的，需要对原有的命令式的请求进行一层封装，也就是说所有的参数 requestURL、method 和 parameters 都应该以配置的形式声明在每一个 Request 类中。 如果是在 Objective-C 中，一般会定义一个抽象的基类，并让所有的 Request 都继承它；但是在 Swift 中，我们可以使用协议以及协议扩展的方式实现这一功能。 123456789101112131415protocol AbstractRequest { var requestURL: String { get } var method: HTTPMethod { get } var parameters: Parameters? { get }}extension AbstractRequest { func start(completion: @escaping (Any) -&gt; Void) { Alamofire.request(requestURL, method: self.method).responseJSON { response in if let json = response.result.value { completion(json) } } }} 在 AbstractRequest 协议中，我们定义了发出一个请求所需要的全部参数，并在协议扩展中实现了 start(completion:) 方法，这样实现该协议的类都可以直接调用 start(completion:) 发出网络请求。 12345678910111213141516final class AllUsersRequest: AbstractRequest { let requestURL = &quot;http://localhost:3000/users&quot; let method = HTTPMethod.get let parameters: Parameters? = nil}final class FindUserRequest: AbstractRequest { let requestURL: String let method = HTTPMethod.get let parameters: Parameters? = nil init(id: Int) { self.requestURL = &quot;http://localhost:3000/users/\\(id)&quot; }} 我们在这里写了两个简单的 Request 类 AllUsersRequest 和 FindUserRequest，它们两个一个负责获取所有的 User 对象，一个负责从服务端获取指定的 User；在使用上面的声明式 Service 层时也与命令式有一些不同： 123456FindUserRequest(id: 1).start { json in if let json = json as? [String: Any], let user = User(json: json) { print(user) }} 因为在 Swift 中，我们没法将 JSON 在 Service 层转换成模型对象，所以我们不得不在 FindUserRequest 的回调中进行类型以及 JSON 转模型等过程；又因为 HTTP 请求可能依赖其他的参数，所以在使用这种形式请求资源时，我们需要在初始化方法传入参数。 命令式 vs 声明式 现有的 iOS 开发中的网络服务层一般都是使用这两种组织方式，我们一般会按照资源或者功能来划分命令式中的 Manager 类，而声明式的 Request 类与实际请求是一对一的关系。 这两种网络层的组织方法在笔者看来没有高下之分，无论是 Manager 还是 Request 的方式，尤其是后者由于一个类只对应一个 API 请求，在整个 iOS 项目变得异常复杂时，就会导致网络层类的数量剧增。 这个问题并不是不可以接受的，在大多数项目中的网络请求就是这么做的，虽然在查找实际的请求类时有一些麻烦，不过只要遵循一定的命名规范还是可以解决的。 小结 现有的 MVC 下的 Model 层，其实只起到了对数据结构定义的作用，它将服务端返回的 JSON 数据，以更方便使用的方式包装了一下，这样呈现给上层的就是一些即拆即用的『字典』。 单独的 Model 层并不能返回什么关键的作用，它只有与网络服务层 Service 结合在一起的时候才能发挥更重要的能力。 而网络服务 Service 层是对 HTTP 请求的封装，其实现形式有两种，一种是命令式的，另一种是声明式的，这两种实现的方法并没有绝对的优劣，遵循合适的形式设计或者重构现有的架构，随着应用的开发与迭代，为上层提供相同的接口，保持一致性才是设计 Service 层最重要的事情。 服务端的 Model 层 虽然文章是对客户端中 Model 层进行分析和介绍，但是在客户端大规模使用 MVC 架构模式之前，服务端对于 MVC 的使用早已有多年的历史，而移动端以及 Web 前端对于架构的设计是近年来才逐渐被重视。 因为客户端的应用变得越来越复杂，动辄上百万行代码的巨型应用不断出现，以前流水线式的开发已经没有办法解决现在的开发、维护工作，所以合理的架构设计成为客户端应用必须要重视的事情。 这一节会以 Ruby on Rails 中 Model 层的设计为例，分析在经典的 MVC 框架中的 Model 层是如何与其他模块进行交互的，同时它又担任了什么样的职责。 Model 层的职责 Rails 中的 Model 层主要承担着以下两大职责： 使用数据库存储并管理 Web 应用的数据； 包含 Web 应用所有的业务逻辑； 除了上述两大职责之外，Model 层还会存储应用的状态，同时，由于它对用户界面一无所知，所以它不依赖于任何视图的状态，这也使得 Model 层的代码可以复用。 Model 层的两大职责决定了它在整个 MVC 框架的位置： 因为 Model 是对数据库中表的映射，所以当 Controller 向 Model 层请求数据时，它会从数据库中获取相应的数据，然后对数据进行加工最后返回给 Controller 层。","link":"/back/MCV_MVVM_MVP.html"},{"title":"Metal 编程指南","text":"Metal Programming Guide Command organization and execution model (指令组织和执行模型) 在 Metal 框架中, MTLDevice 协议定义的接口描述了一个 GPU, 该协议提供了一系列方法可以查询设备属性, 创建设备相关对象(缓存和纹理) command queue 包含了一系列的 command buffers, command queue 用于管理其中的 command buffers 的执行顺序. command buffer 包含了多个被编码的指令, 这些指令在一个特定设备上运行. command encoder 可以将绘制, 计算, 位图传输指令放到一个 command buffer 中 command buffers 最终被提交到设备中去执行. MTLCommandQueue 协议为 command queue 定义了接口, 主要是创建 command buffer 对象的方法. MTLCommandBuffer 协议 为 command queue 定义了接口, 提供了创建 command encoder, 入队列执行, 检测状态以及其他操作. 该协议定义了几种 command encoder 的类型, 他们可以被用于将不同的 GPU 任务编码到 command buffer 中执行. MTLRenderCommandEncoder 协议 - 将图形渲染指令编码为一次渲染过程. MTLComputeCommandEncoder 协议 - 编码并行计算任务 MTLBlitCommandEncoder 协议 - 在缓存和纹理之间的拷贝以及 mipmap 的生成. 任一时刻, 只有一个 Encoder 是处于激活状态的, 他可以向一个 command buffer 提交 command. 对于同一个 command buffer 来说,必须是前一个 encoder 结束后, 新的 encoder 才可以被创建并且用于此 command buffer(MTLParallelRenderCommandEncoder 例外). 一点所有的指令编码结束, MTLCommandBuffer 对象自己就会提交,并且会被标记为准备执行状态. MTLCommandQueue 协议可以用来控制这些要被执行的 MTLCommandBuffer 对象. 一个 MTLDevice 对象代表了一个可以执行 command 的 GPU. MTLDevice 协议有创建新的 command queue , 从内存创建缓存, 创建纹理, 查询设备能力的方法. 使用 MTLCreateSystemDefaultDevice 来创建首选设备. 创建: command buffers 和 command encoder 基本不耗费什么系统资源. Command queue &amp; buffer &amp; texture &amp; sample state libraries &amp; compute state &amp; render pipeline state &amp; depth/stencil state, 这些对象系统鼓励重用. Command Queue command queue 接受的是: 有序的 command buffer(将要在 GPU 中执行) 列表. 在 command queue 中的 command buffers 会被确保按顺序执行. command queue 是线程安全的. MTLDevice 中有两个方法可以创建 command queue newCommandQueue newCommandQueueWithMaxCommandBufferCount 不要没事销毁和创建 commandQueue, 记得复用. Command buffer command buffer 在被 GPU 执行之前会包含多个被编码的 command, 不支持重用, 能做的就是提交执行后, 检查状态 他还是 app 中独立可以被追踪的任务单元. 创建 command buffer MTLCommandQueue 中定义了创建 commandBuffer 的方法. 一个 MTLCommandQueue 对象只能提交给创建他的 MTLCommandQueue. commandBuffers创建的 command buffer 对象持有他执行时需要的数据. 在特定场景下, 你需要的资源已经被持有了, 可以使用commandBufferWithUnretainedReferences方法.(该方法只有在极端需要性能 app 中, 并且能够保证在 command 执行完之前资源都保持存活的情况下才使用) Executing Command MTLCommandBuffer 协议中有下列的方法可以设定在 command queue 中的执行顺序. 一个 command buffer 一定要先提交然后在执行. enqueue 方法可以为一个 command buffer 在 command queue 中预定一个位置.但是并没有把 command buffer 提交执行.当这个 command buffer 最终提交的时候, 他会在之前做 enqueue 操作的 command buffer 之后执行. commit 方法会使 command buffer 尽快的被执行.但必须是等到之前 enqueue 的 command buffer 执行后. commit 会隐式的调用 enqueue. Registering Handler Blocks for Command Buffer Execution addScheduledHandler, 当 command buffer 被 schedule 的时候调用. waitUntilScheduled, 该方法同步的等待, 当 command buffer 被完全执行完或者其所有注册 addScheduledhandler 都结束的时候返回. addCompleteHandler, 当设备执行完 command buffer 的时候调用. waitUntilCompleted, 该方法同步的等待, 当设备执行完 command buffer并且所有注册 addCompleteHandler 都返回的时候. presentDrawable:, 便捷函数:在command buffer 被 schedule 的时候, 能够将可显示的资源(CAMetalDrawable 对象)展示出来 status, read-only 属性. command buffer 是在生命周期的哪个阶段. error, 如果没有异常,为 nil. 如果有错误, 可以看看 command buffer error codes. Command Encoder 1.Encoder 是一个一次性的 transient 的对象, 在激活状态的时候可以他就可以把一个 command 追加到 command buffer 中. 使用 endEncoding 来结束编码 command. 还想要编码 command, 只能在新建一个 encoder. Creating a Command Encoding Object renderCommandEncoderWithDescriptor, 创建一个 MTLRenderCommandEncoder 类型的 encoder 用来在TMLRenderPassDescriptor中做图形渲染. computeCommandEncoder, 创建一个 MTLComputeCommandEncoder 类型的 encoder 用来做并行计算. blitCommandEncoder, 创建了一个 MTLBlitCommandEncoder 类型的 encoder 用来做内存操作. parallelRenderCommandEncoderWithDescriptor, 创建了一个MTLParallelRenderCommandEncoder 类型的 encoder, 用来让多个 MTLRenderCommandEncoder 对象在不同的线程工作,并且保证渲染到同一个 attachment(共享的MTLRenderPassDescriptor) 中. Render Command Encoder 该 encoder 需要关联一个MTLRenderPassDescriptor对象，在这个descriptor对象中包含了颜色 、景深、模板attachment，这些attachment将被当做绘制命令的目标， 该 Encoder 有如下能力: 指定图形资源, 如缓存和纹理对象。 指定 MTLRenderPipelineState对象(包含 compiled rendering state 以及顶点和片段着色器) 指定 fixed-function 状态, 包括 viewport, 更多可以看 MTLRenderCommandEncoder 协议 Compute Command Encoder 参见 MTLComputeCommandEncoder 协议 Blit Command Encoder MTLBlitCommandEncoder 协议可以追加一个 command 用来做 MTLBuffer 和 MTLTexture 之前的内存拷贝操作. 还可以用固定颜色填充纹理生成一个 mipmaps Multiple Thread, Command Buffers, Command Encoder 大多数程序使用单一的线程来encoder 绘制指令到一个 command buffer 来绘制一帧画面.在每一帧结束的时候, 提交 command buffer, 这样就可以 shcedule 并且 开始 command 的执行. 如果需要并行的为 command buffer 编码, 这样就需要在同时创建多个command buffer, 在不同的线程 encoder 每一个 command buffer. 如果提前知道 command buffer 的执行顺序, 就可以按顺序 enqueue 每个 command buffer, 就不用等待执行编码和提交. Resource Objects: Buffers and Textures MTLBuffer 表示一块非格式化的内存可以存放任何类型的数据.通常用来存放顶点, 着色器, 计算状态数据. MTLTexture 表示一块有格式的图像数据, 有特定的纹理类型 &amp; 像素格式 MTLSampleState 用于纹理对象的查找计算. Buffers are Typeless Allocations of Memory 一个 MTLBuffer 表示了一段内存区域,他可以存放任何数据类型. Creating a Buffer Object 下面的 MTLDevice 方法创建并返回一个 MTLBuffer 对象 newBufferWithLenth:Options: 分配内存创建一个 MTLBuffer 对象 newBufferWithBytes:length:options: 通过从已有的存储器中拷贝到新分配的内存中 newBufferWithBytesNoCopy:length:options:deallocator: 该方法创建一个 MTLBuffer 对象，但不会为这个对象新分配内存，而是使用已经存在的内存。","link":"/back/Metal%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97.html"},{"title":"Selector 是什么","text":"selector 到底是什么 1234567891011static SEL sel_alloc(const char *name, bool copy){ selLock.assertWriting(); return (SEL)(copy ? strdup(name) : name); }const char *sel_getName(SEL sel) { if (!sel) return &quot;&lt;null selector&gt;&quot;; return (const char *)(const void*)sel;} 从 sel_alloc 可以看出来，SEL 就是直接使用当前的字符串，或者把当前的字符串拷贝一份，然后char * 强转为 SEL. 从 sel_getName 可以看出，SEL 类型可以强转为 char * 也就是说 SEL 就是字符串，那么@selector(XXX)\u0010就是字符串 XXX。然后从 class 里面取方法就是拿这个字符串跟 class 里面的 methodList 里面取 method 的 name（也就是 SEL）作对比，如果相等，就取到了。","link":"/back/Selector%E6%98%AF%E4%BB%80%E4%B9%88.html"},{"title":"Block学习","text":"#iOS Block 概要 ##1.Block 的种类 block 常见的类型有三种: __NSGlobalBlock__（全局）, __NSStackBlock__（栈）, __NSMallocBlock（堆）。 1234567891011121314int main(int argc, const char *argv[]){ @autorelease{ int i = 10; //ARC 情况下 ^{i;}; //创建 block 的时候都是在 `栈` 中 --&gt; StackBlock void (^block) = ^{i;}; //block为 strong 类型，并且捕获了外部变量，所以赋值的时候，自动进行了 copy -&gt; MallocBlock __weak void (^weakBlock) = ^{i;};\u0010 //如果是 weak 类型的 block，不会自动进行 copy -&gt; StackBlock void (^stackBlock) = ^{}; //如果 block 是 strong 类型，并且没有捕获外部变量、或者用到全局变量，静态变量，那么就会被转换成 GlobalStack. } } 综上所述：我们可以得到如下的结论：ARC 下 1.block 没有捕获外部变量，或者用到全局变量、静态变量，则为 __NSGlobalBlock__ 2.block 用到自动变量且用正常变量来接受这个 block，则是 MallocBlock 3.block 用到自动变量或者用 weak 变量来接受 block，则是 StackBlock 备注： 1.block 用到自动变量初创之时都是 StackBlock 类型，在 ARC 环境下赋值给正常变量时，系统会将 block 拷贝到堆上，StackBlock 变成了 MallocBlock 2.在 MRC 下，赋值给正常变量时，系统不会自动的将 block 拷贝到堆上。 ###2.Block 内外关系 123456static int a;//全局或者局部变量都一样- (void)test{ ^{ a; }} //不向 block 内传递任何东西，（\u0010全局或者局部变量作用域广，任何时候用到变量 a 都是同一个变量，block 用到的变量 a 也是同一个） 123456- (void)test{ static int a; ^{ a = 10; }} //向 block 内传递地址（局部静态变量作用域有限，block 记录了局部静态变量的地址，确保了 block 内外用到的变量 a 是同一个） 123456- (void)test{ int a; ^{ a; }} // 向 block 内传递 123456- (void)test{ __block int a; ^{ a = 10; }} //向 block 内传递构造的结构体 __Block_byref 综上所述：__block 修饰的基础类型和对象类型都会构造__Block_byref结构体再传递。 构造__Block_byref结构体在传递的方式会很复杂。 ###3.梳理 在 ARC 环境下， __NSGlobalBlock__ 几乎不出现，使用起来没什么需要注意。 __NSStackBlock__ 几乎不出现， 但他是 __NSMallocBlock__ 的前身。 __NSMallocBlock__ 比较重要 看得懂编译是一切的前提 ##1.看懂编译 编译选项：clang --rewrite-objc ### A.不带参数 123456int main(int argc, const char *argv[]){ @autorelease{ ^{} } return 0;} 编译结果： 12345678910111213141516171819202122232425262728293031323334353637struct __block_impl{ void *isa; int Flags; int Reverse; void *FuncPtr;};struct __main_block_impl_0{ struct __block_impl impl; struct __main_block_desc_0 *Desc; __main_block_desc_0(void *fp, struct __main_block_desc_0 *desc, int flags = 0){ impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct _main_block_impl_0 *__cself){}static struct _main_block_func_0{ size_t reserved; size_t Block_size;}__main_block_desc_0_DATA = {0, sizeof(struct __main_block_impl_0);}int main(int argc, const char* argv[]){ void(*test)()=( (void (*))&amp;__main_block_impl_0( (void *)__main_block_func_9, &amp;__main_block_desc_0_DATA) ); ); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr((__block_impl *)test); return 0;} __main_block_impl_0 就是 block 的一个 C++的实现，0 表示第几个block，其实就是一个结构体。 __block_impl 结构体中 1. isa指向所属类，就是 block 的类型。 2. flags，标志变量，在 block 内部操作中会用到。 3. Reserved，是保留变量。 4. FuncPtr，block 执行时调用的函数指针，它包含了 isa 指针，其实 block 也是一个对象。 __main_block_desc_0 结构体中 1. Reserved，为保留字段 2. Block_size 为 block 的大小，也就是sizeof(struct __main_block_impl_0) 在上面的代码中，定义__main_block_desc_0结构体时，同时创建了__main_block_desc_0_DATA，并给它赋值，以供main函数中对__main_block_0进行初始化。 __main_block_impl_0 的isa指向了__NSConcreteStackBlock 从main函数中看，__main_block_impl_0的FuncPtr指向了函数__main_block_func_0 __main_block_impl_0的Desc也指向了定义的__main_block_desc_0时就创建的__main_block_desc_0_DATA，其中记录了 block 结构体大小等信息。 ##2.Block 实际结构 在Block_private.h 中定义了对 block 的相关结构体的真实定义 1234567891011121314struct Block_descriptor{ unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *)}struct Block_layout{ void *isa; int flags; int reserved; void (* invoke)(void *,...); struct Block_descriptor *descriptor;} invoke ,相当于上文中的 FuncPtr, block 执行时调用的函数指针，block 定义时内部的执行代码都在这个函数中。 Block_descriptor，block 的详细描述 copy/dispose,辅助拷贝/销毁函数，处理 block 范围外的变量时使用。 结论： block 就是一个里面存储了指向函数体中包含定义 block 时代码块的函数指针，以及block 外部上下文等信息的结构体。 B. 基础类型 12345678int main(int argc, const char *argv[]){ int any = 1; void (^test)() = ^{ NSLog(@&quot;%d&quot;, any); }; test(); return 0;} 编译结果： 1234567891011121314151617181920212223242526272829303132333435struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int any; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _any, int flags=0) : any(_any) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself){ int any = __cself-&gt;any; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_a_f8f541_mi_0, any); }static struct __main_block_desc_0 { size_t reserved; size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};int main (int argc, const char *argv[]){ int any = 1; void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, any)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ###C. 对象类型 12345678int main(int argc, const char *argv[]){ NSString *any = [NSString stringWithFormat:@&quot;1&quot;]\u0010; void (^test)() = ^{ NSLog(@&quot;%@&quot;, any); }; test(); return 0;} 编译结果： 123456789101112131415161718192021222324252627282930313233343536373839404142struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; NSString *any; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString *_any, int flags=0) : any(_any) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { NSString *any = __cself-&gt;any; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_b_ca6e15_mi_2, any);}static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main (int argc, const char *argv[]){ NSString *any = ((NSString *(*)(id, SEL, NSString *, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_b_ca6e15_mi_0, (NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_b_ca6e15_mi_1); void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, any, 570425344)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ###D.__block 修饰基础类型 12345678int main(int argc, const char * argv[]) { __block int any = 1; void (^test)() = ^ { NSLog(@&quot;%d&quot;,any); }; test(); return 0;} 编译结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __Block_byref_any_0 { void *__isa;__Block_byref_any_0 *__forwarding; int __flags; int __size; int any;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_any_0 *any; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_any_0 *_any, int flags=0) : any(_any-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_any_0 *any = __cself-&gt;any; // bound by ref NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_c_88a22a_mi_0, (any-&gt;__forwarding-&gt;any)); }static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main(int argc, const char *argv[]){ __attribute__((__blocks__(byref))) __Block_byref_any_0 any = {(void*)0,(__Block_byref_any_0 *)&amp;any, 0, sizeof(__Block_byref_any_0), 1}; void(*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_any_0 *)&amp;any, 570425344)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ###E. __block修饰对象类型 12345678int main(int argc, const char * argv[]) { __block NSString * any = [NSString stringWithFormat:@&quot;1&quot;]; void (^test)() = ^ { NSLog(@&quot;%@&quot;,any); }; test(); return 0;} 编译结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};static void __Block_byref_id_object_copy_131(void *dst, void *src) { _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);}static void __Block_byref_id_object_dispose_131(void *src) { _Block_object_dispose(*(void * *) ((char*)src + 40), 131);}struct __Block_byref_any_0 { void *__isa;__Block_byref_any_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSString *any;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_any_0 *any; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_any_0 *_any, int flags=0) : any(_any-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_any_0 *any = __cself-&gt;any; // bound by ref NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_d_a788e6_mi_1, (any-&gt;__forwarding-&gt;any)); }static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main(int argc, const char *argv[]){ __attribute__((__blocks__(byref))) __Block_byref_any_0 any = {(void*)0,(__Block_byref_any_0 *)&amp;any, 33554432, sizeof(__Block_byref_any_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSString *(*)(id, SEL, NSString *, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_d_a788e6_mi_0)}; void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_any_0 *)&amp;any, 570425344)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ##3. 结果分析 ###3.1 1. __main_block_func_0 为 block 具体实现函数 2. __main_block_desc_0 为 block 大小描述 + 拷贝函数 + 销毁函数 3. __main_block_impl_0 block 的一切都封装在内，包括前两个函数 + 捕获的参数。该结构体就是 block 在内存里的真实存在。 4. block 的调用((void (*)(__block_impl *)) ((__block_impl *)test) -&gt; FuncPtr)((__block_impl *)test); ###3.2 以 A 为例 block 的调用 12void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0,&amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); 调用__main_block_impl_0结构体的构造函数，生成__main_block_impl_0结构体的实例，获取实例地址，将这个地址转成函数地址。 (void (*)(__block_impl *))读取地址，强转成函数 ((__block_impl *)test)之类对象转换成父类，这个地方 test 指针真正的指向对象__main_block_impl_0,是一个子类对象，但是__main_block_impl_0包含了__block_impl结构体，所以读取子类对象的父类对象大小，就能取到了父类对象 ###3.3 对象类型编译结果 1. 拷贝__main_block_impl_0 -&gt; __Block_byref_any 123static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);} 销毁 __main_block_impl_0 -&gt; __Block_byref_any 123static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);} ###3.4 __block修饰编译结果有的","link":"/back/block%E5%AD%A6%E4%B9%A0.html"},{"title":"iOS 内存管理","text":"iOS 内存管理和 malloc 源代码解读 iOS 内存基本管理 在接触 iOS 开发的时候，我们知道引用计数器的概念，也知道 ARC 和 MRC，但其实这仅仅是对堆内存上对象的内存管理。 在内存管理方面，其实 iOS 和其他操作系统总体上来说是大同小异的，大的框架原理基本相似，小的细节有所创新和不同。 和其他操作系统上运行的进程类似，iOS App 进程的地址空间也分为代码区、数据区、栈区和堆区。进程开始时，会把 mach-o 文件中的各部分，按需加载到内存中。 对于一般的 iPhone 来说，实际物理内存都在1GB 左右，对于超大的内存需求，也和一般的操作系统一样，都由系统内核维护一套虚拟内存系统。但这里需要注意的是 iOS 的虚拟系统原则略有不同，最截然不同的地方就是当物理内存内存紧张情况时得处理。 当物理内存紧张时，iOS 会把可以通过重新映射来加载的内存直接清理出内存，对于不可再生的数据，iOS 需要 App 进程配合处理，由各进程发送内存警告要求配合释放内存。对于不能及时释放足够内存的，直接 kill 掉进程，必要时甚至是前台运行的 app。。 所以，iOS 在外存没有交换区，没有内存页换出的过程。 malloc 基本原理 在 iOS APP 进程地址空间各个区域中，最灵活的就要属堆区，它为进程动态分配内存，也是我们经常和内存打交道的地方。 通常，我们会在需要新对象的时候，进行[NSObject alloc]调用，而释放对象时需要 release（ARC 会自动帮你做到这些）。 而这些 alloc、release 方法的调用，最终会走到 libsystem_malloc.dylib 的 malloc() 和 free() 函数这里。libsystem_malloc.dylib 是 iOS 内核之外的一个内存库，我们 app 进程需要的内存，先会请求到这里，但最终libsystem_malloc.dylib也都会向 iOS 的系统内核发起申请，映射实际内存到 app 进程的地址空间。 从苹果公开的 malloc 的源代码上看，原理大概如此： malloc 内存分配基于 malloc zone，并将内存分配按大小分为 nano、tiny、small、large 几种类型。申请时按需进行最适分配。 malloc 在首次调用时，初始化 default zone，在 64 位情况下，会初始化 default zone 为 nano zone。同事初始化一个 scalable zone 作为 helper zone，nano zone 负责 nano 大小的分配，scalable zone 负责 tiny、small 和 large 内存的分配。每次 malloc 时，根据传入的 size 参数，优先交个 nano zone 做分配处理，如果大小不在 nano 范围，则转交给 helper zone 处理。 nano malloc 在支持64位的条件下，malloc 优先考虑 nano malloc，负责对 256B 以下小内存分配，单位是16B。 nano zone 分配内存的地址空间范围是 0x00006nnnnnnnnnnn （OSX 64位情况），将地址空间从大到小一次分为 magazine、band、slot 几个级别 magazine 范围对应于 CPU，CPU0 对应 Mag0、CPU1 对应 Mag1，以此类推； Band 范围为 2M，连续分配内存当内存不够时以 Band 为单位向内核请求。 Slot 则对应每个 Band 中 128K 大小的范围，每个 Band 都分为 16个 Slot，分别对应于 16B、32B、.... 256B大小，支持他们的内存分配。 分配过程 确定当前 CPU 对应的 mag 和通过 size 参数计算出来的 slot，去对应的 metadata 的链表中取已经被释放过得内存区块缓存。判断渠道检查指针地址是否有问题，没有问题就直接返回。 初次进行 nano malloc 时，nano zone 并没有缓存，会直接在 nano zone 范围的地址空间上直接分配连续地址内存。 如当前 band 中当前 slot 耗尽，则向系统申请新的 band （每个 band 固定大小2M，容纳了16个128K 的槽），连续地址分配内存的基地址、limit 地址以及当前分配到的地址由 meta data 结构维护起来，而这些 meta data 则以 mag、slot 为维度（mag 个数是处理器个数，slot 是16个）的二维数组形式，放在 nanozone_t 的 meta_data字段中。 当 app 通过 free() 释放内存时：malloc 库会检查指针地址，如果没有问题，则以链表形式将这些区块按大小存储起来。这些链表的头部放在 meta_data 数组中对应的 [mag][slot] 元素中。 其实从缓存获取空余内存和释放内存时都会对指向这片内存区域的指针进行检查，如果有类似地址不对齐、未释放、多次释放、所属地址与预期的 mag、slot 不匹配等情况都会以报错结束。 除了分配和释放、系统内存吃紧时，nano zone 需将 cache 的内存区块还给系统，这主要是通过对各个 slot 对应的 meta data 上挂着空闲的链表上内存区块回收来完成。 scalable zone 上内存分配简要分析 对于超出 nano 大小范围或者不支持 nano 分配的，直接会在 scalable zone 上分配。由于 scalable zone 上的内存分配比 nano 分配要复杂。下面只做简单介绍。 scalable zone 上分配的内存包括 tiny、small、large 三大类。其中 tiny 和 small 的分配、释放过程大致相同，large 类型有自己的方式管理。 而 tiny、small 的方式也遵循着 nano 分配中的原则，新内存从系统申请并分配，free 后按照大小以特定的形式缓存起来，供后续分配使用。这里的分配在 region 上进行，region 和 nano malloc 里的 band 概念即为相似，但不同的是地址空间未必连续，而且每个 region 都有自己的位图等描述信息。和 nano 一样每个 CPU 都有一个 magazine，除此之外还分配了一个 index 为 -1 的 magazine 作为后备之用。 以 tiny 的情况为例， 分配时： 确定当前线程所在处理器的 magazine index，找到对应的 magazine 结构。 优先查看上次最后释放的区块是否和此次请求的大小刚好相等（都是对齐后的 slot 大小），如果是则直接返回。 如果不是，则查找 free list 中当前请求大小区块的空闲缓存列表，如果有返回，并整理列表。 如果没有，则在 free list 找比当前申请区块大的，而且最接近的缓存，如果有返回，并把剩余大小放到 free list 中另外的链表上。（这里需要注意的是，在一般情况下，free list 分为64个槽，0-62 上挂载区块的大小都是按 16B 为单位递增，63为所有更大的内存区块挂载的地方） 上面几项都不行，就在最后一个 region 的尾部或者首部（如果支持 ALSR）找空闲区域分配。 如果还是不行，说明所有现有 region 都没有可用空间了，那么从一个后备 magazine 中取出一个可用 region，完整地拿过来放到当前 magazine，再走一遍上面的步骤。 如果这都不行，那只能向内核申请一块新的 region 区域，挂载到当前的 magazine 下并分配内存。 如果还是不行，那就没招了，系统也给不到内存，就返回报错。 free 时 检查指针指向的地址是否有问题。 如果 last free 指针上没有挂载内存区块，则当道 last free 上就 OK 了。 如果有 last free，置换内存，并把 last free 原有内存区块挂载到 free list 上。（在挂载的 free list 前，会根据 region 位图检查前后区块是否能合并成为更大的区块，如果能会合并成一个） 合并后所在的 region 如果空闲字节超过一定条件，则把 region 放到后备的 magazine 中（-1）。 如果整个 region 都是空的，则直接还给系统内核，一了百了。 而 large 的情况，malloc 以页为单位申请和分配内存，不区分 magazine，scalable zone 同意维护一个 hash table 管理已申请的内存。而且由于内存区域都比较庞大，置换村总量2G 的区块，氛围16个元素，每个最大为128M。large 相关的结构相对简单。 苹果 malloc 代码：","link":"/back/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},{"title":"IMP是什么","text":"IMP 到底是什么 IMP 的定义可以再 objc.h 中找到 12typedef void (*IMP)(void /* id, SEL, ... */ ); typedef void (*IMP)(void); 其实就是参数为空，返回值为空的函数指针。 #1 IMP 能直接调用么 定义一个类： 1234567891011@interface TestClass : NSObject@end@implementation TestClass- (id)test:(NSInteger)arg { return nil;}@end 获取 IMP 并调用： 123456int main(int argc, char * argv[]) { IMP testIMP = class_getMethodImplementation([TestClass class], @selector(test:)); testIMP(); return 1;} #2 IMP 的返回值和参数怎么定？ 不对劲吧，参数没有传。怎么判断一个方法的具体参数呢： 1Method testMethod = class_getInstanceMethod([TestClass class], @selector(test:)); 而 Method 是： 12345struct objc_method { SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;} 从调试窗口看到的： method_types是@24@0:8q16 [4], 内容都是一个字符跟一个数字成对出现, 第一对表示返回值和参数长度(其中@表示返回值为id, 24表示参数长度为24字节),后面三对代表三个参数(@0表示参数是id而参数的偏移为0, :8表示参数是selector偏移为8,q16表示参数为long long偏移为16), 完整的type encoding参见参考. 也就意味着test:方法的IMP的类型应该是id (*IMP)(id, SEL, long long), 其中参数的第一个id是self, 第二个SEL是当前IMP对应的selector, 第三个long long就是test:的arg参数. 更详细的介绍见参考.","link":"/back/imp%E6%98%AF%E4%BB%80%E4%B9%88.html"},{"title":"iOS 静态库转动态库","text":"iOS 静态库转动态库的方法 问题 由于二级制 __TEXT 段 60M 的上限问题，支付宝钱包也将个别的 SDK 转换成动态库。 在实际抓换的过程中，由于源代码保密的问题，第三方只能提供二级制的静态库，不能提供源代码。因为我们只能把静态库直接转成动态库 抓换方法 转换方法是基于动态库本身编译和链接的特点：在链接时会把依赖的静态库 symbol 复制到本库 步骤示意图：（S1 表示静态库，D1 表示动态库） 举例说明：将不依赖其他的静态库的静态库 AMapFoundationKit.framework 转换成动态库 AMapFoundationKit.framework 步骤一 可以从Xcode原生的动态库模版一个空的动态库，与静态库名称相同，即AMapFoundationKit。 步骤二 ####2.1 设置Framework搜索路径，在AMapFoundationKit -&gt; Build Settings -&gt; FRAMEWORK_SEARCH_PATHS设置成静态库的路径 2.2 将静态库拖到AMapFoundationKit -&gt; Build Phases -&gt; Link Binary With Libraries 2.3 2.3 将静态库Headers中的所有头文件拖到AMapFoundationKit -&gt; Build Phases -&gt; Headers -&gt; Public，不用Copy文件。同时删除模版生成的AMapFoundationKit.h。 2.4 将静态库中的所有资源拖到AMapFoundationKit -&gt; Build Phases -&gt; Copy Bundle Resources 2.5 定义Link时load all symbols，将AMapFoundationKit -&gt; Build Settings -&gt; OTHER_LDFLAGS中添加-all_load 2.6 关闭Version System，AMapFoundationKit -&gt; Build Settings -&gt; VERSIONING_SYSTEM设置为None 2.7 创建触发编译的空文件（不用写任何函数），因为无编译文件将不会生成macho文件。 2.8 将静态库framework的所有系统库的依赖添加进来，可根据编译时symbol未找到symbol报错，依次添加到AMapFoundationKit -&gt; Build Phases -&gt; Link Binary With Libraries 步骤三 执行编译 步骤四 获取编译后的产物，即动态库AMapFoundationKit.framework","link":"/back/iOS%E9%9D%99%E6%80%81%E5%BA%93%E8%BD%AC%E5%8A%A8%E6%80%81%E5%BA%93.html"},{"title":"依赖注入","text":"iOS 依赖注入（DI） 依赖注入DI: Dependency Injection是控制反转IoC: Inversion of Control的实现方式之一，另外一种是依赖查找DL: Dependency Lookup 什么是依赖注入(Dependency injection) 在StackOverflow上有个问题：如何向一个5岁的小孩解释依赖注入 “When you go and get things out of the refrigerator for yourself, you can cause problems. You might leave the door open, you might get something Mommy or Daddy doesn’t want you to have. You might even be looking for something we don’t even have or which has expired. What you should be doing is stating a need, “I need something to drink with lunch,” and then we will make sure you have something when you sit down to eat.” 映射到面向对象开发中的就是：高层类（5岁小孩）应该依赖底层基础设施（家长）来提供必要的服务。 依赖倒置解决了高层次模块依赖于低层次模块和细节的问题 Dependency Injection是一个将行为从依赖中分离的技术。允许开发者定义一个方法函数依赖于外部其他各种交互，而不需要编码如何获得这些外部交互的实例。这样就在各种组件之间解耦，从而获得干净的代码，相比依赖的硬编码，一个组建只有在运行时才调用其所需要的其他组件，因此在代码运行时，通过特定的框架和容器，将其所需要的其他依赖组件进行注入，主动推入。 依赖注入可以看成是控制反转（inversion of control）的一个特例。反转的是依赖，而不是其他。“Inversion of Control Containers and the Dependency Injection pattern” 依赖注入与IOC模式类似于工厂模式，是一种解决调用者和被调用者依赖耦合关系的模式。他解决了对象之间的依赖关系，使得对象只依赖于IOC/DI 容器，实现松散耦合，然后在对象创建时，由IOC/DI容器将其依赖的对象注入其内部。 DI 解决的问题 所有的对象都必须创建；或者说：使用对象之前必须创建，但是现在我们可以不必一定遵循这个定律了，我们可以从DI容器中直接获得一个对象然后直接使用，无需事先创建它们。 依赖注入 参考文章：依赖注入 1234567891011121314- (NSNumber *)nextReminderId{ NSNumber *currentReminderId = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;currentReminderId&quot;]; if (currentReminderId) { // 增加前一个 reminderId currentReminderId = @([currentReminderId intValue] + 1); } else { // 如果还没有，设为 0 currentReminderId = @0; } // 将 currentReminderId 更新到 model 中 [[NSUserDefaults standardUserDefaults] setObject:currentReminderId forKey:@&quot;currentReminderId&quot;]; return currentReminderId;} 构造器注入 构造器注入，即将某个依赖对象传入到构造器中 (在 Objective- C中指 designated 初始化方法) 并存储起来，以便在后续过程中使用： 1234567891011121314@interface Example ()@property (nonatomic, strong, readonly) NSUserDefaults *userDefaults;@end@implementation Example- (instancetype)initWithUserDefaults:(NSUserDefaults *userDefaults){ self = [super init]; if (self) { _userDefaults = userDefaults; } return self;}@end 1234567891011- (NSNumber *)nextReminderId{ NSNumber *currentReminderId = [self.userDefaults objectForKey:@&quot;currentReminderId&quot;]; if (currentReminderId) { currentReminderId = @([currentReminderId intValue] + 1); } else { currentReminderId = @0; } [self.userDefaults setObject:currentReminderId forKey:@&quot;currentReminderId&quot;]; return currentReminderId;} 属性注入 对于属性注入，nextReminderId 的代码看起来和 self.userDefaults 的做法是一致的。只是这次不是将依赖对象传递给初始化方法，而是采用属性赋值方式 1234@interface Example@property (nonatomic, strong) NSUserDefaults *userDefaults;- (NSNumber *)nextReminderId;@end 方法注入 如果依赖对象只在某一个方法中被使用，则可以利用方法参数做注入： 1234567891011- (NSNumber *)nextReminderIdWithUserDefaults:(NSUserDefaults *)userDefaults{ NSNumber *currentReminderId = [userDefaults objectForKey:@&quot;currentReminderId&quot;]; if (currentReminderId) { currentReminderId = @([currentReminderId intValue] + 1); } else { currentReminderId = @0; } [userDefaults setObject:currentReminderId forKey:@&quot;currentReminderId&quot;]; return currentReminderId;} Demo Demo场景 Demo 中使用依赖注入的方式来为不同的 BioAuthDemoObject 提供不同的对象属性。 Demo结构 基类有相同的方法，只有在运行的时候，才会调用传入的实现 #参考 Dependency Injection, iOS and You 关于IOS依赖注入(DI)那些事 依赖注入 iOS控制反转(IoC)与依赖注入(DI)的实现 objection typhoon Objection 与 Typhoon 的协议绑定对比","link":"/back/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html"},{"title":"如何分析Crash日志","text":"iOS Crash Log 解析 #1 简介 Crash Log 是用来分析 Crash 问题的主要手段。 #2 示例 下面的 Crash Log 取自于天猫客户端，Log 中不重要的部分已经被略去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Incident Identifier: C7F427F7-FDF8-41C3-9659-3C54756B1547CrashReporter Key: TODOHardware Model: iPhone8,2Process: Tmall4iPhone [1313]Path: /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhoneIdentifier: Unknown|com.taobao.tmallVersion: 5.24.1 (5.24.1)Code Type: ARM-64Parent Process: ??? [1]Date/Time: 2016-10-07 03:16:35 +0000OS Version: iPhone OS 10.0.1 (14A403)Report Version: 104Exception Type: SIGSEGVException Codes: SEGV_ACCERR at 0x110Triggered by Thread: 42Thread 0:0 libsystem_kernel.dylib 0x0000000186bf016c _mach_msg_trap :8 (in libsystem_kernel.dylib)1 CoreFoundation 0x0000000187bedcec ___CFRunLoopServiceMachPort :192 (in CoreFoundation)2 CoreFoundation 0x0000000187beb908 ___CFRunLoopRun :1132 (in CoreFoundation)3 CoreFoundation 0x0000000187b1a048 _CFRunLoopRunSpecific :444 (in CoreFoundation)4 GraphicsServices 0x000000018959d198 _GSEventRunModal :180 (in GraphicsServices)5 UIKit 0x000000018daf3818 -[UIApplication _run] :684 (in UIKit)6 UIKit 0x000000018daee550 _UIApplicationMain :208 (in UIKit)7 Tmall4iPhone 0x000000010006bf7c main main.m:27 (in Tmall4iPhone)8 libdyld.dylib 0x0000000186afc5b8 _start :4 (in libdyld.dylib)Thread 42 Crashed:0 CFNetwork 0x00000001883cd970 __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 (in CFNetwork)1 CFNetwork 0x00000001882a49c4 __ZN14SPDYConnection20_onqueue_closeStreamEP10SPDYStream :236 (in CFNetwork)2 CFNetwork 0x00000001882a48b4 ____ZN14SPDYConnection19startEnqueuedStreamEP10SPDYStream_block_invoke_2 :28 (in CFNetwork)3 libdispatch.dylib 0x0000000186ac9200 __dispatch_call_block_and_release :24 (in libdispatch.dylib)4 libdispatch.dylib 0x0000000186ac91c0 __dispatch_client_callout :16 (in libdispatch.dylib)5 libdispatch.dylib 0x0000000186ad7444 __dispatch_queue_serial_drain :928 (in libdispatch.dylib)6 libdispatch.dylib 0x0000000186acc9a8 __dispatch_queue_invoke :652 (in libdispatch.dylib)7 libdispatch.dylib 0x0000000186ad938c __dispatch_root_queue_drain :572 (in libdispatch.dylib)8 libdispatch.dylib 0x0000000186ad90ec __dispatch_worker_thread3 :124 (in libdispatch.dylib)9 libsystem_pthread.dylib 0x0000000186cd12c8 __pthread_wqthread :1288 (in libsystem_pthread.dylib)10 libsystem_pthread.dylib 0x0000000186cd0db4 _start_wqthread :4 (in libsystem_pthread.dylib)Thread State: lr:0x00000001882a49c4 x6:0x0000000170ade8b0 x7:0x0000000000000450 x4:0x0000000000000001 x5:0x0000000000000010 x2:0x0000021aaf85c0e0 x3:0xfffffff0001fc088 x0:0x0000000000000000 x1:0x00000001ab457998 cpsr:0x0000000080000000 x10:0x0000000000077234 x16:0xfffffff100000000 x15:0xfffffff500000000 x18:0x0000000000000000 x17:0x003000000000f49f x12:0xffc0000800000000 x11:0x0000000000049198 x14:0xfffffffd00000001 fp:0x000000016e5b2c50 x13:0x0000000800000000 sp:0x000000016e5b2b70 x19:0x00000001701574a0 x21:0x00000001ab457998 x9:0x0000000000000000 x8:0x00000001a6bcc000 x20:0x0000000000000000 pc:0x00000001883cd970 x28:0xffffffffffffffff x27:0x000000016e5b30e0 x26:0x0000000000000014 x25:0x0000000000000000 x24:0x0000000000000000 x23:0x00000001746f2580 x22:0xdc990b23045700adBinary Images:0x0000000100064000 - 0x0000000103517fff Tmall4iPhone arm64 &lt;d21caba7463b3a38a7ee3ae16448f4b6&gt; /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhone0x000000018823b000 - 0x00000001885aafff CFNetwork arm64 &lt;ca09941bfd353bb8b6b679a0f14cad1e&gt; /System/Library/Frameworks/CFNetwork.framework/CFNetwork #3 关注点 Identifier: Unknown|com.taobao.tmall, 在这里区分是线上版本还是线下开发版本. Version: 5.24.1 (5.24.1), 应用版本号. Code Type: ARM-64, 代码架构, 目前有ARM/ARM-64两种. OS Version: iPhone OS 10.0.1 (14A403), 系统版本及build号, 用来查找系统库文件, 用于疑难问题的排查. Exception Type: SIGSEGV, 异常类型常见的有SIGSEGV/SIGABRT/SIGTRAP/SIGBUS/SIGILL等. Exception Codes: SEGV_ACCERR at 0x110, 非法访问0x110这个没有访问权限的地址. Triggered by Thread: 42, 挂的线程是Thread 42, 待会看调用栈的时候, 看Thread 42的调用栈就好. 12345SIGSEGV 访问了非法的地址(地址还没有从系统映射到当前进程的内存空间), 一般是野指针导致, 而野指针一般由于多线程操作对象导致.SIGABRT 一般是Exception或者其他的代码主动退出的问题.SIGTRAP 代码里面触发了调试指令, 该指令可能由编译器提供的trap方法触发, 如'__builtin_trap()'SIGBUS 一般由于地址对齐问题导致, 单纯的OC代码挺难触发的, 主要是系统库方法或者其他c实现的方法导致SIGILL 表示执行了非法的cpu指令, 但是一般是由于死循环导致 那么我们来看 Thread 42 123Thread 42 Crashed:0 CFNetwork 0x00000001883cd970 __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 (in CFNetwork)1 CoreFoundation 0x0000000187bedcec ___CFRunLoopServiceMachPort :192 (in CoreFoundation) 这里我们取了两条调用栈记录, 这里的每条调用记录都叫做frame, 每条有一个编号0和1, 这个编号代表的是frame number, 它是当前frame在整个调用栈中的索引. 先看frame #0, frame #0是当前调用的方法的信息, 0 CFNetwork 0x00000001883cd970 __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 (in CFNetwork), CFNetwork代表当前frame调用的方法所在的镜像(可执行文件或动态库)的名称, 0x00000001883cd970代表当前执行的指令在内存中的地址(也就是crash的指令的地址), __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 是前面那个地址符号化后的方法名称, :44表示挂的指令相对于符号化出来的方法的首地址的偏移量. 再看frame #1, frame #1是调用frame #0方法的地方, 1 CoreFoundation 0x0000000187bedcec ___CFRunLoopServiceMachPort :192 (in CoreFoundation), 镜像名和地址不多说, 这里要说说偏移量:192, 除了frame #0的方法地址是取的pc寄存器的内容(存放的当前指令的地址), 而其他frame实际上存的都是历史记录, 而为了省内存和cpu, frame中并不会保存所有的寄存器的值, 只存了lr寄存器的内容(存放的是方法调用完后要返回的地址), 而返回地址是调用方法的地址的下一个指令地址. 因此偏移量192(lr), 对应的调用处的地址是188(pc). 其他frame的看法参见frame #1. Thread State:, 后面跟的内容是在frame #0挂的时候的所有寄存器的值, 寄存器中可能存放的是一个指令的地址/一个指向对象的指针/一个数值. 寄存器的值结合汇编代码, 可以推断具体是对某个方法调用的参数或者类的成员变量导致的野指针. 后续会有详细的问题分析实战文章做介绍. Binary Images: 表示当前运行时所加载的所有的镜像的名称/uuid/加载地址等信息. 看一条示例: 10x0000000100064000 - 0x0000000103517fff Tmall4iPhone arm64 &lt;d21caba7463b3a38a7ee3ae16448f4b6&gt; /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhone 000000100064000 - 0x0000000103517fff表示镜像Tmall4iPhone在内存中的加载地址的起始范围, 这个在符号化和调试疑难问题时是一个很重要的参考. Tmall4iPhone是镜像名称, arm64是架构, d21caba7463b3a38a7ee3ae16448f4b6是镜像的uuid, /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhone是镜像在用户手机上地址. 注1: uuid可以通过dwarfdump --uuid Tmall4iPhone 查看, 确定镜像是否相同.","link":"/back/%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90Crash%E6%97%A5%E5%BF%97.html"},{"title":"深入理解 autorelease","text":"深入理解 autorelease 先上一段代码，分别实现了包含 autorelease pool 不包含 autorelease pool 的函数 123456789void autoreleasepool() { @autoreleasepool { NSObject *a = [[NSObject alloc] init]; }}void noautoreleasepool() { NSObject *a = [[NSObject alloc] init];} 编译后再用hopper disassembler 反编译，然后看 autorelasepool函数的汇编代码。 123456789101112131415161718192021222324252627282930 _autoreleasepool:0000000100006b80 stp x29, x30, [sp, #0xfffffff0]! ; XREF=_main+240000000100006b84 mov x29, sp0000000100006b88 sub sp, sp, #0x100000000100006b8c bl imp___stubs__objc_autoreleasePoolPush0000000100006b90 adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006b94 add x8, x8, #0xc30 ; @selector(alloc)0000000100006b98 adrp x9, #0x100008000 ; imp___got_dyld_stub_binder0000000100006b9c add x9, x9, #0xc40 ; objc_cls_ref_NSObject0000000100006ba0 ldr x9, [x9] ; objc_cls_ref_NSObject0000000100006ba4 ldr x1, [x8] ; @selector(alloc)0000000100006ba8 str x0, [sp]0000000100006bac mov x0, x90000000100006bb0 bl imp___stubs__objc_msgSend0000000100006bb4 adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006bb8 add x8, x8, #0xc38 ; @selector(init)0000000100006bbc ldr x1, [x8] ; @selector(init)0000000100006bc0 bl imp___stubs__objc_msgSend0000000100006bc4 movz x8, #0x00000000100006bc8 add x9, sp, #0x80000000100006bcc str x0, [sp, #0x8]0000000100006bd0 mov x0, x90000000100006bd4 mov x1, x80000000100006bd8 bl imp___stubs__objc_storeStrong0000000100006bdc ldr x0, [sp]0000000100006be0 bl imp___stubs__objc_autoreleasePoolPop0000000100006be4 mov sp, x290000000100006be8 ldp x29, x30, [sp], #0x100000000100006bec ret ; endp 再看 noautoreleasepool 函数的反汇编代码： 1234567891011121314151617181920212223242526 _noautoreleasepool:0000000100006bf0 stp x29, x30, [sp, #0xfffffff0]! ; XREF=_main+280000000100006bf4 mov x29, sp0000000100006bf8 sub sp, sp, #0x100000000100006bfc adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006c00 add x8, x8, #0xc30 ; @selector(alloc)0000000100006c04 adrp x9, #0x100008000 ; imp___got_dyld_stub_binder0000000100006c08 add x9, x9, #0xc40 ; objc_cls_ref_NSObject0000000100006c0c ldr x9, [x9] ; objc_cls_ref_NSObject0000000100006c10 ldr x1, [x8] ; @selector(alloc)0000000100006c14 mov x0, x90000000100006c18 bl imp___stubs__objc_msgSend0000000100006c1c adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006c20 add x8, x8, #0xc38 ; @selector(init)0000000100006c24 ldr x1, [x8] ; @selector(init)0000000100006c28 bl imp___stubs__objc_msgSend0000000100006c2c movz x8, #0x00000000100006c30 add x9, sp, #0x80000000100006c34 str x0, [sp, #0x8]0000000100006c38 mov x0, x90000000100006c3c mov x1, x80000000100006c40 bl imp___stubs__objc_storeStrong0000000100006c44 mov sp, x290000000100006c48 ldp x29, x30, [sp], #0x100000000100006c4c ret ; endp 两者的区别是 autorelease 版本多了如下内容 12345670000000100006b8c bl imp___stubs__objc_autoreleasePoolPush ; 调用 objc_autoreleasePoolPush方法0000000100006ba8 str x0, [sp] ; 把objc_autoreleasePoolPush的返回值入栈......0000000100006bdc ldr x0, [sp] ; 把之前入栈的返回值出栈0000000100006be0 bl imp___stubs__objc_autoreleasePoolPop ; 调用objc_autoreleasePoolPop方法 发现了和预想不一样的地方，按照常理，在 autoreleasepool 里面的对象初始化的时候，似乎要调用-[NSObject autorelease] 来让他自动释放，然而，并没有。 看看 objc 的源码 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 的实现。 objc_autoreleasePoolPush 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void *objc_autoreleasePoolPush(void){ if (UseGC) return nil; return AutoreleasePoolPage::push();}static inline void *push() { id *dest; if (DebugPoolAllocation) { // Each autorelease pool starts on a new pool page. dest = autoreleaseNewPage(POOL_SENTINEL); } else { dest = autoreleaseFast(POOL_SENTINEL); } assert(*dest == POOL_SENTINEL); return dest;}static inline id *autoreleaseFast(id obj){ AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) { return page-&gt;add(obj); } else if (page) { return autoreleaseFullPage(obj, page); } else { return autoreleaseNoPage(obj); }}static __attribute__((noinline))id *autoreleaseNoPage(id obj){ // No pool in place. assert(!hotPage()); if (obj != POOL_SENTINEL &amp;&amp; DebugMissingPools) { // We are pushing an object with no pool in place, // and no-pool debugging was requested by environment. _objc_inform(&quot;MISSING POOLS: Object %p of class %s &quot; &quot;autoreleased with no pool in place - &quot; &quot;just leaking - break on &quot; &quot;objc_autoreleaseNoPool() to debug&quot;, (void*)obj, object_getClassName(obj)); objc_autoreleaseNoPool(obj); return nil; } // Install the first page. AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); // Push an autorelease pool boundary if it wasn't already requested. if (obj != POOL_SENTINEL) { page-&gt;add(POOL_SENTINEL); } // Push the requested object. return page-&gt;add(obj);} push 的主要作用是选一个/建一个autoreleasePoolPage ，设定为hotpage备用，流程图如下 objc_autoreleasePoolPop 1","link":"/back/%E7%90%86%E8%A7%A3autorelease.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"路由","text":"APP 内组件路由设计 APP内部主要为了解决两个问题 1. 各个页面和组件之间的跳转问题 2. 各个组件之间的相互调用. 各个页面和组件之间的跳转问题 屏幕快照 2018-02-27 下午4.11.24 在iOS开发的过程中，经常会遇到以下的场景，点击按钮跳转Push到另外一个界面，或者点击一个cell Present一个新的ViewController。在MVC模式中，一般都是新建一个VC，然后Push / Present到下一个VC。但是在MVVM中，会有一些不合适的情况。 40_17 众所周知，MVVM把MVC拆成了上图演示的样子，原来View对应的与数据相关的代码都移到ViewModel中，相应的C也变瘦了，演变成了M-VM-C-V的结构。这里的C里面的代码可以只剩下页面跳转相关的逻辑。如果用代码表示就是下面这样子： 假设一个按钮的执行逻辑都封装成了command。 123456 @weakify(self); [[[_viewModel.someCommand executionSignals] flatten] subscribeNext:^(id x) { @strongify(self); // 跳转逻辑 [self.navigationController pushViewController:targetViewController animated:YES];}]; MVVM框架的目的除去解耦以外，还有2个很重要的目的： 代码复用率高 方便进行单元测试 如果需要测试一个业务是否正确，我们只要对ViewModel进行单元测试即可。前提是假定我们使用ReactiveCocoa进行UI绑定的过程是准确无误的。目前绑定是正确的。所以我们只需要单元测试到ViewModel即可完成业务逻辑的测试。 页面跳转也属于业务逻辑，所以应该放在ViewModel中一起单元测试，保证业务逻辑测试的覆盖率。 把页面跳转放到ViewModel中，有2种做法，第一种就是用路由来实现，第二种由于和路由没有关系，所以这里就不多阐述，有兴趣的可以看lpd-mvvm-kit这个库关于页面跳转的具体实现。 页面跳转相互的耦合性也就体现出来了： 由于pushViewController或者presentViewController，后面都需要带一个待操作的ViewController，那么就必须要引入该类，import头文件也就引入了耦合性。 由于跳转这里写死了跳转操作，如果线上一旦出现了bug，这里是不受我们控制的。 推送消息或者是3D-Touch需求，要求直接跳转到内部第10级界面，那么就需要写一个入口跳转到指定界面。 各个组件之间的相互调用 屏幕快照 2018-02-27 下午4.24.18 关于组件间的调用，也需要解耦。随着业务越来越复杂，我们封装的组件越来越多，要是封装的粒度拿捏不准，就会出现大量组件之间耦合度高的问题。组件的粒度可以随着业务的调整，不断的调整组件职责的划分。但是组件之间的调用依旧不可避免，相互调用对方组件暴露的接口。如何减少各个组件之间的耦合度，是一个设计优秀的路由的职责所在。 如何设计一个路由 方案调研 JLRoutes JLRoutes 使用 URL Scheme 的方式，将所有的资源看成是一个URL。 JLRoutes 将传入的 URL Scheme 按照上面的样子进行分割，并获取NSURLComponent JLRoutes全局会保存一个Map，这个Map会以scheme为Key，JLRoutes为Value。所以在routeControllerMap里面每个scheme都是唯一的。 在每个JLRoutes里面都保存了一个数组，这个数组里面保存了每个路由规则JLRRouteDefinition里面会保存外部传进来的block闭包，pattern，和拆分之后的pattern。 在每个JLRoutes的数组里面，会按照路由的优先级进行排列，优先级高的排列在前面。 123456789101112131415161718192021222324252627- (void)_registerRoute:(NSString *)routePattern priority:(NSUInteger)priority handler:(BOOL (^)(NSDictionary *parameters))handlerBlock{ JLRRouteDefinition *route = [[JLRRouteDefinition alloc] initWithScheme:self.scheme pattern:routePattern priority:priority handlerBlock:handlerBlock]; if (priority == 0 || self.routes.count == 0) { [self.routes addObject:route]; } else { NSUInteger index = 0; BOOL addedRoute = NO; // 找到当前已经存在的一条优先级比当前待插入的路由低的路由 for (JLRRouteDefinition *existingRoute in [self.routes copy]) { if (existingRoute.priority &lt; priority) { // 如果找到，就插入数组 [self.routes insertObject:route atIndex:index]; addedRoute = YES; break; } index++; } // 如果没有找到任何一条路由比当前待插入的路由低的路由，或者最后一条路由优先级和当前路由一样，那么就只能插入到最后。 if (!addedRoute) { [self.routes addObject:route]; } }} 由于这个数组里面的路由是一个单调队列，所以查找优先级的时候只用从高往低遍历即可。 具体查找路由的过程如下 首先根据外部传进来的URL初始化一个JLRRouteRequest，然后用这个JLRRouteRequest在当前的路由数组里面依次request，每个规则都会生成一个response，但是只有符合条件的response才会match，最后取出匹配的JLRRouteResponse拿出其字典parameters里面对应的参数就可以了。查找和匹配过程中重要的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859- (BOOL)_routeURL:(NSURL *)URL withParameters:(NSDictionary *)parameters executeRouteBlock:(BOOL)executeRouteBlock{ if (!URL) { return NO; } [self _verboseLog:@&quot;Trying to route URL %@&quot;, URL]; BOOL didRoute = NO; JLRRouteRequest *request = [[JLRRouteRequest alloc] initWithURL:URL]; for (JLRRouteDefinition *route in [self.routes copy]) { // 检查每一个route，生成对应的response JLRRouteResponse *response = [route routeResponseForRequest:request decodePlusSymbols:shouldDecodePlusSymbols]; if (!response.isMatch) { continue; } [self _verboseLog:@&quot;Successfully matched %@&quot;, route]; if (!executeRouteBlock) { // 如果我们被要求不允许执行，但是又找了匹配的路由response。 return YES; } // 装配最后的参数 NSMutableDictionary *finalParameters = [NSMutableDictionary dictionary]; [finalParameters addEntriesFromDictionary:response.parameters]; [finalParameters addEntriesFromDictionary:parameters]; [self _verboseLog:@&quot;Final parameters are %@&quot;, finalParameters]; didRoute = [route callHandlerBlockWithParameters:finalParameters]; if (didRoute) { // 调用Handler成功 break; } } if (!didRoute) { [self _verboseLog:@&quot;Could not find a matching route&quot;]; } // 如果在当前路由规则里面没有找到匹配的路由，当前路由不是global 的，并且允许降级到global里面去查找，那么我们继续在global的路由规则里面去查找。 if (!didRoute &amp;&amp; self.shouldFallbackToGlobalRoutes &amp;&amp; ![self _isGlobalRoutesController]) { [self _verboseLog:@&quot;Falling back to global routes...&quot;]; didRoute = [[JLRoutes globalRoutes] _routeURL:URL withParameters:parameters executeRouteBlock:executeRouteBlock]; } // 最后，依旧没有找到任何能匹配的，如果有unmatched URL handler，调用这个闭包进行最后的处理。if, after everything, we did not route anything and we have an unmatched URL handler, then call it if (!didRoute &amp;&amp; executeRouteBlock &amp;&amp; self.unmatchedURLHandler) { [self _verboseLog:@&quot;Falling back to the unmatched URL handler&quot;]; self.unmatchedURLHandler(self, URL, parameters); } return didRoute;} 举个例子 先注册一个Router，规则如下: 123456[[JLRoutes globalRoutes] addRoute:@&quot;/:object/:action&quot; handler:^BOOL(NSDictionary *parameters) { NSString *object = parameters[@&quot;object&quot;]; NSString *action = parameters[@&quot;action&quot;]; // stuff return YES;}]; 传入一个URL， 让 Route 处理 12NSURL *editPost = [NSURL URLWithString:@&quot;ele://post/halfrost?debug=true&amp;foo=bar&quot;]; [[UIApplication sharedApplication] openURL:editPost]; 匹配之后，得到如下的字典 123456789{ &quot;object&quot;: &quot;post&quot;, &quot;action&quot;: &quot;halfrost&quot;, &quot;debug&quot;: &quot;true&quot;, &quot;foo&quot;: &quot;bar&quot;, &quot;JLRouteURL&quot;: &quot;ele://post/halfrost?debug=true&amp;foo=bar&quot;, &quot;JLRoutePattern&quot;: &quot;/:object/:action&quot;, &quot;JLRouteScheme&quot;: &quot;JLRoutesGlobalRoutesScheme&quot;} 详细过程 JLRoutes还可以支持Optional的路由规则，假如定义一条路由规则： Swift/the(/foo/:a)(/bar/:b) JLRoutes 会帮我们默认注册如下4条路由规则： 1234/the/foo/:a/bar/:b/the/foo/:a/the/bar/:b/the routable-ios Routable路由是用在in-app native端的 URL router, 它可以用在iOS上也可以用在 Android UPRouter里面保存了2个字典。 routes字典里面存储的Key是路由规则，Value存储的是UPRouterOptions。 cachedRoutes里面存储的Key是最终的URL，带传参的，Value存储的是RouterParams。RouterParams里面会包含在routes匹配的到的UPRouterOptions，还有额外的打开参数openParams和一些额外参数extraParams。 这一段代码里面重点在干一件事情，遍历routes字典，然后找到参数匹配的字符串，封装成RouterParams返回。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (RouterParams *)routerParamsForUrl:(NSString *)url extraParams: (NSDictionary *)extraParams { if (!url) { //if we wait, caching this as key would throw an exception if (_ignoresExceptions) { return nil; } @throw [NSException exceptionWithName:@&quot;RouteNotFoundException&quot; reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url] userInfo:nil]; } if ([self.cachedRoutes objectForKey:url] &amp;&amp; !extraParams) { return [self.cachedRoutes objectForKey:url]; } // 比对url通过/分割之后的参数个数和pathComponents的个数是否一样 NSArray *givenParts = url.pathComponents; NSArray *legacyParts = [url componentsSeparatedByString:@&quot;/&quot;]; if ([legacyParts count] != [givenParts count]) { NSLog(@&quot;Routable Warning - your URL %@ has empty path components - this will throw an error in an upcoming release&quot;, url); givenParts = legacyParts; } __block RouterParams *openParams = nil; [self.routes enumerateKeysAndObjectsUsingBlock: ^(NSString *routerUrl, UPRouterOptions *routerOptions, BOOL *stop) { NSArray *routerParts = [routerUrl pathComponents]; if ([routerParts count] == [givenParts count]) { NSDictionary *givenParams = [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts]; if (givenParams) { openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams]; *stop = YES; } } }]; if (!openParams) { if (_ignoresExceptions) { return nil; } @throw [NSException exceptionWithName:@&quot;RouteNotFoundException&quot; reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url] userInfo:nil]; } [self.cachedRoutes setObject:openParams forKey:url]; return openParams;} 下面这段函数，第一个参数是外部传进来URL带有各个入参的分割数组。第二个参数是路由规则分割开的数组。routerComponent由于规定：号后面才是参数，所以routerComponent的第1个位置就是对应的参数名。params字典里面以参数名为Key，参数为Value。 123456789101112131415161718- (NSDictionary *)paramsForUrlComponents:(NSArray *)givenUrlComponents routerUrlComponents:(NSArray *)routerUrlComponents { __block NSMutableDictionary *params = [NSMutableDictionary dictionary]; [routerUrlComponents enumerateObjectsUsingBlock: ^(NSString *routerComponent, NSUInteger idx, BOOL *stop) { NSString *givenComponent = givenUrlComponents[idx]; if ([routerComponent hasPrefix:@&quot;:&quot;]) { NSString *key = [routerComponent substringFromIndex:1]; [params setObject:givenComponent forKey:key]; } else if (![routerComponent isEqualToString:givenComponent]) { params = nil; *stop = YES; } }]; return params;} 通过RouterParams的初始化方法，把路由规则对应的UPRouterOptions，上一步封装好的参数字典givenParams，还有 routerParamsForUrl: extraParams: 方法的第二个入参，这3个参数作为初始化参数，生成了一个RouterParams 12345 NSDictionary *givenParams = [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts];if (givenParams) { openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams]; *stop = YES;} 最后一步self.cachedRoutes的字典里面Key为带参数的URL，Value是RouterParams。 1[self.cachedRoutes setObject:openParams forKey:url]; 最后将匹配封装出来的RouterParams转换成对应的Controller。 123456789101112131415161718192021222324252627- (UIViewController *)controllerForRouterParams:(RouterParams *)params { SEL CONTROLLER_CLASS_SELECTOR = sel_registerName(&quot;allocWithRouterParams:&quot;); SEL CONTROLLER_SELECTOR = sel_registerName(&quot;initWithRouterParams:&quot;); UIViewController *controller = nil; Class controllerClass = params.routerOptions.openClass;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; if ([controllerClass respondsToSelector:CONTROLLER_CLASS_SELECTOR]) { controller = [controllerClass performSelector:CONTROLLER_CLASS_SELECTOR withObject:[params controllerParams]]; } else if ([params.routerOptions.openClass instancesRespondToSelector:CONTROLLER_SELECTOR]) { controller = [[params.routerOptions.openClass alloc] performSelector:CONTROLLER_SELECTOR withObject:[params controllerParams]]; }#pragma clang diagnostic pop if (!controller) { if (_ignoresExceptions) { return controller; } @throw [NSException exceptionWithName:@&quot;RoutableInitializerNotFound&quot; reason:[NSString stringWithFormat:INVALID_CONTROLLER_FORMAT, NSStringFromClass(controllerClass), NSStringFromSelector(CONTROLLER_CLASS_SELECTOR), NSStringFromSelector(CONTROLLER_SELECTOR)] userInfo:nil]; } controller.modalTransitionStyle = params.routerOptions.transitionStyle; controller.modalPresentationStyle = params.routerOptions.presentationStyle; return controller;} 如果Controller是一个类，那么就调用allocWithRouterParams:方法去初始化。如果Controller已经是一个实例了，那么就调用initWithRouterParams:方法去初始化。 将Routable的大致流程图解如下： HHRouter ViewController提供了2个方法。map是用来设置路由规则，matchController是用来匹配路由规则的，匹配争取之后返回对应的UIViewController。 12- (void)map:(NSString *)route toControllerClass:(Class)controllerClass;- (UIViewController *)matchController:(NSString *)route; block闭包提供了三个方法，map也是设置路由规则，matchBlock：是用来匹配路由，找到指定的block，但是不会调用该block。callBlock:是找到指定的block，找到以后就立即调用。 1234- (void)map:(NSString *)route toBlock:(HHRouterBlock)block;- (HHRouterBlock)matchBlock:(NSString *)route;- (id)callBlock:(NSString *)route; matchBlock:和callBlock:的区别就在于前者不会自动调用闭包。所以matchBlock:方法找到对应的block之后，如果想调用，需要手动调用一次。 除去上面这些方法，HHRouter还为我们提供了一个特殊的方法。 1- (HHRouteType)canRoute:(NSString *)route; 这个方法就是用来找到执行路由规则对应的RouteType，RouteType总共就3种: 12345typedef NS_ENUM (NSInteger, HHRouteType) { HHRouteTypeNone = 0, HHRouteTypeViewController = 1, HHRouteTypeBlock = 2}; 再来看看HHRouter是如何管理路由规则的。整个HHRouter就是由一个NSMutableDictionary *routes控制的。 123@interface HHRouter ()@property (strong, nonatomic) NSMutableDictionary *routes;@end 别看只有这一个看似“简单”的字典数据结构，但是HHRouter路由设计的还是很精妙的。 1234567891011- (void)map:(NSString *)route toBlock:(HHRouterBlock)block{ NSMutableDictionary *subRoutes = [self subRoutesToRoute:route]; subRoutes[@&quot;_&quot;] = [block copy];}- (void)map:(NSString *)route toControllerClass:(Class)controllerClass{ NSMutableDictionary *subRoutes = [self subRoutesToRoute:route]; subRoutes[@&quot;_&quot;] = controllerClass;} 上面两个方法分别是block闭包和ViewController设置路由规则调用的方法实体。不管是ViewController还是block闭包，设置规则的时候都会调用subRoutesToRoute:方法。 123456789101112131415161718- (NSMutableDictionary *)subRoutesToRoute:(NSString *)route{ NSArray *pathComponents = [self pathComponentsFromRoute:route]; NSInteger index = 0; NSMutableDictionary *subRoutes = self.routes; while (index &lt; pathComponents.count) { NSString *pathComponent = pathComponents[index]; if (![subRoutes objectForKey:pathComponent]) { subRoutes[pathComponent] = [[NSMutableDictionary alloc] init]; } subRoutes = subRoutes[pathComponent]; index++; } return subRoutes;} 上面这段函数就是来构造路由匹配规则的字典。 举个例子： 123456[[HHRouter shared] map:@&quot;/user/:userId/&quot; toControllerClass:[UserViewController class]];[[HHRouter shared] map:@&quot;/story/:storyId/&quot; toControllerClass:[StoryViewController class]];[[HHRouter shared] map:@&quot;/user/:userId/story/?a=0&quot; toControllerClass:[StoryListViewController class]]; 设置3条规则以后，按照上面构造路由匹配规则的字典的方法，该路由规则字典就会变成这个样子： 123456789101112131415{ story = { &quot;:storyId&quot; = { &quot;_&quot; = StoryViewController; }; }; user = { &quot;:userId&quot; = { &quot;_&quot; = UserViewController; story = { &quot;_&quot; = StoryListViewController; }; }; };} 路由规则字典生成之后，等到匹配的时候就会遍历这个字典。 假设这时候有一条路由过来： 1[[[HHRouter shared] matchController:@&quot;hhrouter20://user/1/&quot;] class], HHRouter对这条路由的处理方式是先匹配前面的scheme，如果连scheme都不正确的话，会直接导致后面匹配失败。 然后再进行路由匹配，最后生成的参数字典如下： 12345{ &quot;controller_class&quot; = UserViewController; route = &quot;/user/1/&quot;; userId = 1;} 具体的路由参数匹配的函数在 1- (NSDictionary *)paramsInRoute:(NSString *)route 个方法里面实现的。这个方法就是按照路由匹配规则，把传进来的URL的参数都一一解析出来，带？号的也都会解析成字典。这个方法没什么难度，就不在赘述了。 ViewController 的字典里面默认还会加上2项： 12&quot;controller_class&quot; = route = route里面都会保存传过来的完整的URL。 如果传进来的路由后面带访问字符串呢？那我们再来看看： 1[[HHRouter shared] matchController:@&quot;/user/1/?a=b&amp;c=d&quot;] 那么解析出所有的参数字典会是下面的样子： 1234567{ a = b; c = d; &quot;controller_class&quot; = UserViewController; route = &quot;/user/1/?a=b&amp;c=d&quot;; userId = 1;} 同理，如果是一个block闭包的情况呢？ 还是先添加一条block闭包的路由规则： 12[[HHRouter shared] map:@&quot;/user/add/&quot; toBlock:^id(NSDictionary* params) {}]; 这条规则对应的会生成一个路由规则的字典。 123456789101112131415161718{ story = { &quot;:storyId&quot; = { &quot;_&quot; = StoryViewController; }; }; user = { &quot;:userId&quot; = { &quot;_&quot; = UserViewController; story = { &quot;_&quot; = StoryListViewController; }; }; add = { &quot;_&quot; = &quot;&lt;__NSMallocBlock__: 0x600000240480&gt;&quot;; }; };} 注意”_”后面跟着是一个block。 匹配block闭包的方式有两种。 1234567// 1.第一种方式匹配到对应的block之后，还需要手动调用一次闭包。 HHRouterBlock block = [[HHRouter shared] matchBlock:@&quot;/user/add/?a=1&amp;b=2&quot;]; block(nil);// 2.第二种方式匹配block之后自动会调用改闭包。 [[HHRouter shared] callBlock:@&quot;/user/add/?a=1&amp;b=2&quot;]; 匹配出来的参数字典是如下： 123456{ a = 1; b = 2; block = &quot;&lt;__NSMallocBlock__: 0x600000056b90&gt;&quot;; route = &quot;/user/add/?a=1&amp;b=2&quot;;} block的字典里面会默认加上下面这2项： 12block = route = route里面都会保存传过来的完整的URL。 生成的参数字典最终会被绑定到ViewController的Associated Object关联对象上。 123456789- (void)setParams:(NSDictionary *)paramsDictionary{ objc_setAssociatedObject(self, &amp;kAssociatedParamsObjectKey, paramsDictionary, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (NSDictionary *)params{ return objc_getAssociatedObject(self, &amp;kAssociatedParamsObjectKey);} 这个绑定的过程是在match匹配完成的时候进行的。 12345678910111213- (UIViewController *)matchController:(NSString *)route{ NSDictionary *params = [self paramsInRoute:route]; Class controllerClass = params[@&quot;controller_class&quot;]; UIViewController *viewController = [[controllerClass alloc] init]; if ([viewController respondsToSelector:@selector(setParams:)]) { [viewController performSelector:@selector(setParams:) withObject:[params copy]]; } return viewController;} 最终得到的ViewController也是我们想要的。相应的参数都在它绑定的params属性的字典里面。 将上述过程图解出来，如下： MGJRouter JLRoutes 的问题主要在于查找 URL 的实现不够高效，通过遍历而不是匹配。还有就是功能偏多。 HHRouter 的 URL 查找是基于匹配，所以会更高效，MGJRouter 也是采用的这种方法，但它跟 ViewController 绑定地过于紧密，一定程度上降低了灵活性。 于是就有了 MGJRouter。 从数据结构来看，MGJRouter还是和HHRouter一模一样的 123@interface MGJRouter ()@property (nonatomic) NSMutableDictionary *routes;@end 那么我们就来看看它对HHRouter做了哪些优化改进。 1.MGJRouter支持openURL时，可以传一些 userinfo 过去 1[MGJRouter openURL:@&quot;mgj://category/travel&quot; withUserInfo:@{@&quot;user_id&quot;: @1900} completion:nil]; 这个对比HHRouter，仅仅只是写法上的一个语法糖，在HHRouter中虽然不支持带字典的参数，但是在URL后面可以用URL Query Parameter来弥补。 12345678910111213if (parameters) { MGJRouterHandler handler = parameters[@&quot;block&quot;]; if (completion) { parameters[MGJRouterParameterCompletion] = completion; } if (userInfo) { parameters[MGJRouterParameterUserInfo] = userInfo; } if (handler) { [parameters removeObjectForKey:@&quot;block&quot;]; handler(parameters); } } MGJRouter对userInfo的处理是直接把它封装到Key = MGJRouterParameterUserInfo对应的Value里面。 2.支持中文的URL。 12345[parameters enumerateKeysAndObjectsUsingBlock:^(id key, NSString *obj, BOOL *stop) { if ([obj isKindOfClass:[NSString class]]) { parameters[key] = [obj stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; } }]; 这里就是需要注意一下编码。 3.定义一个全局的 URL Pattern 作为 Fallback。 这一点是模仿的JLRoutes的匹配不到会自动降级到global的思想。 1234567if (parameters) { MGJRouterHandler handler = parameters[@&quot;block&quot;]; if (handler) { [parameters removeObjectForKey:@&quot;block&quot;]; handler(parameters); } } parameters字典里面会先存储下一个路由规则，存在block闭包中，在匹配的时候会取出这个handler，降级匹配到这个闭包中，进行最终的处理。 4.当 OpenURL 结束时，可以执行 Completion Block。 在MGJRouter里面，作者对原来的HHRouter字典里面存储的路由规则的结构进行了改造。 123NSString *const MGJRouterParameterURL = @&quot;MGJRouterParameterURL&quot;; NSString *const MGJRouterParameterCompletion = @&quot;MGJRouterParameterCompletion&quot;; NSString *const MGJRouterParameterUserInfo = @&quot;MGJRouterParameterUserInfo&quot;; 这3个key会分别保存一些信息： MGJRouterParameterURL保存的传进来的完整的URL信息。 MGJRouterParameterCompletion保存的是completion闭包。 MGJRouterParameterUserInfo保存的是UserInfo字典。 举个例子： 12345678910[MGJRouter registerURLPattern:@&quot;ele://name/:name&quot; toHandler:^(NSDictionary *routerParameters) { void (^completion)(NSString *) = routerParameters[MGJRouterParameterCompletion]; if (completion) { completion(@&quot;完成了&quot;); } }]; [MGJRouter openURL:@&quot;ele://name/halfrost/?age=20&quot; withUserInfo:@{@&quot;user_id&quot;: @1900} completion:^(id result) { NSLog(@&quot;result = %@&quot;,result); }]; 上面的URL会匹配成功，那么生成的参数字典结构如下： 12345678910{ MGJRouterParameterCompletion = &quot;&lt;__NSGlobalBlock__: 0x107ffe680&gt;&quot;; MGJRouterParameterURL = &quot;ele://name/halfrost/?age=20&quot;; MGJRouterParameterUserInfo = { &quot;user_id&quot; = 1900; }; age = 20; block = &quot;&lt;__NSMallocBlock__: 0x608000252120&gt;&quot;; name = halfrost;} 5.可以统一管理URL 这个功能非常有用。 URL 的处理一不小心，就容易散落在项目的各个角落，不容易管理。比如注册时的 pattern 是 mgj://beauty/:id，然后 open 时就是 mgj://beauty/123，这样到时候 url 有改动，处理起来就会很麻烦，不好统一管理。 所以 MGJRouter 提供了一个类方法来处理这个问题。 12345678#define TEMPLATE_URL @&quot;qq://name/:name&quot;[MGJRouter registerURLPattern:TEMPLATE_URL toHandler:^(NSDictionary *routerParameters) { NSLog(@&quot;routerParameters[name]:%@&quot;, routerParameters[@&quot;name&quot;]); // halfrost}];[MGJRouter openURL:[MGJRouter generateURLWithPattern:TEMPLATE_URL parameters:@[@&quot;halfrost&quot;]]];} generateURLWithPattern:函数会对我们定义的宏里面的所有的:进行替换，替换成后面的字符串数组，依次赋值。 将上述过程图解出来，如下： 蘑菇街为了区分开页面间调用和组件间调用，于是想出了一种新的方法。用Protocol的方法来进行组件间的调用。 每个组件之间都有一个 Entry，这个 Entry，主要做了三件事： 注册这个组件关心的 URL 注册这个组件能够被调用的方法/属性 在 App 生命周期的不同阶段做不同的响应 页面间的openURL调用就是如下的样子： 每个组件间都会向MGJRouter注册，组件间相互调用或者是其他的App都可以通过openURL:方法打开一个界面或者调用一个组件。 在组件间的调用，蘑菇街采用了Protocol的方式。 [ModuleManager registerClass:ClassA forProtocol:ProtocolA] 的结果就是在 MM 内部维护的 dict 里新加了一个映射关系。 [ModuleManager classForProtocol:ProtocolA] 的返回结果就是之前在 MM 内部 dict 里 protocol 对应的 class，使用方不需要关心这个 class 是个什么东东，反正实现了 ProtocolA 协议，拿来用就行。 这里需要有一个公共的地方来容纳这些 public protocl，也就是图中的 PublicProtocl.h。 我猜测，大概实现可能是下面的样子： 123456@interface ModuleProtocolManager : NSObject+ (void)registServiceProvide:(id)provide forProtocol:(Protocol*)protocol;+ (id)serviceProvideForProtocol:(Protocol *)protocol;@end 然后这是一个单例，在这里注册各个协议 12345678910111213141516171819202122232425262728293031323334353637@interface ModuleProtocolManager ()@property (nonatomic, strong) NSMutableDictionary *serviceProvideSource;@end@implementation ModuleProtocolManager+ (ModuleProtocolManager *)sharedInstance{ static ModuleProtocolManager * instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ instance = [[self alloc] init]; }); return instance;}- (instancetype)init{ self = [super init]; if (self) { _serviceProvideSource = [[NSMutableDictionary alloc] init]; } return self;}+ (void)registServiceProvide:(id)provide forProtocol:(Protocol*)protocol{ if (provide == nil || protocol == nil) return; [[self sharedInstance].serviceProvideSource setObject:provide forKey:NSStringFromProtocol(protocol)];}+ (id)serviceProvideForProtocol:(Protocol *)protocol{ return [[self sharedInstance].serviceProvideSource objectForKey:NSStringFromProtocol(protocol)];} 在ModuleProtocolManager中用一个字典保存每个注册的protocol。现在再来猜猜ModuleEntry的实现。 12345678#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@protocol DetailModuleEntryProtocol &lt;NSObject&gt;@required;- (UIViewController *)detailViewControllerWithId:(NSString*)Id Name:(NSString *)name;@end 然后每个模块内都有一个和暴露到外面的协议相连接的“接头”。 1234#import &lt;Foundation/Foundation.h&gt;@interface DetailModuleEntry : NSObject@end 在它的实现中，需要引入3个外部文件，一个是ModuleProtocolManager，一个是DetailModuleEntryProtocol，最后一个是所在模块需要跳转或者调用的组件或者页面。 123456789101112131415161718192021222324#import &quot;DetailModuleEntry.h&quot;#import &lt;DetailModuleEntryProtocol/DetailModuleEntryProtocol.h&gt;#import &lt;ModuleProtocolManager/ModuleProtocolManager.h&gt;#import &quot;DetailViewController.h&quot;@interface DetailModuleEntry()&lt;DetailModuleEntryProtocol&gt;@end@implementation DetailModuleEntry+ (void)load{ [ModuleProtocolManager registServiceProvide:[[self alloc] init] forProtocol:@protocol(DetailModuleEntryProtocol)];}- (UIViewController *)detailViewControllerWithId:(NSString*)Id Name:(NSString *)name{ DetailViewController *detailVC = [[DetailViewController alloc] initWithId:id Name:name]; return detailVC;}@end 至此基于Protocol的方案就完成了。如果需要调用某个组件或者跳转某个页面，只要先从ModuleProtocolManager的字典里面根据对应的ModuleEntryProtocol找到对应的DetailModuleEntry，找到了DetailModuleEntry就是找到了组件或者页面的“入口”了。再把参数传进去即可。 1234567- (void)didClickDetailButton:(UIButton *)button{ id&lt; DetailModuleEntryProtocol &gt; DetailModuleEntry = [ModuleProtocolManager serviceProvideForProtocol:@protocol(DetailModuleEntryProtocol)]; UIViewController *detailVC = [DetailModuleEntry detailViewControllerWithId:@“详情界面” Name:@“我的购物车”]; [self.navigationController pushViewController:detailVC animated:YES];} 这样就可以调用到组件或者界面了。 如果组件之间有相同的接口，那么还可以进一步的把这些接口都抽离出来。这些抽离出来的接口变成“元接口”，它们是可以足够支撑起整个组件一层的。 CTMediator 这方案是基于Mediator的。 传统的中间人Mediator的模式是这样的 这种模式每个页面或者组件都会依赖中间者，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator还是会依赖其他组件。那么这是最终方案了么？ 主要思想是利用了Target-Action简单粗暴的思想，利用Runtime解决解耦的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget{ NSString *targetClassString = [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName]; NSString *actionString = [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName]; Class targetClass; NSObject *target = self.cachedTarget[targetClassString]; if (target == nil) { targetClass = NSClassFromString(targetClassString); target = [[targetClass alloc] init]; } SEL action = NSSelectorFromString(actionString); if (target == nil) { // 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的 return nil; } if (shouldCacheTarget) { self.cachedTarget[targetClassString] = target; } if ([target respondsToSelector:action]) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [target performSelector:action withObject:params];#pragma clang diagnostic pop } else { // 有可能target是Swift对象 actionString = [NSString stringWithFormat:@&quot;Action_%@WithParams:&quot;, actionName]; action = NSSelectorFromString(actionString); if ([target respondsToSelector:action]) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [target performSelector:action withObject:params];#pragma clang diagnostic pop } else { // 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理 SEL action = NSSelectorFromString(@&quot;notFound:&quot;); if ([target respondsToSelector:action]) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [target performSelector:action withObject:params];#pragma clang diagnostic pop } else { // 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。 [self.cachedTarget removeObjectForKey:targetClassString]; return nil; } } }} targetName就是调用接口的Object，actionName就是调用方法的SEL，params是参数，shouldCacheTarget代表是否需要缓存，如果需要缓存就把target存起来，Key是targetClassString，Value是target。 通过这种方式进行改造的，外面调用的方法都很统一，都是调用performTarget: action: params: shouldCacheTarget:。第三个参数是一个字典，这个字典里面可以传很多参数，只要Key-Value写好就可以了。处理错误的方式也统一在一个地方了，target没有，或者是target无法响应相应的方法，都可以在Mediator这里进行统一出错处理。 但是在实际开发过程中，不管是界面调用，组件间调用，在Mediator中需要定义很多方法。于是作者又想出了建议我们用Category的方法，对Mediator的所有方法进行拆分，这样就就可以不会导致Mediator这个类过于庞大了。 123456789101112131415161718192021222324252627282930313233- (UIViewController *)CTMediator_viewControllerForDetail{ UIViewController *viewController = [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativFetchDetailViewController params:@{@&quot;key&quot;:@&quot;value&quot;} shouldCacheTarget:NO ]; if ([viewController isKindOfClass:[UIViewController class]]) { // view controller 交付出去之后，可以由外界选择是push还是present return viewController; } else { // 这里处理异常场景，具体如何处理取决于产品 return [[UIViewController alloc] init]; }}- (void)CTMediator_presentImage:(UIImage *)image{ if (image) { [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativePresentImage params:@{@&quot;image&quot;:image} shouldCacheTarget:NO]; } else { // 这里处理image为nil的场景，如何处理取决于产品 [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativeNoImage params:@{@&quot;image&quot;:[UIImage imageNamed:@&quot;noImage&quot;]} shouldCacheTarget:NO]; }} 把这些具体的方法一个个的都写在Category里面就好了，调用的方式都非常的一致，都是调用performTarget: action: params: shouldCacheTarget:方法。 最终去掉了中间者Mediator对组件的依赖，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator不依赖其他任何组件。 没有开源的解决方案 Uber在发现MVC的一些弊端之后：比如动辄上万行巨胖无比的VC，无法进行单元测试等缺点后，于是考虑把架构换成VIPER。但是VIPER也有一定的弊端。因为它的iOS特定的结构，意味着iOS必须为Android做出一些妥协的权衡。以视图为驱动的应用程序逻辑，代表应用程序状态由视图驱动，整个应用程序都锁定在视图树上。由操作应用程序状态所关联的业务逻辑的改变，就必须经过Presenter。因此会暴露业务逻辑。最终导致了视图树和业务树进行了紧紧的耦合。这样想实现一个紧紧只有业务逻辑的Node节点或者紧紧只有视图逻辑的Node节点就非常的困难了。 通过改进VIPER架构，吸收其优秀的特点，改进其缺点，就形成了Uber 骑手App的全新架构——Riblets(肋骨)。 在这个新的架构中，即使是相似的逻辑也会被区分成很小很小，相互独立，可以单独进行测试的组件。每个组件都有非常明确的用途。使用这些一小块一小块的Riblets(肋骨)，最终把整个App拼接成一颗Riblets(肋骨)树。 通过抽象，一个Riblets(肋骨)被定义成一下6个更小的组件，这些组件各自有各自的职责。通过一个Riblets(肋骨)进一步的抽象业务逻辑和视图逻辑 一个Riblets(肋骨)被设计成这样，那和之前的VIPER和MVC有什么区别呢？最大的区别在路由上面。 Riblets(肋骨)内的Router不再是视图逻辑驱动的，现在变成了业务逻辑驱动。这一重大改变就导致了整个App不再是由表现形式驱动，现在变成了由数据流驱动。 每一个Riblet都是由一个路由Router，一个关联器Interactor，一个构造器Builder和它们相关的组件构成的。所以它的命名（Router - Interactor - Builder，Rib）也由此得来。当然还可以有可选的展示器Presenter和视图View。路由Router和关联器Interactor处理业务逻辑，展示器Presenter和视图View处理视图逻辑。 重点分析一下Riblet里面路由的职责。 路由职责 在整个App的结构树中，路由的职责是用来关联和取消关联其他子Riblet的。至于决定是由关联器Interactor传递过来的。在状态转换过程中，关联和取消关联子Riblet的时候，路由也会影响到关联器Interactor的生命周期。路由只包含2个业务逻辑： 1.提供关联和取消关联其他路由的方法。 2.在多个孩子之间决定最终状态的状态转换逻辑 拼装 每一个Riblets只有一对Router路由和Interactor关联器。但是它们可以有多对视图。Riblets只处理业务逻辑，不处理视图相关的部分。Riblets可以拥有单一的视图（一个Presenter展示器和一个View视图），也可以拥有多个视图（一个Presenter展示器和多个View视图，或者多个Presenter展示器和多个View视图），甚至也可以能没有视图（没有Presenter展示器也没有View视图）。这种设计可以有助于业务逻辑树的构建，也可以和视图树做到很好的分离。 举个例子，骑手的Riblet是一个没有视图的Riblet，它用来检查当前用户是否有一个激活的路线。如果骑手确定了路线，那么这个Riblet就会关联到路线的Riblet上面。路线的Riblet会在地图上显示出路线图。如果没有确定路线，骑手的Riblet就会被关联到请求的Riblet上。请求的Riblet会在屏幕上显示等待被呼叫。像骑手的Riblet这样没有任何视图逻辑的Riblet，它分开了业务逻辑，在驱动App和支撑模块化架构起了重大作用。 在这个新的架构中，数据流动是单向的。Data数据流从service服务流到Model Stream生成Model流。Model流再从Model Stream流动到Interactor关联器。Interactor关联器，scheduler调度器，远程推送都可以想Service触发变化来引起Model Stream的改动。Model Stream生成不可改动的models。这个强制的要求就导致关联器只能通过Service层改变App的状态。 举两个例子： 数据从后台到视图View上 一个状态的改变，引起服务器后台触发推送到App。数据就被Push到App，然后生成不可变的数据流。关联器收到model之后，把它传递给展示器Presenter。展示器Presenter把model转换成view model传递给视图View。 数据从视图到服务器后台 当用户点击了一个按钮，比如登录按钮。视图View就会触发UI事件传递给展示器Presenter。展示器Presenter调用关联器Interactor登录方法。关联器Interactor又会调用Service call的实际登录方法。请求网络之后会把数据pull到后台服务器。 Riblet间的数据流 当一个关联器Interactor在处理业务逻辑的工程中，需要调用其他Riblet的事件的时候，关联器Interactor需要和子关联器Interactor进行关联。见上图5个步骤。 如果调用方法是从子调用父类，父类的Interactor的接口通常被定义成监听者listener。如果调用方法是从父类调用到子类，那么子类的接口通常是一个delegate，实现父类的一些Protocol。 在Riblet的方案中，路由Router仅仅只是用来维护一个树型关系，而关联器Interactor才担当的是用来决定触发组件间的逻辑跳转的角色。 各个方案对比 APP间跳转 URL Scheme方式 Universal Link方式 APP内路由跳转 URLRoute注册 Protocol-Class 注册 Target-Action 经过上面的分析，可以发现，路由的设计思路是从URLRoute -&gt;Protocol-class -&gt;Target-Action一步步的深入的过程。这也是逐渐深入本质的过程。 1. URLRoute注册方案的优缺点 首先URLRoute也许是借鉴前端Router和系统App内跳转的方式想出来的方法。它通过URL来请求资源。不管是H5，RN，Weex，iOS界面或者组件请求资源的方式就都统一了。URL里面也会带上参数，这样调用什么界面或者组件都可以。所以这种方式是最容易，也是最先可以想到的。 URLRoute的优点很多，最大的优点就是服务器可以动态的控制页面跳转，可以统一处理页面出问题之后的错误处理，可以统一三端，iOS，Android，H5 / RN / Weex 的请求方式。 但是这种方式也需要看不同公司的需求。如果公司里面已经完成了服务器端动态下发的脚手架工具，前端也完成了Native端如果出现错误了，可以随时替换相同业务界面的需求，那么这个时候可能选择URLRoute的几率会更大。 但是如果公司里面H5没有做相关出现问题后能替换的界面，H5开发人员觉得这是给他们增添负担。如果公司也没有完成服务器动态下发路由规则的那套系统，那么公司可能就不会采用URLRoute的方式。因为URLRoute带来的少量动态性，公司是可以用JSPatch来做到。线上出现bug了，可以立即用JSPatch修掉，而不采用URLRoute去做。 所以选择URLRoute这种方案，也要看公司的发展情况和人员分配，技术选型方面。 URLRoute方案也是存在一些缺点的，首先URL的map规则是需要注册的，它们会在load方法里面写。写在load方法里面是会影响App启动速度的。 其次是大量的硬编码。URL链接里面关于组件和页面的名字都是硬编码，参数也都是硬编码。而且每个URL参数字段都必须要一个文档进行维护，这个对于业务开发人员也是一个负担。而且URL短连接散落在整个App四处，维护起来实在有点麻烦，虽然蘑菇街想到了用宏统一管理这些链接，但是还是解决不了硬编码的问题。 真正一个好的路由是在无形当中服务整个App的，是一个无感知的过程，从这一点来说，略有点缺失。 最后一个缺点是，对于传递NSObject的参数，URL是不够友好的，它最多是传递一个字典。 2. Protocol-Class注册方案的优缺点 Protocol-Class方案的优点，这个方案没有硬编码。 Protocol-Class方案也是存在一些缺点的，每个Protocol都要向ModuleManager进行注册。 这种方案ModuleEntry是同时需要依赖ModuleManager和组件里面的页面或者组件两者的。当然ModuleEntry也是会依赖ModuleEntryProtocol的，但是这个依赖是可以去掉的，比如用Runtime的方法NSProtocolFromString，加上硬编码是可以去掉对Protocol的依赖的。但是考虑到硬编码的方式对出现bug，后期维护都是不友好的，所以对Protocol的依赖还是不要去除。 最后一个缺点是组件方法的调用是分散在各处的，没有统一的入口，也就没法做组件不存在时或者出现错误时的统一处理。 3. Target-Action方案的优缺点 Target-Action方案的优点，充分的利用Runtime的特性，无需注册这一步。Target-Action方案只有存在组件依赖Mediator这一层依赖关系。在Mediator中维护针对Mediator的Category，每个category对应一个Target，Categroy中的方法对应Action场景。Target-Action方案也统一了所有组件间调用入口。 Target-Action方案也能有一定的安全保证，它对url中进行Native前缀进行验证。 Target-Action方案的缺点，Target_Action在Category中将常规参数打包成字典，在Target处再把字典拆包成常规参数，这就造成了一部分的硬编码。","link":"/back/%E8%B7%AF%E7%94%B1.html"},{"title":"404 Not Found","text":"对不起，您所访问的页面不存在或者已删除。 您可以点击此处返回首页。 ACE_xW","link":"/source/404.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"关于我们","text":"ACE_xW 简介 联系方式 Blog: http://bapuqln.github.io GitHub: https://github.com/bapuqln","link":"/source/about/index.html"},{"title":"分类","text":"","link":"/source/categories/index.html"},{"title":"Clang学习笔记","text":"Clang 学习笔记 什么是 Clang Clang 是 LLVM 的前端，可以分析 C 语言家族的所有源代码。 Clang 是如何工作的 预处理：展开所有的宏，将代码解析成抽象语法树 Clang AST 几乎所有的编译器 &amp; 静态分析工具 都是用 AST 来表示原本的代码。 一般来说， Clang AST 由两个类组成：Decl &amp; bStmt。 &gt; FunctionDecl：函数原型或者函数定义 &gt; BinaryOperator：二元表达式，（a+b） &gt; CallExpr：函数调用，foo（x） 怎么使用 Clang Clang Plugin 使用 Clang Plugin，写出的代码本身就是插件。在使用 Clang Plugin 的时候，我们不可以保留不同文件之间的全局信息和其他横跨多个文件的上下文信息。插件的运行是通过传递命令行参数给 build system（Clang/Make），在源文件分析前后，我们不能进行任何的 custom task。插件的存在形式是一个动态链接库。 LibTooling(Clang Tool) 使用 LibTooling，代码本身就是一个正常的 C++ 程序，已正常的 main() 函数作为入口。LibTooling 一般用来把程序构建的过程和程序的分析过程分开。针对每个源程序都会生成分析代码以及对应的 AST，但同时还可以维护不同源代码文件的全局信息。由于程序有 main()函数，我们还可以在分析源代码前后运行其他的任务。 LibClang 当我们想要一个稳定的 API 的时候，LibClang 是一个很好的选择，Clang 变化很块，如果使用 Plugin 或者 LibTooling，我们可能需要更新代码以应对 Clang 的变化。但如果需要在 C++ 以外的地方调用 Clang 的 API 的时候，必须要使用 LibClang。 LibClang 不可以使用完整的 AST（只能使用高层次的 AST），而另外两个选择（Plugin 与 LibTooling）则可以。如果还是无法选择，推荐使用 LibTooling interface，简单好用。LibTooling能够像 Plugin 一样完整的使用 AST，同时还不会丢掉源代码的全局信息。另外设置 LibTooling 比 Plugin 更容易。 开始使用 Clang 编译安装 LLVM 12cd where-you-want-llvm-to-livesvn co http://llvm.org/svn/llvm-project/llvm/trunk llvm Clang 123cd where-you-want-llvm-to-livecd llvm/toolssvn co http://llvm.org/svn/llvm-project/cfe/trunk clang Compile-RT 123cd where-you-want-llvm-to-livecd llvm/projectssvn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt 构建 1234cd where you want to build llvmmkdir buildcd buildcmake -G &lt;generator&gt; [options] &lt;path to llvm sources&gt; LibTooling 假如我们要分析一个 C 语言文件如下： 12345678910#No header, because it needs additional effortsvoid do_math(int *x) { *x += 5;}int main(void) { int result = -1, val = 4; do_math(&amp;val); return result;} 我们想要对上述函数进行重构。 * 把函数名do_math 改为 addFive * 把所有的对 do_math 的调用都改为 addFive * 把返回值改为 val 从 main 函数开始 1234567891011121314int main(int argc, const char **argv) { // parse the command-line args passed to your code CommonOptionsParser op(argc, argv, StatSampleCategory); // create a new Clang Tool instance (a LibTooling environment) ClangTool Tool(op.getCompilations(), op.getSourcePathList()); // run the Clang Tool, creating a new FrontendAction (explained below) int result = Tool.run(newFrontendActionFactory&lt;ExampleFrontendAction&gt;().get()); errs() &lt;&lt; &quot;\\nFound &quot; &lt;&lt; numFunctions &lt;&lt; &quot; functions.\\n\\n&quot;; // print out the rewritten source code (&quot;rewriter&quot; is a global var.) rewriter.getEditBuffer(rewriter.getSourceMgr().getMainFileID()).write(errs()); return result;} 首先设置一个 ClangTool，将命令行参数：op.getCompilations() 以及源文件列表 op.getSourcePathList() 传给它，然后就运行这个工具就好了。 LibTooling 的优点在于，可以再工具运行前后做其他的事情，比如说打印出修改前后的代码以及统计函数的个数。 创建 FrontendAction 现在创建自己的 FrontendAction，创建的原因：想要分析 test.c 的 AST 表示。 123456789class ExampleFrontendAction : public ASTFrontendAction {public: ExampleFrontendAction() {} //Note that unique pointer is used. virtual std::unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI, StringRef file) { return llvm::make_unique&lt;ExampleASTConsumer&gt;(&amp;CI); // pass CI pointer to ASTConsumer }}; 这里不是很复杂，我们创建了一个ASTFrontendAction的子类，改写了CreateASTConsumer函数以返回我们自己的ASTConsumer。我们还将指向CompileInstance的指针传入，因为这里面包含很多我们需要分析的上下文信息。 构建 ASTConsumer ASTConsumer 由Clang parser产生的AST。我们可以任意地重载ASTConsumer的成员函数，这样解析AST后我们的代码就可以被调用。首先，我们重载函数HandleTopLevelDecl，这在Clang解析完顶级的声明（像全局变量，函数定义等）后就可以被调用了。 1234567891011121314151617181920class ExampleASTConsumer : public ASTConsumer {private: ExampleVisitor *visitor; // doesn't have to be privatepublic: // override the constructor in order to pass CI explicit ExampleASTConsumer(CompilerInstance *CI) : visitor(new ExampleVisitor(CI)) // initialize the visitor { } // override this to call our ExampleVisitor on each top-level Decl virtual bool HandleTopLevelDecl(DeclGroupRef DG) { // a DeclGroupRef may have multiple Decls, so we iterate through each one for (DeclGroupRef::iterator i = DG.begin(), e = DG.end(); i != e; i++) { Decl *D = *i; visitor-&gt;TraverseDecl(D); // recursively visit each AST node in Decl &quot;D&quot; } return true; }}; 以上代码使用了ExampleVisitor（见下文），来访问整个源文件顶级声明（top-level declaration）的AST节点。对于test.c而言，两个FunctionDecl将会被访问，do_math()以及main()。 更好的 ASTConsumer 实现 重载HandleTopLevelDecl()意味着每当一个新的Decl出现的时候，函数中的代码就会被调用，而不是等到整个源文件被解析完成后。从parser的角度看，当访问do_math()的时候，它将完全不知道main()的存在，也就是说我们不能access到当前分析的函数之后的函数。 但是，这个功能很重要！ 不过，ASTConsumer还有一个更好的函数用来重载，HandelTranslationUnit()，该函数只有在整个文件都解析完才被调用。这样的话，一个translation单元就是一整个源文件。ASTContext类用来表示那个源文件的AST，并且包含许多很有用的成员（去读文档吧！）。 所以，下面的代码重载了HandelTranslationUnit(): 123456// override this to call our ExampleVisitor on the entire source file virtual void HandleTranslationUnit(ASTContext &amp;Context) { /* we can use ASTContext to get the TranslationUnitDecl, which is a single Decl that collectively represents the entire source file */ visitor-&gt;TraverseDecl(Context.getTranslationUnitDecl()); } 大多数情况下，我们都应该使用HandelTranslationUnit(), 尤其在使用RecursiveASTVisitor的时候。 创建一个 RecursiveASTVisitor 前面两部分只不过在设置架构，现在到了正文部分了。RecursiveASTVisitor是一个特别有用的类，使用它可以访问任意类型的AST节点，比如FunctionDecl以及Stmt, 只要重载那个函数（比如VisitFunctionDecl以及VisitStmt）就可以了。当然，其它AST类也同样适用这样的规则。Clang提供了一个官方的文档，虽然很短，但是很全面。 像Visit..(表示Visit任意节点的函数，如VisitStmt）这样的函数，我们必须返回true以继续遍历AST或者返回false以终止遍历，退出Clang。我们不可以直接调用Visit..，而是应该调用TraverseDecl（正如我们前面的那个例子一样），调用Visit..函数则是在背后调用的。 由于我们只需要改写函数定义和一些statement，我们只需要重载VisitFunctionDecl和VisitStmt。下面是部分代码： 12345678910111213141516171819202122232425262728293031class ExampleVisitor : public RecursiveASTVisitor&lt;ExampleVisitor&gt; {private: ASTContext *astContext; // used for getting additional AST infopublic: explicit ExampleVisitor(CompilerInstance *CI): astContext(&amp;(CI-&gt;getASTContext())) { // initialize private members rewriter.setSourceMgr(astContext-&gt;getSourceManager(), astContext-&gt;getLangOpts()); } virtual bool VisitFunctionDecl(FunctionDecl *func) { numFunctions++; string funcName = func-&gt;getNameInfo().getName().getAsString(); if (funcName == &quot;do_math&quot;) { rewriter.ReplaceText(func-&gt;getLocation(), funcName.length(), &quot;add5&quot;); errs() &lt;&lt; &quot;** Rewrote function def: &quot; &lt;&lt; funcName &lt;&lt; &quot;\\n&quot;; } return true; } virtual bool VisitStmt(Stmt *st) { if (ReturnStmt *ret = dyn_cast&lt;ReturnStmt&gt;(st)) { rewriter.ReplaceText(ret-&gt;getRetValue()-&gt;getLocStart(), 6, &quot;val&quot;); errs() &lt;&lt; &quot;** Rewrote ReturnStmt\\n&quot;; } if (CallExpr *call = dyn_cast&lt;CallExpr&gt;(st)) { rewriter.ReplaceText(call-&gt;getLocStart(), 7, &quot;add5&quot;); errs() &lt;&lt; &quot;** Rewrote function call\\n&quot;; } return true; }}; 以上的代码引入了Rewriter类，可以让我们对源代码进行修改，这在代码重构或者小规模的代码修改里面很常见。我们还在main()函数的末尾用它打印出了修改后的代码。 使用Rewriter意味着我们需要找到正确SourceLocation来插入或者替换相关的代码。同时，我们还使用了dyn_cast，来检查Stmt st是一个ReturnStmt还是CallExpr。而errs()是一个stderr流，在LLVM/Clang里面打印debug信息 写一个更具体的Visit..函数 除了更一般化地重载VisitStmt，我们可以更具体化地重载VisitReturnStme以及VisitCallExpr。VisitReturnStme和VisitCallExpr都是Stmt的子类。这就是Clang AST和RecursiveASTVisitor的美妙之处：我们可以选择一般化或者是具体化，下面就是代码 1234567891011// this replaces the VisitStmt function abovevirtual bool VisitReturnStmt(ReturnStmt *ret) { rewriter.ReplaceText(ret-&gt;getLocStart(), 6, &quot;val&quot;); errs() &lt;&lt; &quot;** Rewrote ReturnStmt\\n&quot;; return true;}virtual bool VisitCallExpr(CallExpr *call) { rewriter.ReplaceText(call-&gt;getLocStart(), 7, &quot;add5&quot;); errs() &lt;&lt; &quot;** Rewrote function call\\n&quot;; return true;}","link":"/source/back/Clang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"Clang plugin with Xcode","text":"Creating and using Clang plugin with Xcode 环境设置 plugin 设置 Xcode 工程设置 warnning error Xcode 集成 与 error/warning 的交互 环境设置 需要 llvm/clang，源码 12345cd /optsudo mkdir llvmsudo chown `whoami` llvmcd llvmexport LLVM_HOME=`pwd` 根据本机的 clang 版本来编译,本机3.3.1 为例 123456789git clone -b release_33 https://github.com/llvm-mirror/llvm.git llvmgit clone -b release_33 https://github.com/llvm-mirror/clang.git llvm/tools/clanggit clone -b release_33 https://github.com/llvm-mirror/clang-tools-extra.git llvm/tools/clang/tools/extragit clone -b release_33 https://github.com/llvm-mirror/compiler-rt.git llvm/projects/compiler-rt mkdir llvm_buildcd llvm_buildcmake ../llvm -DCMAKE_BUILD_TYPE:STRING=Releasemake -j`sysctl -n hw.logicalcpu` plugin 设置 创建 plugin 的文件夹 12cd $LLVM_HOMEmkdir toy_clang_plugin; cd toy_clang_plugin 基于 plugin 的例子结构如下 ToyClangPlugin.exports CMakeLists.txt ToyClangPlugin.cpp 文件内容 ToyClangPlugin.cpp 12345678910111213141516171819202122232425262728293031#include &quot;clang/Frontend/FrontendPluginRegistry.h&quot;#include &quot;clang/AST/AST.h&quot;#include &quot;clang/AST/ASTConsumer.h&quot;#include &quot;clang/Frontend/CompilerInstance.h&quot; using namespace clang; namespace{ class ToyConsumer : public ASTConsumer { }; class ToyASTAction : public PluginASTAction { public: virtual clang::ASTConsumer *CreateASTConsumer(CompilerInstance &amp;Compiler, llvm::StringRef InFile) { return new ToyConsumer; } bool ParseArgs(const CompilerInstance &amp;CI, const std::vector&lt;std::string&gt;&amp; args) { return true; } };} static clang::FrontendPluginRegistry::Add&lt;ToyASTAction&gt;X(&quot;ToyClangPlugin&quot;, &quot;Toy Clang Plugin&quot;); CMakeLists.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124cmake_minimum_required (VERSION 2.6)project (ToyClangPlugin) set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin )set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib )set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib ) set( LLVM_HOME /opt/llvm )set( LLVM_SRC_DIR ${LLVM_HOME}/llvm )set( CLANG_SRC_DIR ${LLVM_HOME}/llvm/tools/clang )set( LLVM_BUILD_DIR ${LLVM_HOME}/llvm_build )set( CLANG_BUILD_DIR ${LLVM_HOME}/llvm_build/tools/clang) add_definitions (-D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS)add_definitions (-D_GNU_SOURCE -DHAVE_CLANG_CONFIG_H) set (CMAKE_CXX_COMPILER &quot;${LLVM_BUILD_DIR}/bin/clang++&quot;)set (CMAKE_CC_COMPILER &quot;${LLVM_BUILD_DIR}/bin/clang&quot;) set (CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fPIC -fno-common -Woverloaded-virtual -Wcast-qual -fno-strict-aliasing -pedantic -Wno-long-long -Wall -Wno-unused-parameter -Wwrite-strings -fno-exceptions -fno-rtti&quot;) set (CMAKE_MODULE_LINKER_FLAGS &quot;-Wl,-flat_namespace -Wl,-undefined -Wl,suppress&quot;) set (LLVM_LIBS LLVMJIT LLVMX86CodeGen LLVMX86AsmParser LLVMX86Disassembler LLVMExecutionEngine LLVMAsmPrinter LLVMSelectionDAG LLVMX86AsmPrinter LLVMX86Info LLVMMCParser LLVMCodeGen LLVMX86Utils LLVMScalarOpts LLVMInstCombine LLVMTransformUtils LLVMipa LLVMAnalysis LLVMTarget LLVMCore LLVMMC LLVMSupport LLVMBitReader LLVMOption) macro(add_clang_plugin name) set (srcs ${ARGN}) include_directories( &quot;${LLVM_SRC_DIR}/include&quot; &quot;${CLANG_SRC_DIR}/include&quot; &quot;${LLVM_BUILD_DIR}/include&quot; &quot;${CLANG_BUILD_DIR}/include&quot; ) link_directories( &quot;${LLVM_BUILD_DIR}/lib&quot; ) add_library( ${name} SHARED ${srcs} ) if (SYMBOL_FILE) set_target_properties( ${name} PROPERTIES LINK_FlAGS &quot;-exported_symbols_list ${SYMBOL_FILE}&quot;) endif() foreach (clang_lib ${CLANG_LIBS}) target_link_libraries( ${name} ${clang_lib} ) endforeach() foreach (llvm_lib ${LLVM_LIBS}) target_link_libraries( ${name} ${llvm_lib} ) endforeach() foreach (user_lib ${USER_LIBS}) target_link_libraries( ${name} ${user_lib} ) endforeach() endmacro(add_clang_plugin) set(SYMBOL_FILE ToyClangPlugin.exports) set (CLANG_LIBS clang clangFrontend clangAST clangAnalysis clangBasic clangCodeGen clangDriver clangFrontendTool clangLex clangParse clangSema clangEdit clangSerialization clangStaticAnalyzerCheckers clangStaticAnalyzerCore clangStaticAnalyzerFrontend) set (USER_LIBS pthread curses) add_clang_plugin(ToyClangPlugin ToyClangPlugin.cpp) set_target_properties(ToyClangPlugin PROPERTIES LINKER_LANGUAGE CXX PREFIX &quot;&quot;) ToyClangPlugin.exports 1__ZN4llvm8Registry* 现在我们能够基于 CMakeLists.txt 生成 Xcode-project， 123mkdir build; cd buildcmake -G Xcode ..open ToyClangPlugin.xcodeproj 运行 ALL_BUILD target ，然后就能看到动态库：lib/Debug/ToyClangPlugin.dylib RecuresiveASTVisitor Clang 的 AST 模块提供了RecuresiveASTVisitor，他能够让你编译整个 AST，我们只需要创建一个子类并且实现我们感兴趣的方法就行。为了测试一下，现在只是打印所有发现的类名。 12345678910111213141516171819class ToyClassVisitor : public RecursiveASTVisitor&lt;ToyClassVisitor&gt;{public: bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration) { printf(&quot;ObjClass: %s\\n&quot;, declaration-&gt;getNameAsString().c_str()); return true; }}; class ToyConsumer : public ASTConsumer{public: void HandleTranslationUnit(ASTContext &amp;context) { visitor.TraverseDecl(context.getTranslationUnitDecl()); }private: ToyClassVisitor visitor;}; 下面我们就来创建测试的文件并且看看 plugin 是如何工作的。 123456789#import &lt;Foundation/Foundation.h&gt; @interface ToyObject : NSObject @end @implementation ToyObject @end rebuild &amp; 运行 插件 12345/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin 报警告 下面我们试试这个情况：类名是以小写字母开始。 在 ToyClassVisitor 中增加 ASTContext 123456789101112131415161718class ToyClassVisitor : public RecursiveASTVisitor&lt;ToyClassVisitor&gt;{private: ASTContext *context;public: void setContext(ASTContext &amp;context) { this-&gt;context = &amp;context; }// ...}; // ...void HandleTranslationUnit(ASTContext &amp;context) { visitor.setContext(context); visitor.TraverseDecl(context.getTranslationUnitDecl());} // ... 增加检测 1234567891011121314151617bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration){ checkForLowercasedName(declaration); return true;}// ...void checkForLowercasedName(ObjCInterfaceDecl *declaration){ StringRef name = declaration-&gt;getName(); char c = name[0]; if (isLowercase(c)) { DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Warning, &quot;Class name should not start with lowercase letter&quot;); SourceLocation location = declaration-&gt;getLocation(); diagEngine.Report(location, diagID); }} 测一下 1234567@interface bad_ToyObject : NSObject @end @implementation bad_ToyObject @end rebuild &amp; run 12345678910/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin ../test.m:11:12: warning: Class name should not start with lowercase letter@interface bad_ToyObject : NSObject ^1 warning generated. 报错误 试一下如果类名里面包含下划线 123456789101112131415161718void checkForUnderscoreInName(ObjCInterfaceDecl *declaration){ size_t underscorePos = declaration-&gt;getName().find('_'); if (underscorePos != StringRef::npos) { DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Error, &quot;Class name with `_` forbidden&quot;); SourceLocation location = declaration-&gt;getLocation().getLocWithOffset(underscorePos); diagEngine.Report(location, diagID); }} bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration){ // disable this check temporary // checkForLowercasedName(declaration); checkForUnderscoreInName(declaration); return true;} 看看运行后的输出 12345678910/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin ../test.m:11:15: error: Class name with `_` forbidden@interface bad_ToyObject : NSObject ^1 error generated. 我们试试两个监测都打开的时候的样子 12345678910111213/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin ../test.m:11:12: warning: Class name should not start with lowercase letter@interface bad_ToyObject : NSObject ^../test.m:11:15: error: Class name with `_` forbidden@interface bad_ToyObject : NSObject ^1 warning and 1 error generated. Xcode 集成 很遗憾，Xcode 的 clang 并不支持插件，所以我们要这么做。 在 Xcode 中启用自定义编译工具 12sudo mv HackedClang.xcplugin `xcode-select -print-path`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-inssudo mv HackedBuildSystem.xcspec `xcode-select -print-path`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications 这样就能在 build option 里面找到编译器了 在 OTHER_CFLAGS 中增加 1-Xclang -load -Xclang /opt/llvm/toy_clang_plugin/build/lib/Debug/ToyClangPlugin.dylib -Xclang -add-plugin -Xclang ToyClangPlugin 注意：这个地方使用 -add-plugin，因为我们想用自己的 ASTAction，而不是替换掉现存的 在 Module - CLANG_ENABLE_MODULES 设置为 NO 把之前新建的 test.m 增加到工程中。即可见到 增加交互 针对 warning &amp; error 增加 FixItHints 123456789101112131415161718192021222324252627282930313233343536373839404142void checkForLowercasedName(ObjCInterfaceDecl *declaration){ StringRef name = declaration-&gt;getName(); char c = name[0]; if (isLowercase(c)) { std::string tempName = name; tempName[0] = toUppercase(c); StringRef replacement(tempName); SourceLocation nameStart = declaration-&gt;getLocation(); SourceLocation nameEnd = nameStart.getLocWithOffset(name.size()); FixItHint fixItHint = FixItHint::CreateReplacement(SourceRange(nameStart, nameEnd), replacement); DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Warning, &quot;Class name should not start with lowercase letter&quot;); SourceLocation location = declaration-&gt;getLocation(); diagEngine.Report(location, diagID).AddFixItHint(fixItHint); }} void checkForUnderscoreInName(ObjCInterfaceDecl *declaration){ StringRef name = declaration-&gt;getName(); size_t underscorePos = name.find('_'); if (underscorePos != StringRef::npos) { std::string tempName = name; std::string::iterator end_pos = std::remove(tempName.begin(), tempName.end(), '_'); tempName.erase(end_pos, tempName.end()); StringRef replacement(tempName); SourceLocation nameStart = declaration-&gt;getLocation(); SourceLocation nameEnd = nameStart.getLocWithOffset(name.size()); FixItHint fixItHint = FixItHint::CreateReplacement(SourceRange(nameStart, nameEnd), replacement); DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Error, &quot;Class name with `_` forbidden&quot;); SourceLocation location = declaration-&gt;getLocation().getLocWithOffset(underscorePos); diagEngine.Report(location, diagID).AddFixItHint(fixItHint); }}","link":"/source/back/Creating_and_using_Clang_plugin_with_Xcode.html"},{"title":"ARM 汇编","text":"ARM 汇编 Layout label: instruction ;comment &gt;label 字母、下划线和 $ 组成. &gt;comment 所有在;后面的都认为是注释 &gt;instruction 指令 1234567 .textstart: MOV r1, #20 ;puts the value 20 into register r1 MOV r2, #22 ;puts the value 22 into register r2 ADD r0, r1, r2 ;adds r1 and r2, r0 contains 42end: b end ;infinite loop, always jump back to end Instruction Format &lt;op&gt;{cond}{flags} Rd, Rn, Operand2 例如: ADD r0, r1, r2 三个字母的指令 {cond} 可选，两个字母的状态码(condition code) {flags} 可选，附加标志位 Rd 目标寄存器 Rn 第一个寄存器 Operand2 第二个寄存器或者操作数 Condition Code 在指令后面添加，允许指令在特定条件下执行。 AL - always 无条件执行，因此可以不用写 ADDAL 和 ADD 是等价的 NV - never。 AL 的反义词，带有该标记的指令不会执行。已经废弃。 EQ - equal 当 Z 标志为被设置过后，才会执行，如果 Z 标志位被清除，该行指令被忽略. MOV r0, #42 ;Write the value 42 into the register r0MOV r1, #41 ;Write the value 41 into the register r1CMP r0, r1 ;Compare the registers r0 and r1, update CPSR register BEQ label ;This command will not be run, since Z = 0MOV r1, #42 ;Write the value 42 into the register r1CMP r0, r1 ;Compare r0 and r1, update the CPSRBEQ label ;This command will be run, since Z = 1 1234* NE - not equal &gt; EQ 的反义词，如果 Z 标志位被清除，则执行。如果 Z 标志位被设置过，该行指令被忽略 MOV r0, #42 ;Write the value 42 into the register r0MOV r1, #42 ;Write the value 42 into the register r1CMP r0, r1 ;Compare the registers r0 and r1, update CPSR register BNE label ;This command will not be run, since Z = 1MOV r1, #41 ;Write the value 42 into the register r1CMP r0, r1 ;Compare r0 and r1, update the CPSRBNE label ;This command will be run, since Z = 0 12345678910111213* VS - overflow set &gt; 如果 overflow(v) 位被设置，该条件为 true。两个32位有符号数相加，可能会出一个33位的有符号数* VC - overflow clear &gt; 如果 overflow(v) 位被清除，该条件为 true。 * MI - minus &gt; 如果 negative(N) 为被设置，该条件为 true MOV r0, #40MOV r1, #42SUBS r2, r0, r1 ; 40 – 42, the result is negative BMI destination ; this portion of code is never executed PL - plus 如果 negative(N) 位被清除，该条件为 true。(&lt;= 0) CS - Carry Set 当一个在32位无符号数上的操作超出了32位的范围的时候，carry set 标志位设为 true CC - Carry Clear 如果 Carry Flag(C) 被清除了，该条语句执行 HI - Higher 如果 Carry Flag(C) 被设置，并且结果非0(Z)，该语句执行 LS - Lower or Same 如果 Carry Flag(C) 被清除，并且结果为0(Z)，该语句执行 GE - Greater than or Equal 当有符号数，并且当 Negative(N) 和 Overflow(V) 相等的时候，该语句才有效 LT - Less Than 有符号数，并且当 Negative(V) 和 Overflow(V) 不相等的时候，该语句才有效。 LE - Less Than or Equal 像 LT， 如果 Negative(V) 和 Overflow(V) 不相等，或者 Zero(Z)标志位被设置了的时候，该语句才执行。 CODE MEANING FLAGS EQ Equal equals Zero Z NE Not Equal !Z VS Overflow V VC No overflow !V MI Minus/negative N PL Plus/positive or zero !N CS Carryset/unsigned higher or same C CC Carry clear/unsigned lower !C HI Unsigned higher C and !Z LS Unsigned lower or same !C or Z GE Signed greater than or equal N == V LT Signed less than N != V GT Signed greater than !Z and (N == V) LE Signed less than or equal Z or (N != V) AL Always(default) Any Updating Condition Flags 默认情况下，指令不更新条件标志。 &gt; 当 S (ADDS, SBCS...) 标志位被设置后，指令才能更新标志位。 &gt; 例外：比较指令会自动更新 Objective-C MOV r0, # 80 00 00 0F ; r0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I I I IMOV r1, r0, LSL #1 ; r1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I I I I 0","link":"/source/back/ARM%E6%B1%87%E7%BC%96.html"},{"title":"LLVM &amp; Clang","text":"LLVM &amp; Clang LLVM DragonMediu LLVM（Low Level Virtual Machine） 是一个底层虚拟机，但是现在是一系列编译器和工具链的合集，而且是模块化和可重用的。 #### LLVM 的结构 传统的编译器分为三个阶段：前端，优化，后端 Untitled LLVM 也是三段式结构。 如果要支持一个新的硬件设备，只需要实现一个新的后端。要支持一个新的语言，只需要实现一个新的前端。 优化阶段 针对了统一的 LLVM IR，LLVM IR 主要有三种格式（完全等价） * 在内存中的编译中间语言 * 硬盘上存储的二进制中间语言（.bc） * 可读的中间格式（.ll） Demo - hello.c 1 生成一个二进制的 .bc 文件 生成一个 .ll 文件","link":"/source/back/LLVM_Clang.html"},{"title":"MVC、MVP、MVVM","text":"MVC. MVP. MVVM 架构模式 MVX 中的 Model 在大多数的iOS项目中，Model 层只是一个单纯的数据结构，大部分的模型都是这样的 12345678910struct User { enum Gender: String { case male = &quot;male&quot; case female = &quot;female&quot; } let name: String let email: String let age: Int let gender: Gender} 模型起到了定义一堆坑的作用，只是一个简单的模板，并没有参与到实际的业务逻辑，只是在模型层进行了一些抽象，将服务器端发回的JSON或者说NSDictionary 对象中的字段一一取出并填装到预先定义好的模型中。 可以将这种模型层中提供的对象理解为即开即用的NSDictionary实例，在使用时，可以直接从模型中取出属性，省去了从NSDictionary中抽出属性以及验证是否合法的过程. JSON -&gt; Model 使用 Swift 将 Dictionary 转换成模型，在笔者看来其实是一件比较麻烦的事情，主要原因是 Swift 作为一个号称类型安全的语言，有着使用体验非常差的 Optional 特性，从 Dictionary 中取出的值都是不一定存在的，所以如果需要纯手写这个过程其实还是比较麻烦的. 123456789extension User { init(json: [String: Any]) { let name = json[&quot;name&quot;] as! String let email = json[&quot;email&quot;] as! String let age = json[&quot;age&quot;] as! Int let gender = Gender(rawValue: json[&quot;gender&quot;] as! String)! self.init(name: name, email: email, age: age, gender: gender) }} 这里为 User 模型创建了一个 extension 并写了一个简单的模型转换的初始化方法，当我们从 JSON 对象中取值时，得到的都是 Optional 对象；而在大多数情况下，我们都没有办法直接对 Optional 对象进行操作，这就非常麻烦了。 麻烦的 Optional 在 Swift 中遇到无法立即使用的 Optional 对象时，我们可以会使用 ! 默认将字典中取出的值当作非 Optional 处理，但是如果服务端发回的数据为空，这里就会直接崩溃；当然，也可使用更加安全的 if let 对 Optional 对象进行解包（unwrap）。 123456789101112extension User { init?(json: [String: Any]) { if let name = json[&quot;name&quot;] as? String, let email = json[&quot;email&quot;] as? String, let age = json[&quot;age&quot;] as? Int, let genderString = json[&quot;gender&quot;] as? String, let gender = Gender(rawValue: genderString) { self.init(name: name, email: email, age: age, gender: gender) } return nil }} 上面的代码看起来非常的丑陋，而正是因为上面的情况在 Swift 中非常常见，所以社区在 Swift 2.0 中引入了 guard 关键字来优化代码的结构。 123456789101112extension User { init?(json: [String: Any]) { guard let name = json[&quot;name&quot;] as? String, let email = json[&quot;email&quot;] as? String, let age = json[&quot;age&quot;] as? Int, let genderString = json[&quot;gender&quot;] as? String, let gender = Gender(rawValue: genderString) else { return nil } self.init(name: name, email: email, age: age, gender: gender) }} 不过，上面的代码在笔者看来，并没有什么本质的区别，不过使用 guard 对错误的情况进行提前返回确实是一个非常好的编程习惯。 不关心空值的 Objective-C 为什么 Objective-C 中没有这种问题呢？主要原因是在 OC 中所有的对象其实都是 Optional 的，我们也并不在乎对象是否为空，因为在 OC 中向 nil 对象发送消息并不会造成崩溃，Objective-C 运行时仍然会返回 nil 对象。 OC 作为动态语言，这种设计思路其实还是非常优秀的，它避免了大量由于对象不存在导致无法完成方法调用造成的崩溃；同时，作为开发者，我们往往都不需要考虑 nil 的存在，所以使用 OC 时写出的模型转换的代码都相对好看很多。 1234567891011121314151617181920212223242526272829// User.htypedef NS_ENUM(NSUInteger, Gender) { Male = 0, Female = 1,};@interface User: NSObject@property (nonatomic, strong) NSString *email;@property (nonatomic, strong) NSString *name;@property (nonatomic, assign) NSUInteger age;@property (nonatomic, assign) Gender gender;@end// User.m@implementation User- (instancetype)initWithJSON:(NSDictionary *)json { if (self = [super init]) { self.email = json[@&quot;email&quot;]; self.name = json[@&quot;name&quot;]; self.age = [json[@&quot;age&quot;] integerValue]; self.gender = [json[@&quot;gender&quot;] integerValue]; } return self;}@end 元编程能力 从上面的代码，我们可以看出：Objective-C 和 Swift 对于相同功能的处理，却有较大差别的实现。这种情况的出现主要原因是语言的设计思路导致的；Swift 一直鼓吹自己有着较强的安全性，能够写出更加稳定可靠的应用程序，而安全性来自于 Swift 语言的设计哲学；由此看来静态类型、安全和动态类型、元编程能力（？）看起来是比较难以共存的。 OC 中对于 nil 的处理能够减少我们在编码时的工作量，不过也对工程师的代码质量提出了考验。我们需要思考 nil 的出现会不会带来崩溃，是否会导致行为的异常、增加应用崩溃的风险以及不确定性，而这也是 Swift 引入 Optional 这一概念来避免上述问题的初衷。 相比而言，笔者还是更喜欢强大的元编程能力，这样可以减少大量的重复工作并且提供更多的可能性，与提升工作效率相比，牺牲一些安全性还是可以接受的。 网络服务Service 层 现有的大多数应用都会将网路服务组织成单独的一层，所以有时候你会看到所谓的 MVCS 架构模式，它其实只是在 MVC 的基础上加上了一个服务层（Service），而在 iOS 中常见的 MVC 架构模式也都可以理解为 MVCS 的形式，当引入了 Service 层之后，整个数据的获取以及处理的流程是这样的： 大多数情况下服务的发起都是在 Controller 中进行的； 然后会在 HTTP 请求的回调中交给模型层处理 JSON 数据； 返回开箱即用的对象交还给 Controller 控制器； 最后由 View 层展示服务端返回的数据； 不过按理来说服务层并不属于模型层，为什么要在这里进行介绍呢？这是因为 Service 层其实与 Model 层之间的联系非常紧密；网络请求返回的结果决定了 Model 层该如何设计以及该有哪些功能模块，而 Service 层的设计是与后端的 API 接口的设计强关联的，这也是我们谈模型层的设计无法绕过的坑。 iOS 中的 Service 层大体上有两种常见的组织方式，其中一种是命令式的，另一种是声明式的。 命令式 命令式的 Service 层一般都会为每一个或者一组 API 写一个专门用于 HTTP 请求的 Manager 类，在这个类中，我们会在每一个静态方法中使用 AFNetworking 或者 Alamofire 等网络框架发出 HTTP 请求。 123456789101112131415161718192021222324252627import Foundationimport Alamofirefinal class UserManager { static let baseURL = &quot;http://localhost:3000&quot; static let usersBaseURL = &quot;\\(baseURL)/users&quot; static func allUsers(completion: @escaping ([User]) -&gt; ()) { let url = &quot;\\(usersBaseURL)&quot; Alamofire.request(url).responseJSON { response in if let jsons = response.result.value as? [[String: Any]] { let users = User.users(jsons: jsons) completion(users) } } } static func user(id: Int, completion: @escaping (User) -&gt; ()) { let url = &quot;\\(usersBaseURL)/\\(id)&quot; Alamofire.request(url).responseJSON { response in if let json = response.result.value as? [String: Any], let user = User(json: json) { completion(user) } } }} 在这个方法中，我们完成了网络请求、数据转换 JSON、JSON 转换到模型以及最终使用 completion 回调的过程，调用 Service 服务的 Controller 可以直接从回调中使用构建好的 Model 对象。 123456UserManager.user(id: 1) { user in self.nameLabel.text = user.name self.emailLabel.text = user.email self.ageLabel.text = &quot;\\(user.age)&quot; self.genderLabel.text = user.gender.rawValue} 声明式 使用声明式的网络服务层与命令式的方法并没有本质的不同，它们最终都调用了底层的一些网络库的 API，这种网络服务层中的请求都是以配置的形式实现的，需要对原有的命令式的请求进行一层封装，也就是说所有的参数 requestURL、method 和 parameters 都应该以配置的形式声明在每一个 Request 类中。 如果是在 Objective-C 中，一般会定义一个抽象的基类，并让所有的 Request 都继承它；但是在 Swift 中，我们可以使用协议以及协议扩展的方式实现这一功能。 123456789101112131415protocol AbstractRequest { var requestURL: String { get } var method: HTTPMethod { get } var parameters: Parameters? { get }}extension AbstractRequest { func start(completion: @escaping (Any) -&gt; Void) { Alamofire.request(requestURL, method: self.method).responseJSON { response in if let json = response.result.value { completion(json) } } }} 在 AbstractRequest 协议中，我们定义了发出一个请求所需要的全部参数，并在协议扩展中实现了 start(completion:) 方法，这样实现该协议的类都可以直接调用 start(completion:) 发出网络请求。 12345678910111213141516final class AllUsersRequest: AbstractRequest { let requestURL = &quot;http://localhost:3000/users&quot; let method = HTTPMethod.get let parameters: Parameters? = nil}final class FindUserRequest: AbstractRequest { let requestURL: String let method = HTTPMethod.get let parameters: Parameters? = nil init(id: Int) { self.requestURL = &quot;http://localhost:3000/users/\\(id)&quot; }} 我们在这里写了两个简单的 Request 类 AllUsersRequest 和 FindUserRequest，它们两个一个负责获取所有的 User 对象，一个负责从服务端获取指定的 User；在使用上面的声明式 Service 层时也与命令式有一些不同： 123456FindUserRequest(id: 1).start { json in if let json = json as? [String: Any], let user = User(json: json) { print(user) }} 因为在 Swift 中，我们没法将 JSON 在 Service 层转换成模型对象，所以我们不得不在 FindUserRequest 的回调中进行类型以及 JSON 转模型等过程；又因为 HTTP 请求可能依赖其他的参数，所以在使用这种形式请求资源时，我们需要在初始化方法传入参数。 命令式 vs 声明式 现有的 iOS 开发中的网络服务层一般都是使用这两种组织方式，我们一般会按照资源或者功能来划分命令式中的 Manager 类，而声明式的 Request 类与实际请求是一对一的关系。 这两种网络层的组织方法在笔者看来没有高下之分，无论是 Manager 还是 Request 的方式，尤其是后者由于一个类只对应一个 API 请求，在整个 iOS 项目变得异常复杂时，就会导致网络层类的数量剧增。 这个问题并不是不可以接受的，在大多数项目中的网络请求就是这么做的，虽然在查找实际的请求类时有一些麻烦，不过只要遵循一定的命名规范还是可以解决的。 小结 现有的 MVC 下的 Model 层，其实只起到了对数据结构定义的作用，它将服务端返回的 JSON 数据，以更方便使用的方式包装了一下，这样呈现给上层的就是一些即拆即用的『字典』。 单独的 Model 层并不能返回什么关键的作用，它只有与网络服务层 Service 结合在一起的时候才能发挥更重要的能力。 而网络服务 Service 层是对 HTTP 请求的封装，其实现形式有两种，一种是命令式的，另一种是声明式的，这两种实现的方法并没有绝对的优劣，遵循合适的形式设计或者重构现有的架构，随着应用的开发与迭代，为上层提供相同的接口，保持一致性才是设计 Service 层最重要的事情。 服务端的 Model 层 虽然文章是对客户端中 Model 层进行分析和介绍，但是在客户端大规模使用 MVC 架构模式之前，服务端对于 MVC 的使用早已有多年的历史，而移动端以及 Web 前端对于架构的设计是近年来才逐渐被重视。 因为客户端的应用变得越来越复杂，动辄上百万行代码的巨型应用不断出现，以前流水线式的开发已经没有办法解决现在的开发、维护工作，所以合理的架构设计成为客户端应用必须要重视的事情。 这一节会以 Ruby on Rails 中 Model 层的设计为例，分析在经典的 MVC 框架中的 Model 层是如何与其他模块进行交互的，同时它又担任了什么样的职责。 Model 层的职责 Rails 中的 Model 层主要承担着以下两大职责： 使用数据库存储并管理 Web 应用的数据； 包含 Web 应用所有的业务逻辑； 除了上述两大职责之外，Model 层还会存储应用的状态，同时，由于它对用户界面一无所知，所以它不依赖于任何视图的状态，这也使得 Model 层的代码可以复用。 Model 层的两大职责决定了它在整个 MVC 框架的位置： 因为 Model 是对数据库中表的映射，所以当 Controller 向 Model 层请求数据时，它会从数据库中获取相应的数据，然后对数据进行加工最后返回给 Controller 层。","link":"/source/back/MCV_MVVM_MVP.html"},{"title":"Mesh Transforms","text":"Mesh Transforms 先上源代码 本文很简单粗暴，在 layer 中引入了一些点，然后通过移动点来改变整体的形状。 CAMeshVertex CAMeshVertex 是相当简单的一个结构体 1234typedef struct CAMeshVertex { CGPoint from; CAPoint3D to;} CAMeshVertex; CAPoint3D 看上去和 CGPoint 很类似，只不过拓展了 z 轴 12345typedef struct CAPoint3D { CGFloat x; CGFloat y; CGFloat z;} CAPoint3D; CAMeshVertex 的想法是相当简单：他描述了平面点和3D 空间的映射， CAMeshFace 1234typedef struct CAMeshFace { unsigned int indices[4]; float w[4];} CAMeshFace;","link":"/source/back/Mesh_Transform.html"},{"title":"Metal 编程指南","text":"Metal Programming Guide Command organization and execution model (指令组织和执行模型) 在 Metal 框架中, MTLDevice 协议定义的接口描述了一个 GPU, 该协议提供了一系列方法可以查询设备属性, 创建设备相关对象(缓存和纹理) command queue 包含了一系列的 command buffers, command queue 用于管理其中的 command buffers 的执行顺序. command buffer 包含了多个被编码的指令, 这些指令在一个特定设备上运行. command encoder 可以将绘制, 计算, 位图传输指令放到一个 command buffer 中 command buffers 最终被提交到设备中去执行. MTLCommandQueue 协议为 command queue 定义了接口, 主要是创建 command buffer 对象的方法. MTLCommandBuffer 协议 为 command queue 定义了接口, 提供了创建 command encoder, 入队列执行, 检测状态以及其他操作. 该协议定义了几种 command encoder 的类型, 他们可以被用于将不同的 GPU 任务编码到 command buffer 中执行. MTLRenderCommandEncoder 协议 - 将图形渲染指令编码为一次渲染过程. MTLComputeCommandEncoder 协议 - 编码并行计算任务 MTLBlitCommandEncoder 协议 - 在缓存和纹理之间的拷贝以及 mipmap 的生成. 任一时刻, 只有一个 Encoder 是处于激活状态的, 他可以向一个 command buffer 提交 command. 对于同一个 command buffer 来说,必须是前一个 encoder 结束后, 新的 encoder 才可以被创建并且用于此 command buffer(MTLParallelRenderCommandEncoder 例外). 一点所有的指令编码结束, MTLCommandBuffer 对象自己就会提交,并且会被标记为准备执行状态. MTLCommandQueue 协议可以用来控制这些要被执行的 MTLCommandBuffer 对象. 一个 MTLDevice 对象代表了一个可以执行 command 的 GPU. MTLDevice 协议有创建新的 command queue , 从内存创建缓存, 创建纹理, 查询设备能力的方法. 使用 MTLCreateSystemDefaultDevice 来创建首选设备. 创建: command buffers 和 command encoder 基本不耗费什么系统资源. Command queue &amp; buffer &amp; texture &amp; sample state libraries &amp; compute state &amp; render pipeline state &amp; depth/stencil state, 这些对象系统鼓励重用. Command Queue command queue 接受的是: 有序的 command buffer(将要在 GPU 中执行) 列表. 在 command queue 中的 command buffers 会被确保按顺序执行. command queue 是线程安全的. MTLDevice 中有两个方法可以创建 command queue newCommandQueue newCommandQueueWithMaxCommandBufferCount 不要没事销毁和创建 commandQueue, 记得复用. Command buffer command buffer 在被 GPU 执行之前会包含多个被编码的 command, 不支持重用, 能做的就是提交执行后, 检查状态 他还是 app 中独立可以被追踪的任务单元. 创建 command buffer MTLCommandQueue 中定义了创建 commandBuffer 的方法. 一个 MTLCommandQueue 对象只能提交给创建他的 MTLCommandQueue. commandBuffers创建的 command buffer 对象持有他执行时需要的数据. 在特定场景下, 你需要的资源已经被持有了, 可以使用commandBufferWithUnretainedReferences方法.(该方法只有在极端需要性能 app 中, 并且能够保证在 command 执行完之前资源都保持存活的情况下才使用) Executing Command MTLCommandBuffer 协议中有下列的方法可以设定在 command queue 中的执行顺序. 一个 command buffer 一定要先提交然后在执行. enqueue 方法可以为一个 command buffer 在 command queue 中预定一个位置.但是并没有把 command buffer 提交执行.当这个 command buffer 最终提交的时候, 他会在之前做 enqueue 操作的 command buffer 之后执行. commit 方法会使 command buffer 尽快的被执行.但必须是等到之前 enqueue 的 command buffer 执行后. commit 会隐式的调用 enqueue. Registering Handler Blocks for Command Buffer Execution addScheduledHandler, 当 command buffer 被 schedule 的时候调用. waitUntilScheduled, 该方法同步的等待, 当 command buffer 被完全执行完或者其所有注册 addScheduledhandler 都结束的时候返回. addCompleteHandler, 当设备执行完 command buffer 的时候调用. waitUntilCompleted, 该方法同步的等待, 当设备执行完 command buffer并且所有注册 addCompleteHandler 都返回的时候. presentDrawable:, 便捷函数:在command buffer 被 schedule 的时候, 能够将可显示的资源(CAMetalDrawable 对象)展示出来 status, read-only 属性. command buffer 是在生命周期的哪个阶段. error, 如果没有异常,为 nil. 如果有错误, 可以看看 command buffer error codes. Command Encoder 1.Encoder 是一个一次性的 transient 的对象, 在激活状态的时候可以他就可以把一个 command 追加到 command buffer 中. 使用 endEncoding 来结束编码 command. 还想要编码 command, 只能在新建一个 encoder. Creating a Command Encoding Object renderCommandEncoderWithDescriptor, 创建一个 MTLRenderCommandEncoder 类型的 encoder 用来在TMLRenderPassDescriptor中做图形渲染. computeCommandEncoder, 创建一个 MTLComputeCommandEncoder 类型的 encoder 用来做并行计算. blitCommandEncoder, 创建了一个 MTLBlitCommandEncoder 类型的 encoder 用来做内存操作. parallelRenderCommandEncoderWithDescriptor, 创建了一个MTLParallelRenderCommandEncoder 类型的 encoder, 用来让多个 MTLRenderCommandEncoder 对象在不同的线程工作,并且保证渲染到同一个 attachment(共享的MTLRenderPassDescriptor) 中. Render Command Encoder 该 encoder 需要关联一个MTLRenderPassDescriptor对象，在这个descriptor对象中包含了颜色 、景深、模板attachment，这些attachment将被当做绘制命令的目标， 该 Encoder 有如下能力: 指定图形资源, 如缓存和纹理对象。 指定 MTLRenderPipelineState对象(包含 compiled rendering state 以及顶点和片段着色器) 指定 fixed-function 状态, 包括 viewport, 更多可以看 MTLRenderCommandEncoder 协议 Compute Command Encoder 参见 MTLComputeCommandEncoder 协议 Blit Command Encoder MTLBlitCommandEncoder 协议可以追加一个 command 用来做 MTLBuffer 和 MTLTexture 之前的内存拷贝操作. 还可以用固定颜色填充纹理生成一个 mipmaps Multiple Thread, Command Buffers, Command Encoder 大多数程序使用单一的线程来encoder 绘制指令到一个 command buffer 来绘制一帧画面.在每一帧结束的时候, 提交 command buffer, 这样就可以 shcedule 并且 开始 command 的执行. 如果需要并行的为 command buffer 编码, 这样就需要在同时创建多个command buffer, 在不同的线程 encoder 每一个 command buffer. 如果提前知道 command buffer 的执行顺序, 就可以按顺序 enqueue 每个 command buffer, 就不用等待执行编码和提交. Resource Objects: Buffers and Textures MTLBuffer 表示一块非格式化的内存可以存放任何类型的数据.通常用来存放顶点, 着色器, 计算状态数据. MTLTexture 表示一块有格式的图像数据, 有特定的纹理类型 &amp; 像素格式 MTLSampleState 用于纹理对象的查找计算. Buffers are Typeless Allocations of Memory 一个 MTLBuffer 表示了一段内存区域,他可以存放任何数据类型. Creating a Buffer Object 下面的 MTLDevice 方法创建并返回一个 MTLBuffer 对象 newBufferWithLenth:Options: 分配内存创建一个 MTLBuffer 对象 newBufferWithBytes:length:options: 通过从已有的存储器中拷贝到新分配的内存中 newBufferWithBytesNoCopy:length:options:deallocator: 该方法创建一个 MTLBuffer 对象，但不会为这个对象新分配内存，而是使用已经存在的内存。","link":"/source/back/Metal%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97.html"},{"title":"Selector 是什么","text":"selector 到底是什么 1234567891011static SEL sel_alloc(const char *name, bool copy){ selLock.assertWriting(); return (SEL)(copy ? strdup(name) : name); }const char *sel_getName(SEL sel) { if (!sel) return &quot;&lt;null selector&gt;&quot;; return (const char *)(const void*)sel;} 从 sel_alloc 可以看出来，SEL 就是直接使用当前的字符串，或者把当前的字符串拷贝一份，然后char * 强转为 SEL. 从 sel_getName 可以看出，SEL 类型可以强转为 char * 也就是说 SEL 就是字符串，那么@selector(XXX)\u0010就是字符串 XXX。然后从 class 里面取方法就是拿这个字符串跟 class 里面的 methodList 里面取 method 的 name（也就是 SEL）作对比，如果相等，就取到了。","link":"/source/back/Selector%E6%98%AF%E4%BB%80%E4%B9%88.html"},{"title":"Block学习","text":"#iOS Block 概要 ##1.Block 的种类 block 常见的类型有三种: __NSGlobalBlock__（全局）, __NSStackBlock__（栈）, __NSMallocBlock（堆）。 1234567891011121314int main(int argc, const char *argv[]){ @autorelease{ int i = 10; //ARC 情况下 ^{i;}; //创建 block 的时候都是在 `栈` 中 --&gt; StackBlock void (^block) = ^{i;}; //block为 strong 类型，并且捕获了外部变量，所以赋值的时候，自动进行了 copy -&gt; MallocBlock __weak void (^weakBlock) = ^{i;};\u0010 //如果是 weak 类型的 block，不会自动进行 copy -&gt; StackBlock void (^stackBlock) = ^{}; //如果 block 是 strong 类型，并且没有捕获外部变量、或者用到全局变量，静态变量，那么就会被转换成 GlobalStack. } } 综上所述：我们可以得到如下的结论：ARC 下 1.block 没有捕获外部变量，或者用到全局变量、静态变量，则为 __NSGlobalBlock__ 2.block 用到自动变量且用正常变量来接受这个 block，则是 MallocBlock 3.block 用到自动变量或者用 weak 变量来接受 block，则是 StackBlock 备注： 1.block 用到自动变量初创之时都是 StackBlock 类型，在 ARC 环境下赋值给正常变量时，系统会将 block 拷贝到堆上，StackBlock 变成了 MallocBlock 2.在 MRC 下，赋值给正常变量时，系统不会自动的将 block 拷贝到堆上。 ###2.Block 内外关系 123456static int a;//全局或者局部变量都一样- (void)test{ ^{ a; }} //不向 block 内传递任何东西，（\u0010全局或者局部变量作用域广，任何时候用到变量 a 都是同一个变量，block 用到的变量 a 也是同一个） 123456- (void)test{ static int a; ^{ a = 10; }} //向 block 内传递地址（局部静态变量作用域有限，block 记录了局部静态变量的地址，确保了 block 内外用到的变量 a 是同一个） 123456- (void)test{ int a; ^{ a; }} // 向 block 内传递 123456- (void)test{ __block int a; ^{ a = 10; }} //向 block 内传递构造的结构体 __Block_byref 综上所述：__block 修饰的基础类型和对象类型都会构造__Block_byref结构体再传递。 构造__Block_byref结构体在传递的方式会很复杂。 ###3.梳理 在 ARC 环境下， __NSGlobalBlock__ 几乎不出现，使用起来没什么需要注意。 __NSStackBlock__ 几乎不出现， 但他是 __NSMallocBlock__ 的前身。 __NSMallocBlock__ 比较重要 看得懂编译是一切的前提 ##1.看懂编译 编译选项：clang --rewrite-objc ### A.不带参数 123456int main(int argc, const char *argv[]){ @autorelease{ ^{} } return 0;} 编译结果： 12345678910111213141516171819202122232425262728293031323334353637struct __block_impl{ void *isa; int Flags; int Reverse; void *FuncPtr;};struct __main_block_impl_0{ struct __block_impl impl; struct __main_block_desc_0 *Desc; __main_block_desc_0(void *fp, struct __main_block_desc_0 *desc, int flags = 0){ impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct _main_block_impl_0 *__cself){}static struct _main_block_func_0{ size_t reserved; size_t Block_size;}__main_block_desc_0_DATA = {0, sizeof(struct __main_block_impl_0);}int main(int argc, const char* argv[]){ void(*test)()=( (void (*))&amp;__main_block_impl_0( (void *)__main_block_func_9, &amp;__main_block_desc_0_DATA) ); ); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr((__block_impl *)test); return 0;} __main_block_impl_0 就是 block 的一个 C++的实现，0 表示第几个block，其实就是一个结构体。 __block_impl 结构体中 1. isa指向所属类，就是 block 的类型。 2. flags，标志变量，在 block 内部操作中会用到。 3. Reserved，是保留变量。 4. FuncPtr，block 执行时调用的函数指针，它包含了 isa 指针，其实 block 也是一个对象。 __main_block_desc_0 结构体中 1. Reserved，为保留字段 2. Block_size 为 block 的大小，也就是sizeof(struct __main_block_impl_0) 在上面的代码中，定义__main_block_desc_0结构体时，同时创建了__main_block_desc_0_DATA，并给它赋值，以供main函数中对__main_block_0进行初始化。 __main_block_impl_0 的isa指向了__NSConcreteStackBlock 从main函数中看，__main_block_impl_0的FuncPtr指向了函数__main_block_func_0 __main_block_impl_0的Desc也指向了定义的__main_block_desc_0时就创建的__main_block_desc_0_DATA，其中记录了 block 结构体大小等信息。 ##2.Block 实际结构 在Block_private.h 中定义了对 block 的相关结构体的真实定义 1234567891011121314struct Block_descriptor{ unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *)}struct Block_layout{ void *isa; int flags; int reserved; void (* invoke)(void *,...); struct Block_descriptor *descriptor;} invoke ,相当于上文中的 FuncPtr, block 执行时调用的函数指针，block 定义时内部的执行代码都在这个函数中。 Block_descriptor，block 的详细描述 copy/dispose,辅助拷贝/销毁函数，处理 block 范围外的变量时使用。 结论： block 就是一个里面存储了指向函数体中包含定义 block 时代码块的函数指针，以及block 外部上下文等信息的结构体。 B. 基础类型 12345678int main(int argc, const char *argv[]){ int any = 1; void (^test)() = ^{ NSLog(@&quot;%d&quot;, any); }; test(); return 0;} 编译结果： 1234567891011121314151617181920212223242526272829303132333435struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int any; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _any, int flags=0) : any(_any) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself){ int any = __cself-&gt;any; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_a_f8f541_mi_0, any); }static struct __main_block_desc_0 { size_t reserved; size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};int main (int argc, const char *argv[]){ int any = 1; void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, any)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ###C. 对象类型 12345678int main(int argc, const char *argv[]){ NSString *any = [NSString stringWithFormat:@&quot;1&quot;]\u0010; void (^test)() = ^{ NSLog(@&quot;%@&quot;, any); }; test(); return 0;} 编译结果： 123456789101112131415161718192021222324252627282930313233343536373839404142struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; NSString *any; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString *_any, int flags=0) : any(_any) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { NSString *any = __cself-&gt;any; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_b_ca6e15_mi_2, any);}static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main (int argc, const char *argv[]){ NSString *any = ((NSString *(*)(id, SEL, NSString *, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_b_ca6e15_mi_0, (NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_b_ca6e15_mi_1); void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, any, 570425344)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ###D.__block 修饰基础类型 12345678int main(int argc, const char * argv[]) { __block int any = 1; void (^test)() = ^ { NSLog(@&quot;%d&quot;,any); }; test(); return 0;} 编译结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __Block_byref_any_0 { void *__isa;__Block_byref_any_0 *__forwarding; int __flags; int __size; int any;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_any_0 *any; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_any_0 *_any, int flags=0) : any(_any-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_any_0 *any = __cself-&gt;any; // bound by ref NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_c_88a22a_mi_0, (any-&gt;__forwarding-&gt;any)); }static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main(int argc, const char *argv[]){ __attribute__((__blocks__(byref))) __Block_byref_any_0 any = {(void*)0,(__Block_byref_any_0 *)&amp;any, 0, sizeof(__Block_byref_any_0), 1}; void(*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_any_0 *)&amp;any, 570425344)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ###E. __block修饰对象类型 12345678int main(int argc, const char * argv[]) { __block NSString * any = [NSString stringWithFormat:@&quot;1&quot;]; void (^test)() = ^ { NSLog(@&quot;%@&quot;,any); }; test(); return 0;} 编译结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};static void __Block_byref_id_object_copy_131(void *dst, void *src) { _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);}static void __Block_byref_id_object_dispose_131(void *src) { _Block_object_dispose(*(void * *) ((char*)src + 40), 131);}struct __Block_byref_any_0 { void *__isa;__Block_byref_any_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSString *any;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_any_0 *any; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_any_0 *_any, int flags=0) : any(_any-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_any_0 *any = __cself-&gt;any; // bound by ref NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_d_a788e6_mi_1, (any-&gt;__forwarding-&gt;any)); }static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main(int argc, const char *argv[]){ __attribute__((__blocks__(byref))) __Block_byref_any_0 any = {(void*)0,(__Block_byref_any_0 *)&amp;any, 33554432, sizeof(__Block_byref_any_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSString *(*)(id, SEL, NSString *, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_d_a788e6_mi_0)}; void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_any_0 *)&amp;any, 570425344)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ##3. 结果分析 ###3.1 1. __main_block_func_0 为 block 具体实现函数 2. __main_block_desc_0 为 block 大小描述 + 拷贝函数 + 销毁函数 3. __main_block_impl_0 block 的一切都封装在内，包括前两个函数 + 捕获的参数。该结构体就是 block 在内存里的真实存在。 4. block 的调用((void (*)(__block_impl *)) ((__block_impl *)test) -&gt; FuncPtr)((__block_impl *)test); ###3.2 以 A 为例 block 的调用 12void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0,&amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); 调用__main_block_impl_0结构体的构造函数，生成__main_block_impl_0结构体的实例，获取实例地址，将这个地址转成函数地址。 (void (*)(__block_impl *))读取地址，强转成函数 ((__block_impl *)test)之类对象转换成父类，这个地方 test 指针真正的指向对象__main_block_impl_0,是一个子类对象，但是__main_block_impl_0包含了__block_impl结构体，所以读取子类对象的父类对象大小，就能取到了父类对象 ###3.3 对象类型编译结果 1. 拷贝__main_block_impl_0 -&gt; __Block_byref_any 123static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);} 销毁 __main_block_impl_0 -&gt; __Block_byref_any 123static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);} ###3.4 __block修饰编译结果有的","link":"/source/back/block%E5%AD%A6%E4%B9%A0.html"},{"title":"iOS 内存管理","text":"iOS 内存管理和 malloc 源代码解读 iOS 内存基本管理 在接触 iOS 开发的时候，我们知道引用计数器的概念，也知道 ARC 和 MRC，但其实这仅仅是对堆内存上对象的内存管理。 在内存管理方面，其实 iOS 和其他操作系统总体上来说是大同小异的，大的框架原理基本相似，小的细节有所创新和不同。 和其他操作系统上运行的进程类似，iOS App 进程的地址空间也分为代码区、数据区、栈区和堆区。进程开始时，会把 mach-o 文件中的各部分，按需加载到内存中。 对于一般的 iPhone 来说，实际物理内存都在1GB 左右，对于超大的内存需求，也和一般的操作系统一样，都由系统内核维护一套虚拟内存系统。但这里需要注意的是 iOS 的虚拟系统原则略有不同，最截然不同的地方就是当物理内存内存紧张情况时得处理。 当物理内存紧张时，iOS 会把可以通过重新映射来加载的内存直接清理出内存，对于不可再生的数据，iOS 需要 App 进程配合处理，由各进程发送内存警告要求配合释放内存。对于不能及时释放足够内存的，直接 kill 掉进程，必要时甚至是前台运行的 app。。 所以，iOS 在外存没有交换区，没有内存页换出的过程。 malloc 基本原理 在 iOS APP 进程地址空间各个区域中，最灵活的就要属堆区，它为进程动态分配内存，也是我们经常和内存打交道的地方。 通常，我们会在需要新对象的时候，进行[NSObject alloc]调用，而释放对象时需要 release（ARC 会自动帮你做到这些）。 而这些 alloc、release 方法的调用，最终会走到 libsystem_malloc.dylib 的 malloc() 和 free() 函数这里。libsystem_malloc.dylib 是 iOS 内核之外的一个内存库，我们 app 进程需要的内存，先会请求到这里，但最终libsystem_malloc.dylib也都会向 iOS 的系统内核发起申请，映射实际内存到 app 进程的地址空间。 从苹果公开的 malloc 的源代码上看，原理大概如此： malloc 内存分配基于 malloc zone，并将内存分配按大小分为 nano、tiny、small、large 几种类型。申请时按需进行最适分配。 malloc 在首次调用时，初始化 default zone，在 64 位情况下，会初始化 default zone 为 nano zone。同事初始化一个 scalable zone 作为 helper zone，nano zone 负责 nano 大小的分配，scalable zone 负责 tiny、small 和 large 内存的分配。每次 malloc 时，根据传入的 size 参数，优先交个 nano zone 做分配处理，如果大小不在 nano 范围，则转交给 helper zone 处理。 nano malloc 在支持64位的条件下，malloc 优先考虑 nano malloc，负责对 256B 以下小内存分配，单位是16B。 nano zone 分配内存的地址空间范围是 0x00006nnnnnnnnnnn （OSX 64位情况），将地址空间从大到小一次分为 magazine、band、slot 几个级别 magazine 范围对应于 CPU，CPU0 对应 Mag0、CPU1 对应 Mag1，以此类推； Band 范围为 2M，连续分配内存当内存不够时以 Band 为单位向内核请求。 Slot 则对应每个 Band 中 128K 大小的范围，每个 Band 都分为 16个 Slot，分别对应于 16B、32B、.... 256B大小，支持他们的内存分配。 分配过程 确定当前 CPU 对应的 mag 和通过 size 参数计算出来的 slot，去对应的 metadata 的链表中取已经被释放过得内存区块缓存。判断渠道检查指针地址是否有问题，没有问题就直接返回。 初次进行 nano malloc 时，nano zone 并没有缓存，会直接在 nano zone 范围的地址空间上直接分配连续地址内存。 如当前 band 中当前 slot 耗尽，则向系统申请新的 band （每个 band 固定大小2M，容纳了16个128K 的槽），连续地址分配内存的基地址、limit 地址以及当前分配到的地址由 meta data 结构维护起来，而这些 meta data 则以 mag、slot 为维度（mag 个数是处理器个数，slot 是16个）的二维数组形式，放在 nanozone_t 的 meta_data字段中。 当 app 通过 free() 释放内存时：malloc 库会检查指针地址，如果没有问题，则以链表形式将这些区块按大小存储起来。这些链表的头部放在 meta_data 数组中对应的 [mag][slot] 元素中。 其实从缓存获取空余内存和释放内存时都会对指向这片内存区域的指针进行检查，如果有类似地址不对齐、未释放、多次释放、所属地址与预期的 mag、slot 不匹配等情况都会以报错结束。 除了分配和释放、系统内存吃紧时，nano zone 需将 cache 的内存区块还给系统，这主要是通过对各个 slot 对应的 meta data 上挂着空闲的链表上内存区块回收来完成。 scalable zone 上内存分配简要分析 对于超出 nano 大小范围或者不支持 nano 分配的，直接会在 scalable zone 上分配。由于 scalable zone 上的内存分配比 nano 分配要复杂。下面只做简单介绍。 scalable zone 上分配的内存包括 tiny、small、large 三大类。其中 tiny 和 small 的分配、释放过程大致相同，large 类型有自己的方式管理。 而 tiny、small 的方式也遵循着 nano 分配中的原则，新内存从系统申请并分配，free 后按照大小以特定的形式缓存起来，供后续分配使用。这里的分配在 region 上进行，region 和 nano malloc 里的 band 概念即为相似，但不同的是地址空间未必连续，而且每个 region 都有自己的位图等描述信息。和 nano 一样每个 CPU 都有一个 magazine，除此之外还分配了一个 index 为 -1 的 magazine 作为后备之用。 以 tiny 的情况为例， 分配时： 确定当前线程所在处理器的 magazine index，找到对应的 magazine 结构。 优先查看上次最后释放的区块是否和此次请求的大小刚好相等（都是对齐后的 slot 大小），如果是则直接返回。 如果不是，则查找 free list 中当前请求大小区块的空闲缓存列表，如果有返回，并整理列表。 如果没有，则在 free list 找比当前申请区块大的，而且最接近的缓存，如果有返回，并把剩余大小放到 free list 中另外的链表上。（这里需要注意的是，在一般情况下，free list 分为64个槽，0-62 上挂载区块的大小都是按 16B 为单位递增，63为所有更大的内存区块挂载的地方） 上面几项都不行，就在最后一个 region 的尾部或者首部（如果支持 ALSR）找空闲区域分配。 如果还是不行，说明所有现有 region 都没有可用空间了，那么从一个后备 magazine 中取出一个可用 region，完整地拿过来放到当前 magazine，再走一遍上面的步骤。 如果这都不行，那只能向内核申请一块新的 region 区域，挂载到当前的 magazine 下并分配内存。 如果还是不行，那就没招了，系统也给不到内存，就返回报错。 free 时 检查指针指向的地址是否有问题。 如果 last free 指针上没有挂载内存区块，则当道 last free 上就 OK 了。 如果有 last free，置换内存，并把 last free 原有内存区块挂载到 free list 上。（在挂载的 free list 前，会根据 region 位图检查前后区块是否能合并成为更大的区块，如果能会合并成一个） 合并后所在的 region 如果空闲字节超过一定条件，则把 region 放到后备的 magazine 中（-1）。 如果整个 region 都是空的，则直接还给系统内核，一了百了。 而 large 的情况，malloc 以页为单位申请和分配内存，不区分 magazine，scalable zone 同意维护一个 hash table 管理已申请的内存。而且由于内存区域都比较庞大，置换村总量2G 的区块，氛围16个元素，每个最大为128M。large 相关的结构相对简单。 苹果 malloc 代码：","link":"/source/back/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},{"title":"iOS 静态库转动态库","text":"iOS 静态库转动态库的方法 问题 由于二级制 __TEXT 段 60M 的上限问题，支付宝钱包也将个别的 SDK 转换成动态库。 在实际抓换的过程中，由于源代码保密的问题，第三方只能提供二级制的静态库，不能提供源代码。因为我们只能把静态库直接转成动态库 抓换方法 转换方法是基于动态库本身编译和链接的特点：在链接时会把依赖的静态库 symbol 复制到本库 步骤示意图：（S1 表示静态库，D1 表示动态库） 举例说明：将不依赖其他的静态库的静态库 AMapFoundationKit.framework 转换成动态库 AMapFoundationKit.framework 步骤一 可以从Xcode原生的动态库模版一个空的动态库，与静态库名称相同，即AMapFoundationKit。 步骤二 ####2.1 设置Framework搜索路径，在AMapFoundationKit -&gt; Build Settings -&gt; FRAMEWORK_SEARCH_PATHS设置成静态库的路径 2.2 将静态库拖到AMapFoundationKit -&gt; Build Phases -&gt; Link Binary With Libraries 2.3 2.3 将静态库Headers中的所有头文件拖到AMapFoundationKit -&gt; Build Phases -&gt; Headers -&gt; Public，不用Copy文件。同时删除模版生成的AMapFoundationKit.h。 2.4 将静态库中的所有资源拖到AMapFoundationKit -&gt; Build Phases -&gt; Copy Bundle Resources 2.5 定义Link时load all symbols，将AMapFoundationKit -&gt; Build Settings -&gt; OTHER_LDFLAGS中添加-all_load 2.6 关闭Version System，AMapFoundationKit -&gt; Build Settings -&gt; VERSIONING_SYSTEM设置为None 2.7 创建触发编译的空文件（不用写任何函数），因为无编译文件将不会生成macho文件。 2.8 将静态库framework的所有系统库的依赖添加进来，可根据编译时symbol未找到symbol报错，依次添加到AMapFoundationKit -&gt; Build Phases -&gt; Link Binary With Libraries 步骤三 执行编译 步骤四 获取编译后的产物，即动态库AMapFoundationKit.framework","link":"/source/back/iOS%E9%9D%99%E6%80%81%E5%BA%93%E8%BD%AC%E5%8A%A8%E6%80%81%E5%BA%93.html"},{"title":"IMP是什么","text":"IMP 到底是什么 IMP 的定义可以再 objc.h 中找到 12typedef void (*IMP)(void /* id, SEL, ... */ ); typedef void (*IMP)(void); 其实就是参数为空，返回值为空的函数指针。 #1 IMP 能直接调用么 定义一个类： 1234567891011@interface TestClass : NSObject@end@implementation TestClass- (id)test:(NSInteger)arg { return nil;}@end 获取 IMP 并调用： 123456int main(int argc, char * argv[]) { IMP testIMP = class_getMethodImplementation([TestClass class], @selector(test:)); testIMP(); return 1;} #2 IMP 的返回值和参数怎么定？ 不对劲吧，参数没有传。怎么判断一个方法的具体参数呢： 1Method testMethod = class_getInstanceMethod([TestClass class], @selector(test:)); 而 Method 是： 12345struct objc_method { SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;} 从调试窗口看到的： method_types是@24@0:8q16 [4], 内容都是一个字符跟一个数字成对出现, 第一对表示返回值和参数长度(其中@表示返回值为id, 24表示参数长度为24字节),后面三对代表三个参数(@0表示参数是id而参数的偏移为0, :8表示参数是selector偏移为8,q16表示参数为long long偏移为16), 完整的type encoding参见参考. 也就意味着test:方法的IMP的类型应该是id (*IMP)(id, SEL, long long), 其中参数的第一个id是self, 第二个SEL是当前IMP对应的selector, 第三个long long就是test:的arg参数. 更详细的介绍见参考.","link":"/source/back/imp%E6%98%AF%E4%BB%80%E4%B9%88.html"},{"title":"依赖注入","text":"iOS 依赖注入（DI） 依赖注入DI: Dependency Injection是控制反转IoC: Inversion of Control的实现方式之一，另外一种是依赖查找DL: Dependency Lookup 什么是依赖注入(Dependency injection) 在StackOverflow上有个问题：如何向一个5岁的小孩解释依赖注入 “When you go and get things out of the refrigerator for yourself, you can cause problems. You might leave the door open, you might get something Mommy or Daddy doesn’t want you to have. You might even be looking for something we don’t even have or which has expired. What you should be doing is stating a need, “I need something to drink with lunch,” and then we will make sure you have something when you sit down to eat.” 映射到面向对象开发中的就是：高层类（5岁小孩）应该依赖底层基础设施（家长）来提供必要的服务。 依赖倒置解决了高层次模块依赖于低层次模块和细节的问题 Dependency Injection是一个将行为从依赖中分离的技术。允许开发者定义一个方法函数依赖于外部其他各种交互，而不需要编码如何获得这些外部交互的实例。这样就在各种组件之间解耦，从而获得干净的代码，相比依赖的硬编码，一个组建只有在运行时才调用其所需要的其他组件，因此在代码运行时，通过特定的框架和容器，将其所需要的其他依赖组件进行注入，主动推入。 依赖注入可以看成是控制反转（inversion of control）的一个特例。反转的是依赖，而不是其他。“Inversion of Control Containers and the Dependency Injection pattern” 依赖注入与IOC模式类似于工厂模式，是一种解决调用者和被调用者依赖耦合关系的模式。他解决了对象之间的依赖关系，使得对象只依赖于IOC/DI 容器，实现松散耦合，然后在对象创建时，由IOC/DI容器将其依赖的对象注入其内部。 DI 解决的问题 所有的对象都必须创建；或者说：使用对象之前必须创建，但是现在我们可以不必一定遵循这个定律了，我们可以从DI容器中直接获得一个对象然后直接使用，无需事先创建它们。 依赖注入 参考文章：依赖注入 1234567891011121314- (NSNumber *)nextReminderId{ NSNumber *currentReminderId = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;currentReminderId&quot;]; if (currentReminderId) { // 增加前一个 reminderId currentReminderId = @([currentReminderId intValue] + 1); } else { // 如果还没有，设为 0 currentReminderId = @0; } // 将 currentReminderId 更新到 model 中 [[NSUserDefaults standardUserDefaults] setObject:currentReminderId forKey:@&quot;currentReminderId&quot;]; return currentReminderId;} 构造器注入 构造器注入，即将某个依赖对象传入到构造器中 (在 Objective- C中指 designated 初始化方法) 并存储起来，以便在后续过程中使用： 1234567891011121314@interface Example ()@property (nonatomic, strong, readonly) NSUserDefaults *userDefaults;@end@implementation Example- (instancetype)initWithUserDefaults:(NSUserDefaults *userDefaults){ self = [super init]; if (self) { _userDefaults = userDefaults; } return self;}@end 1234567891011- (NSNumber *)nextReminderId{ NSNumber *currentReminderId = [self.userDefaults objectForKey:@&quot;currentReminderId&quot;]; if (currentReminderId) { currentReminderId = @([currentReminderId intValue] + 1); } else { currentReminderId = @0; } [self.userDefaults setObject:currentReminderId forKey:@&quot;currentReminderId&quot;]; return currentReminderId;} 属性注入 对于属性注入，nextReminderId 的代码看起来和 self.userDefaults 的做法是一致的。只是这次不是将依赖对象传递给初始化方法，而是采用属性赋值方式 1234@interface Example@property (nonatomic, strong) NSUserDefaults *userDefaults;- (NSNumber *)nextReminderId;@end 方法注入 如果依赖对象只在某一个方法中被使用，则可以利用方法参数做注入： 1234567891011- (NSNumber *)nextReminderIdWithUserDefaults:(NSUserDefaults *)userDefaults{ NSNumber *currentReminderId = [userDefaults objectForKey:@&quot;currentReminderId&quot;]; if (currentReminderId) { currentReminderId = @([currentReminderId intValue] + 1); } else { currentReminderId = @0; } [userDefaults setObject:currentReminderId forKey:@&quot;currentReminderId&quot;]; return currentReminderId;} Demo Demo场景 Demo 中使用依赖注入的方式来为不同的 BioAuthDemoObject 提供不同的对象属性。 Demo结构 基类有相同的方法，只有在运行的时候，才会调用传入的实现 #参考 Dependency Injection, iOS and You 关于IOS依赖注入(DI)那些事 依赖注入 iOS控制反转(IoC)与依赖注入(DI)的实现 objection typhoon Objection 与 Typhoon 的协议绑定对比","link":"/source/back/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html"},{"title":"深入理解 autorelease","text":"深入理解 autorelease 先上一段代码，分别实现了包含 autorelease pool 不包含 autorelease pool 的函数 123456789void autoreleasepool() { @autoreleasepool { NSObject *a = [[NSObject alloc] init]; }}void noautoreleasepool() { NSObject *a = [[NSObject alloc] init];} 编译后再用hopper disassembler 反编译，然后看 autorelasepool函数的汇编代码。 123456789101112131415161718192021222324252627282930 _autoreleasepool:0000000100006b80 stp x29, x30, [sp, #0xfffffff0]! ; XREF=_main+240000000100006b84 mov x29, sp0000000100006b88 sub sp, sp, #0x100000000100006b8c bl imp___stubs__objc_autoreleasePoolPush0000000100006b90 adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006b94 add x8, x8, #0xc30 ; @selector(alloc)0000000100006b98 adrp x9, #0x100008000 ; imp___got_dyld_stub_binder0000000100006b9c add x9, x9, #0xc40 ; objc_cls_ref_NSObject0000000100006ba0 ldr x9, [x9] ; objc_cls_ref_NSObject0000000100006ba4 ldr x1, [x8] ; @selector(alloc)0000000100006ba8 str x0, [sp]0000000100006bac mov x0, x90000000100006bb0 bl imp___stubs__objc_msgSend0000000100006bb4 adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006bb8 add x8, x8, #0xc38 ; @selector(init)0000000100006bbc ldr x1, [x8] ; @selector(init)0000000100006bc0 bl imp___stubs__objc_msgSend0000000100006bc4 movz x8, #0x00000000100006bc8 add x9, sp, #0x80000000100006bcc str x0, [sp, #0x8]0000000100006bd0 mov x0, x90000000100006bd4 mov x1, x80000000100006bd8 bl imp___stubs__objc_storeStrong0000000100006bdc ldr x0, [sp]0000000100006be0 bl imp___stubs__objc_autoreleasePoolPop0000000100006be4 mov sp, x290000000100006be8 ldp x29, x30, [sp], #0x100000000100006bec ret ; endp 再看 noautoreleasepool 函数的反汇编代码： 1234567891011121314151617181920212223242526 _noautoreleasepool:0000000100006bf0 stp x29, x30, [sp, #0xfffffff0]! ; XREF=_main+280000000100006bf4 mov x29, sp0000000100006bf8 sub sp, sp, #0x100000000100006bfc adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006c00 add x8, x8, #0xc30 ; @selector(alloc)0000000100006c04 adrp x9, #0x100008000 ; imp___got_dyld_stub_binder0000000100006c08 add x9, x9, #0xc40 ; objc_cls_ref_NSObject0000000100006c0c ldr x9, [x9] ; objc_cls_ref_NSObject0000000100006c10 ldr x1, [x8] ; @selector(alloc)0000000100006c14 mov x0, x90000000100006c18 bl imp___stubs__objc_msgSend0000000100006c1c adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006c20 add x8, x8, #0xc38 ; @selector(init)0000000100006c24 ldr x1, [x8] ; @selector(init)0000000100006c28 bl imp___stubs__objc_msgSend0000000100006c2c movz x8, #0x00000000100006c30 add x9, sp, #0x80000000100006c34 str x0, [sp, #0x8]0000000100006c38 mov x0, x90000000100006c3c mov x1, x80000000100006c40 bl imp___stubs__objc_storeStrong0000000100006c44 mov sp, x290000000100006c48 ldp x29, x30, [sp], #0x100000000100006c4c ret ; endp 两者的区别是 autorelease 版本多了如下内容 12345670000000100006b8c bl imp___stubs__objc_autoreleasePoolPush ; 调用 objc_autoreleasePoolPush方法0000000100006ba8 str x0, [sp] ; 把objc_autoreleasePoolPush的返回值入栈......0000000100006bdc ldr x0, [sp] ; 把之前入栈的返回值出栈0000000100006be0 bl imp___stubs__objc_autoreleasePoolPop ; 调用objc_autoreleasePoolPop方法 发现了和预想不一样的地方，按照常理，在 autoreleasepool 里面的对象初始化的时候，似乎要调用-[NSObject autorelease] 来让他自动释放，然而，并没有。 看看 objc 的源码 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 的实现。 objc_autoreleasePoolPush 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void *objc_autoreleasePoolPush(void){ if (UseGC) return nil; return AutoreleasePoolPage::push();}static inline void *push() { id *dest; if (DebugPoolAllocation) { // Each autorelease pool starts on a new pool page. dest = autoreleaseNewPage(POOL_SENTINEL); } else { dest = autoreleaseFast(POOL_SENTINEL); } assert(*dest == POOL_SENTINEL); return dest;}static inline id *autoreleaseFast(id obj){ AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) { return page-&gt;add(obj); } else if (page) { return autoreleaseFullPage(obj, page); } else { return autoreleaseNoPage(obj); }}static __attribute__((noinline))id *autoreleaseNoPage(id obj){ // No pool in place. assert(!hotPage()); if (obj != POOL_SENTINEL &amp;&amp; DebugMissingPools) { // We are pushing an object with no pool in place, // and no-pool debugging was requested by environment. _objc_inform(&quot;MISSING POOLS: Object %p of class %s &quot; &quot;autoreleased with no pool in place - &quot; &quot;just leaking - break on &quot; &quot;objc_autoreleaseNoPool() to debug&quot;, (void*)obj, object_getClassName(obj)); objc_autoreleaseNoPool(obj); return nil; } // Install the first page. AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); // Push an autorelease pool boundary if it wasn't already requested. if (obj != POOL_SENTINEL) { page-&gt;add(POOL_SENTINEL); } // Push the requested object. return page-&gt;add(obj);} push 的主要作用是选一个/建一个autoreleasePoolPage ，设定为hotpage备用，流程图如下 objc_autoreleasePoolPop 1","link":"/source/back/%E7%90%86%E8%A7%A3autorelease.html"},{"title":"如何分析Crash日志","text":"iOS Crash Log 解析 #1 简介 Crash Log 是用来分析 Crash 问题的主要手段。 #2 示例 下面的 Crash Log 取自于天猫客户端，Log 中不重要的部分已经被略去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Incident Identifier: C7F427F7-FDF8-41C3-9659-3C54756B1547CrashReporter Key: TODOHardware Model: iPhone8,2Process: Tmall4iPhone [1313]Path: /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhoneIdentifier: Unknown|com.taobao.tmallVersion: 5.24.1 (5.24.1)Code Type: ARM-64Parent Process: ??? [1]Date/Time: 2016-10-07 03:16:35 +0000OS Version: iPhone OS 10.0.1 (14A403)Report Version: 104Exception Type: SIGSEGVException Codes: SEGV_ACCERR at 0x110Triggered by Thread: 42Thread 0:0 libsystem_kernel.dylib 0x0000000186bf016c _mach_msg_trap :8 (in libsystem_kernel.dylib)1 CoreFoundation 0x0000000187bedcec ___CFRunLoopServiceMachPort :192 (in CoreFoundation)2 CoreFoundation 0x0000000187beb908 ___CFRunLoopRun :1132 (in CoreFoundation)3 CoreFoundation 0x0000000187b1a048 _CFRunLoopRunSpecific :444 (in CoreFoundation)4 GraphicsServices 0x000000018959d198 _GSEventRunModal :180 (in GraphicsServices)5 UIKit 0x000000018daf3818 -[UIApplication _run] :684 (in UIKit)6 UIKit 0x000000018daee550 _UIApplicationMain :208 (in UIKit)7 Tmall4iPhone 0x000000010006bf7c main main.m:27 (in Tmall4iPhone)8 libdyld.dylib 0x0000000186afc5b8 _start :4 (in libdyld.dylib)Thread 42 Crashed:0 CFNetwork 0x00000001883cd970 __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 (in CFNetwork)1 CFNetwork 0x00000001882a49c4 __ZN14SPDYConnection20_onqueue_closeStreamEP10SPDYStream :236 (in CFNetwork)2 CFNetwork 0x00000001882a48b4 ____ZN14SPDYConnection19startEnqueuedStreamEP10SPDYStream_block_invoke_2 :28 (in CFNetwork)3 libdispatch.dylib 0x0000000186ac9200 __dispatch_call_block_and_release :24 (in libdispatch.dylib)4 libdispatch.dylib 0x0000000186ac91c0 __dispatch_client_callout :16 (in libdispatch.dylib)5 libdispatch.dylib 0x0000000186ad7444 __dispatch_queue_serial_drain :928 (in libdispatch.dylib)6 libdispatch.dylib 0x0000000186acc9a8 __dispatch_queue_invoke :652 (in libdispatch.dylib)7 libdispatch.dylib 0x0000000186ad938c __dispatch_root_queue_drain :572 (in libdispatch.dylib)8 libdispatch.dylib 0x0000000186ad90ec __dispatch_worker_thread3 :124 (in libdispatch.dylib)9 libsystem_pthread.dylib 0x0000000186cd12c8 __pthread_wqthread :1288 (in libsystem_pthread.dylib)10 libsystem_pthread.dylib 0x0000000186cd0db4 _start_wqthread :4 (in libsystem_pthread.dylib)Thread State: lr:0x00000001882a49c4 x6:0x0000000170ade8b0 x7:0x0000000000000450 x4:0x0000000000000001 x5:0x0000000000000010 x2:0x0000021aaf85c0e0 x3:0xfffffff0001fc088 x0:0x0000000000000000 x1:0x00000001ab457998 cpsr:0x0000000080000000 x10:0x0000000000077234 x16:0xfffffff100000000 x15:0xfffffff500000000 x18:0x0000000000000000 x17:0x003000000000f49f x12:0xffc0000800000000 x11:0x0000000000049198 x14:0xfffffffd00000001 fp:0x000000016e5b2c50 x13:0x0000000800000000 sp:0x000000016e5b2b70 x19:0x00000001701574a0 x21:0x00000001ab457998 x9:0x0000000000000000 x8:0x00000001a6bcc000 x20:0x0000000000000000 pc:0x00000001883cd970 x28:0xffffffffffffffff x27:0x000000016e5b30e0 x26:0x0000000000000014 x25:0x0000000000000000 x24:0x0000000000000000 x23:0x00000001746f2580 x22:0xdc990b23045700adBinary Images:0x0000000100064000 - 0x0000000103517fff Tmall4iPhone arm64 &lt;d21caba7463b3a38a7ee3ae16448f4b6&gt; /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhone0x000000018823b000 - 0x00000001885aafff CFNetwork arm64 &lt;ca09941bfd353bb8b6b679a0f14cad1e&gt; /System/Library/Frameworks/CFNetwork.framework/CFNetwork #3 关注点 Identifier: Unknown|com.taobao.tmall, 在这里区分是线上版本还是线下开发版本. Version: 5.24.1 (5.24.1), 应用版本号. Code Type: ARM-64, 代码架构, 目前有ARM/ARM-64两种. OS Version: iPhone OS 10.0.1 (14A403), 系统版本及build号, 用来查找系统库文件, 用于疑难问题的排查. Exception Type: SIGSEGV, 异常类型常见的有SIGSEGV/SIGABRT/SIGTRAP/SIGBUS/SIGILL等. Exception Codes: SEGV_ACCERR at 0x110, 非法访问0x110这个没有访问权限的地址. Triggered by Thread: 42, 挂的线程是Thread 42, 待会看调用栈的时候, 看Thread 42的调用栈就好. 12345SIGSEGV 访问了非法的地址(地址还没有从系统映射到当前进程的内存空间), 一般是野指针导致, 而野指针一般由于多线程操作对象导致.SIGABRT 一般是Exception或者其他的代码主动退出的问题.SIGTRAP 代码里面触发了调试指令, 该指令可能由编译器提供的trap方法触发, 如'__builtin_trap()'SIGBUS 一般由于地址对齐问题导致, 单纯的OC代码挺难触发的, 主要是系统库方法或者其他c实现的方法导致SIGILL 表示执行了非法的cpu指令, 但是一般是由于死循环导致 那么我们来看 Thread 42 123Thread 42 Crashed:0 CFNetwork 0x00000001883cd970 __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 (in CFNetwork)1 CoreFoundation 0x0000000187bedcec ___CFRunLoopServiceMachPort :192 (in CoreFoundation) 这里我们取了两条调用栈记录, 这里的每条调用记录都叫做frame, 每条有一个编号0和1, 这个编号代表的是frame number, 它是当前frame在整个调用栈中的索引. 先看frame #0, frame #0是当前调用的方法的信息, 0 CFNetwork 0x00000001883cd970 __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 (in CFNetwork), CFNetwork代表当前frame调用的方法所在的镜像(可执行文件或动态库)的名称, 0x00000001883cd970代表当前执行的指令在内存中的地址(也就是crash的指令的地址), __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 是前面那个地址符号化后的方法名称, :44表示挂的指令相对于符号化出来的方法的首地址的偏移量. 再看frame #1, frame #1是调用frame #0方法的地方, 1 CoreFoundation 0x0000000187bedcec ___CFRunLoopServiceMachPort :192 (in CoreFoundation), 镜像名和地址不多说, 这里要说说偏移量:192, 除了frame #0的方法地址是取的pc寄存器的内容(存放的当前指令的地址), 而其他frame实际上存的都是历史记录, 而为了省内存和cpu, frame中并不会保存所有的寄存器的值, 只存了lr寄存器的内容(存放的是方法调用完后要返回的地址), 而返回地址是调用方法的地址的下一个指令地址. 因此偏移量192(lr), 对应的调用处的地址是188(pc). 其他frame的看法参见frame #1. Thread State:, 后面跟的内容是在frame #0挂的时候的所有寄存器的值, 寄存器中可能存放的是一个指令的地址/一个指向对象的指针/一个数值. 寄存器的值结合汇编代码, 可以推断具体是对某个方法调用的参数或者类的成员变量导致的野指针. 后续会有详细的问题分析实战文章做介绍. Binary Images: 表示当前运行时所加载的所有的镜像的名称/uuid/加载地址等信息. 看一条示例: 10x0000000100064000 - 0x0000000103517fff Tmall4iPhone arm64 &lt;d21caba7463b3a38a7ee3ae16448f4b6&gt; /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhone 000000100064000 - 0x0000000103517fff表示镜像Tmall4iPhone在内存中的加载地址的起始范围, 这个在符号化和调试疑难问题时是一个很重要的参考. Tmall4iPhone是镜像名称, arm64是架构, d21caba7463b3a38a7ee3ae16448f4b6是镜像的uuid, /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhone是镜像在用户手机上地址. 注1: uuid可以通过dwarfdump --uuid Tmall4iPhone 查看, 确定镜像是否相同.","link":"/source/back/%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90Crash%E6%97%A5%E5%BF%97.html"},{"title":"路由","text":"APP 内组件路由设计 APP内部主要为了解决两个问题 1. 各个页面和组件之间的跳转问题 2. 各个组件之间的相互调用. 各个页面和组件之间的跳转问题 屏幕快照 2018-02-27 下午4.11.24 在iOS开发的过程中，经常会遇到以下的场景，点击按钮跳转Push到另外一个界面，或者点击一个cell Present一个新的ViewController。在MVC模式中，一般都是新建一个VC，然后Push / Present到下一个VC。但是在MVVM中，会有一些不合适的情况。 40_17 众所周知，MVVM把MVC拆成了上图演示的样子，原来View对应的与数据相关的代码都移到ViewModel中，相应的C也变瘦了，演变成了M-VM-C-V的结构。这里的C里面的代码可以只剩下页面跳转相关的逻辑。如果用代码表示就是下面这样子： 假设一个按钮的执行逻辑都封装成了command。 123456 @weakify(self); [[[_viewModel.someCommand executionSignals] flatten] subscribeNext:^(id x) { @strongify(self); // 跳转逻辑 [self.navigationController pushViewController:targetViewController animated:YES];}]; MVVM框架的目的除去解耦以外，还有2个很重要的目的： 代码复用率高 方便进行单元测试 如果需要测试一个业务是否正确，我们只要对ViewModel进行单元测试即可。前提是假定我们使用ReactiveCocoa进行UI绑定的过程是准确无误的。目前绑定是正确的。所以我们只需要单元测试到ViewModel即可完成业务逻辑的测试。 页面跳转也属于业务逻辑，所以应该放在ViewModel中一起单元测试，保证业务逻辑测试的覆盖率。 把页面跳转放到ViewModel中，有2种做法，第一种就是用路由来实现，第二种由于和路由没有关系，所以这里就不多阐述，有兴趣的可以看lpd-mvvm-kit这个库关于页面跳转的具体实现。 页面跳转相互的耦合性也就体现出来了： 由于pushViewController或者presentViewController，后面都需要带一个待操作的ViewController，那么就必须要引入该类，import头文件也就引入了耦合性。 由于跳转这里写死了跳转操作，如果线上一旦出现了bug，这里是不受我们控制的。 推送消息或者是3D-Touch需求，要求直接跳转到内部第10级界面，那么就需要写一个入口跳转到指定界面。 各个组件之间的相互调用 屏幕快照 2018-02-27 下午4.24.18 关于组件间的调用，也需要解耦。随着业务越来越复杂，我们封装的组件越来越多，要是封装的粒度拿捏不准，就会出现大量组件之间耦合度高的问题。组件的粒度可以随着业务的调整，不断的调整组件职责的划分。但是组件之间的调用依旧不可避免，相互调用对方组件暴露的接口。如何减少各个组件之间的耦合度，是一个设计优秀的路由的职责所在。 如何设计一个路由 方案调研 JLRoutes JLRoutes 使用 URL Scheme 的方式，将所有的资源看成是一个URL。 JLRoutes 将传入的 URL Scheme 按照上面的样子进行分割，并获取NSURLComponent JLRoutes全局会保存一个Map，这个Map会以scheme为Key，JLRoutes为Value。所以在routeControllerMap里面每个scheme都是唯一的。 在每个JLRoutes里面都保存了一个数组，这个数组里面保存了每个路由规则JLRRouteDefinition里面会保存外部传进来的block闭包，pattern，和拆分之后的pattern。 在每个JLRoutes的数组里面，会按照路由的优先级进行排列，优先级高的排列在前面。 123456789101112131415161718192021222324252627- (void)_registerRoute:(NSString *)routePattern priority:(NSUInteger)priority handler:(BOOL (^)(NSDictionary *parameters))handlerBlock{ JLRRouteDefinition *route = [[JLRRouteDefinition alloc] initWithScheme:self.scheme pattern:routePattern priority:priority handlerBlock:handlerBlock]; if (priority == 0 || self.routes.count == 0) { [self.routes addObject:route]; } else { NSUInteger index = 0; BOOL addedRoute = NO; // 找到当前已经存在的一条优先级比当前待插入的路由低的路由 for (JLRRouteDefinition *existingRoute in [self.routes copy]) { if (existingRoute.priority &lt; priority) { // 如果找到，就插入数组 [self.routes insertObject:route atIndex:index]; addedRoute = YES; break; } index++; } // 如果没有找到任何一条路由比当前待插入的路由低的路由，或者最后一条路由优先级和当前路由一样，那么就只能插入到最后。 if (!addedRoute) { [self.routes addObject:route]; } }} 由于这个数组里面的路由是一个单调队列，所以查找优先级的时候只用从高往低遍历即可。 具体查找路由的过程如下 首先根据外部传进来的URL初始化一个JLRRouteRequest，然后用这个JLRRouteRequest在当前的路由数组里面依次request，每个规则都会生成一个response，但是只有符合条件的response才会match，最后取出匹配的JLRRouteResponse拿出其字典parameters里面对应的参数就可以了。查找和匹配过程中重要的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859- (BOOL)_routeURL:(NSURL *)URL withParameters:(NSDictionary *)parameters executeRouteBlock:(BOOL)executeRouteBlock{ if (!URL) { return NO; } [self _verboseLog:@&quot;Trying to route URL %@&quot;, URL]; BOOL didRoute = NO; JLRRouteRequest *request = [[JLRRouteRequest alloc] initWithURL:URL]; for (JLRRouteDefinition *route in [self.routes copy]) { // 检查每一个route，生成对应的response JLRRouteResponse *response = [route routeResponseForRequest:request decodePlusSymbols:shouldDecodePlusSymbols]; if (!response.isMatch) { continue; } [self _verboseLog:@&quot;Successfully matched %@&quot;, route]; if (!executeRouteBlock) { // 如果我们被要求不允许执行，但是又找了匹配的路由response。 return YES; } // 装配最后的参数 NSMutableDictionary *finalParameters = [NSMutableDictionary dictionary]; [finalParameters addEntriesFromDictionary:response.parameters]; [finalParameters addEntriesFromDictionary:parameters]; [self _verboseLog:@&quot;Final parameters are %@&quot;, finalParameters]; didRoute = [route callHandlerBlockWithParameters:finalParameters]; if (didRoute) { // 调用Handler成功 break; } } if (!didRoute) { [self _verboseLog:@&quot;Could not find a matching route&quot;]; } // 如果在当前路由规则里面没有找到匹配的路由，当前路由不是global 的，并且允许降级到global里面去查找，那么我们继续在global的路由规则里面去查找。 if (!didRoute &amp;&amp; self.shouldFallbackToGlobalRoutes &amp;&amp; ![self _isGlobalRoutesController]) { [self _verboseLog:@&quot;Falling back to global routes...&quot;]; didRoute = [[JLRoutes globalRoutes] _routeURL:URL withParameters:parameters executeRouteBlock:executeRouteBlock]; } // 最后，依旧没有找到任何能匹配的，如果有unmatched URL handler，调用这个闭包进行最后的处理。if, after everything, we did not route anything and we have an unmatched URL handler, then call it if (!didRoute &amp;&amp; executeRouteBlock &amp;&amp; self.unmatchedURLHandler) { [self _verboseLog:@&quot;Falling back to the unmatched URL handler&quot;]; self.unmatchedURLHandler(self, URL, parameters); } return didRoute;} 举个例子 先注册一个Router，规则如下: 123456[[JLRoutes globalRoutes] addRoute:@&quot;/:object/:action&quot; handler:^BOOL(NSDictionary *parameters) { NSString *object = parameters[@&quot;object&quot;]; NSString *action = parameters[@&quot;action&quot;]; // stuff return YES;}]; 传入一个URL， 让 Route 处理 12NSURL *editPost = [NSURL URLWithString:@&quot;ele://post/halfrost?debug=true&amp;foo=bar&quot;]; [[UIApplication sharedApplication] openURL:editPost]; 匹配之后，得到如下的字典 123456789{ &quot;object&quot;: &quot;post&quot;, &quot;action&quot;: &quot;halfrost&quot;, &quot;debug&quot;: &quot;true&quot;, &quot;foo&quot;: &quot;bar&quot;, &quot;JLRouteURL&quot;: &quot;ele://post/halfrost?debug=true&amp;foo=bar&quot;, &quot;JLRoutePattern&quot;: &quot;/:object/:action&quot;, &quot;JLRouteScheme&quot;: &quot;JLRoutesGlobalRoutesScheme&quot;} 详细过程 JLRoutes还可以支持Optional的路由规则，假如定义一条路由规则： Swift/the(/foo/:a)(/bar/:b) JLRoutes 会帮我们默认注册如下4条路由规则： 1234/the/foo/:a/bar/:b/the/foo/:a/the/bar/:b/the routable-ios Routable路由是用在in-app native端的 URL router, 它可以用在iOS上也可以用在 Android UPRouter里面保存了2个字典。 routes字典里面存储的Key是路由规则，Value存储的是UPRouterOptions。 cachedRoutes里面存储的Key是最终的URL，带传参的，Value存储的是RouterParams。RouterParams里面会包含在routes匹配的到的UPRouterOptions，还有额外的打开参数openParams和一些额外参数extraParams。 这一段代码里面重点在干一件事情，遍历routes字典，然后找到参数匹配的字符串，封装成RouterParams返回。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (RouterParams *)routerParamsForUrl:(NSString *)url extraParams: (NSDictionary *)extraParams { if (!url) { //if we wait, caching this as key would throw an exception if (_ignoresExceptions) { return nil; } @throw [NSException exceptionWithName:@&quot;RouteNotFoundException&quot; reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url] userInfo:nil]; } if ([self.cachedRoutes objectForKey:url] &amp;&amp; !extraParams) { return [self.cachedRoutes objectForKey:url]; } // 比对url通过/分割之后的参数个数和pathComponents的个数是否一样 NSArray *givenParts = url.pathComponents; NSArray *legacyParts = [url componentsSeparatedByString:@&quot;/&quot;]; if ([legacyParts count] != [givenParts count]) { NSLog(@&quot;Routable Warning - your URL %@ has empty path components - this will throw an error in an upcoming release&quot;, url); givenParts = legacyParts; } __block RouterParams *openParams = nil; [self.routes enumerateKeysAndObjectsUsingBlock: ^(NSString *routerUrl, UPRouterOptions *routerOptions, BOOL *stop) { NSArray *routerParts = [routerUrl pathComponents]; if ([routerParts count] == [givenParts count]) { NSDictionary *givenParams = [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts]; if (givenParams) { openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams]; *stop = YES; } } }]; if (!openParams) { if (_ignoresExceptions) { return nil; } @throw [NSException exceptionWithName:@&quot;RouteNotFoundException&quot; reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url] userInfo:nil]; } [self.cachedRoutes setObject:openParams forKey:url]; return openParams;} 下面这段函数，第一个参数是外部传进来URL带有各个入参的分割数组。第二个参数是路由规则分割开的数组。routerComponent由于规定：号后面才是参数，所以routerComponent的第1个位置就是对应的参数名。params字典里面以参数名为Key，参数为Value。 123456789101112131415161718- (NSDictionary *)paramsForUrlComponents:(NSArray *)givenUrlComponents routerUrlComponents:(NSArray *)routerUrlComponents { __block NSMutableDictionary *params = [NSMutableDictionary dictionary]; [routerUrlComponents enumerateObjectsUsingBlock: ^(NSString *routerComponent, NSUInteger idx, BOOL *stop) { NSString *givenComponent = givenUrlComponents[idx]; if ([routerComponent hasPrefix:@&quot;:&quot;]) { NSString *key = [routerComponent substringFromIndex:1]; [params setObject:givenComponent forKey:key]; } else if (![routerComponent isEqualToString:givenComponent]) { params = nil; *stop = YES; } }]; return params;} 通过RouterParams的初始化方法，把路由规则对应的UPRouterOptions，上一步封装好的参数字典givenParams，还有 routerParamsForUrl: extraParams: 方法的第二个入参，这3个参数作为初始化参数，生成了一个RouterParams 12345 NSDictionary *givenParams = [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts];if (givenParams) { openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams]; *stop = YES;} 最后一步self.cachedRoutes的字典里面Key为带参数的URL，Value是RouterParams。 1[self.cachedRoutes setObject:openParams forKey:url]; 最后将匹配封装出来的RouterParams转换成对应的Controller。 123456789101112131415161718192021222324252627- (UIViewController *)controllerForRouterParams:(RouterParams *)params { SEL CONTROLLER_CLASS_SELECTOR = sel_registerName(&quot;allocWithRouterParams:&quot;); SEL CONTROLLER_SELECTOR = sel_registerName(&quot;initWithRouterParams:&quot;); UIViewController *controller = nil; Class controllerClass = params.routerOptions.openClass;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; if ([controllerClass respondsToSelector:CONTROLLER_CLASS_SELECTOR]) { controller = [controllerClass performSelector:CONTROLLER_CLASS_SELECTOR withObject:[params controllerParams]]; } else if ([params.routerOptions.openClass instancesRespondToSelector:CONTROLLER_SELECTOR]) { controller = [[params.routerOptions.openClass alloc] performSelector:CONTROLLER_SELECTOR withObject:[params controllerParams]]; }#pragma clang diagnostic pop if (!controller) { if (_ignoresExceptions) { return controller; } @throw [NSException exceptionWithName:@&quot;RoutableInitializerNotFound&quot; reason:[NSString stringWithFormat:INVALID_CONTROLLER_FORMAT, NSStringFromClass(controllerClass), NSStringFromSelector(CONTROLLER_CLASS_SELECTOR), NSStringFromSelector(CONTROLLER_SELECTOR)] userInfo:nil]; } controller.modalTransitionStyle = params.routerOptions.transitionStyle; controller.modalPresentationStyle = params.routerOptions.presentationStyle; return controller;} 如果Controller是一个类，那么就调用allocWithRouterParams:方法去初始化。如果Controller已经是一个实例了，那么就调用initWithRouterParams:方法去初始化。 将Routable的大致流程图解如下： HHRouter ViewController提供了2个方法。map是用来设置路由规则，matchController是用来匹配路由规则的，匹配争取之后返回对应的UIViewController。 12- (void)map:(NSString *)route toControllerClass:(Class)controllerClass;- (UIViewController *)matchController:(NSString *)route; block闭包提供了三个方法，map也是设置路由规则，matchBlock：是用来匹配路由，找到指定的block，但是不会调用该block。callBlock:是找到指定的block，找到以后就立即调用。 1234- (void)map:(NSString *)route toBlock:(HHRouterBlock)block;- (HHRouterBlock)matchBlock:(NSString *)route;- (id)callBlock:(NSString *)route; matchBlock:和callBlock:的区别就在于前者不会自动调用闭包。所以matchBlock:方法找到对应的block之后，如果想调用，需要手动调用一次。 除去上面这些方法，HHRouter还为我们提供了一个特殊的方法。 1- (HHRouteType)canRoute:(NSString *)route; 这个方法就是用来找到执行路由规则对应的RouteType，RouteType总共就3种: 12345typedef NS_ENUM (NSInteger, HHRouteType) { HHRouteTypeNone = 0, HHRouteTypeViewController = 1, HHRouteTypeBlock = 2}; 再来看看HHRouter是如何管理路由规则的。整个HHRouter就是由一个NSMutableDictionary *routes控制的。 123@interface HHRouter ()@property (strong, nonatomic) NSMutableDictionary *routes;@end 别看只有这一个看似“简单”的字典数据结构，但是HHRouter路由设计的还是很精妙的。 1234567891011- (void)map:(NSString *)route toBlock:(HHRouterBlock)block{ NSMutableDictionary *subRoutes = [self subRoutesToRoute:route]; subRoutes[@&quot;_&quot;] = [block copy];}- (void)map:(NSString *)route toControllerClass:(Class)controllerClass{ NSMutableDictionary *subRoutes = [self subRoutesToRoute:route]; subRoutes[@&quot;_&quot;] = controllerClass;} 上面两个方法分别是block闭包和ViewController设置路由规则调用的方法实体。不管是ViewController还是block闭包，设置规则的时候都会调用subRoutesToRoute:方法。 123456789101112131415161718- (NSMutableDictionary *)subRoutesToRoute:(NSString *)route{ NSArray *pathComponents = [self pathComponentsFromRoute:route]; NSInteger index = 0; NSMutableDictionary *subRoutes = self.routes; while (index &lt; pathComponents.count) { NSString *pathComponent = pathComponents[index]; if (![subRoutes objectForKey:pathComponent]) { subRoutes[pathComponent] = [[NSMutableDictionary alloc] init]; } subRoutes = subRoutes[pathComponent]; index++; } return subRoutes;} 上面这段函数就是来构造路由匹配规则的字典。 举个例子： 123456[[HHRouter shared] map:@&quot;/user/:userId/&quot; toControllerClass:[UserViewController class]];[[HHRouter shared] map:@&quot;/story/:storyId/&quot; toControllerClass:[StoryViewController class]];[[HHRouter shared] map:@&quot;/user/:userId/story/?a=0&quot; toControllerClass:[StoryListViewController class]]; 设置3条规则以后，按照上面构造路由匹配规则的字典的方法，该路由规则字典就会变成这个样子： 123456789101112131415{ story = { &quot;:storyId&quot; = { &quot;_&quot; = StoryViewController; }; }; user = { &quot;:userId&quot; = { &quot;_&quot; = UserViewController; story = { &quot;_&quot; = StoryListViewController; }; }; };} 路由规则字典生成之后，等到匹配的时候就会遍历这个字典。 假设这时候有一条路由过来： 1[[[HHRouter shared] matchController:@&quot;hhrouter20://user/1/&quot;] class], HHRouter对这条路由的处理方式是先匹配前面的scheme，如果连scheme都不正确的话，会直接导致后面匹配失败。 然后再进行路由匹配，最后生成的参数字典如下： 12345{ &quot;controller_class&quot; = UserViewController; route = &quot;/user/1/&quot;; userId = 1;} 具体的路由参数匹配的函数在 1- (NSDictionary *)paramsInRoute:(NSString *)route 个方法里面实现的。这个方法就是按照路由匹配规则，把传进来的URL的参数都一一解析出来，带？号的也都会解析成字典。这个方法没什么难度，就不在赘述了。 ViewController 的字典里面默认还会加上2项： 12&quot;controller_class&quot; = route = route里面都会保存传过来的完整的URL。 如果传进来的路由后面带访问字符串呢？那我们再来看看： 1[[HHRouter shared] matchController:@&quot;/user/1/?a=b&amp;c=d&quot;] 那么解析出所有的参数字典会是下面的样子： 1234567{ a = b; c = d; &quot;controller_class&quot; = UserViewController; route = &quot;/user/1/?a=b&amp;c=d&quot;; userId = 1;} 同理，如果是一个block闭包的情况呢？ 还是先添加一条block闭包的路由规则： 12[[HHRouter shared] map:@&quot;/user/add/&quot; toBlock:^id(NSDictionary* params) {}]; 这条规则对应的会生成一个路由规则的字典。 123456789101112131415161718{ story = { &quot;:storyId&quot; = { &quot;_&quot; = StoryViewController; }; }; user = { &quot;:userId&quot; = { &quot;_&quot; = UserViewController; story = { &quot;_&quot; = StoryListViewController; }; }; add = { &quot;_&quot; = &quot;&lt;__NSMallocBlock__: 0x600000240480&gt;&quot;; }; };} 注意”_”后面跟着是一个block。 匹配block闭包的方式有两种。 1234567// 1.第一种方式匹配到对应的block之后，还需要手动调用一次闭包。 HHRouterBlock block = [[HHRouter shared] matchBlock:@&quot;/user/add/?a=1&amp;b=2&quot;]; block(nil);// 2.第二种方式匹配block之后自动会调用改闭包。 [[HHRouter shared] callBlock:@&quot;/user/add/?a=1&amp;b=2&quot;]; 匹配出来的参数字典是如下： 123456{ a = 1; b = 2; block = &quot;&lt;__NSMallocBlock__: 0x600000056b90&gt;&quot;; route = &quot;/user/add/?a=1&amp;b=2&quot;;} block的字典里面会默认加上下面这2项： 12block = route = route里面都会保存传过来的完整的URL。 生成的参数字典最终会被绑定到ViewController的Associated Object关联对象上。 123456789- (void)setParams:(NSDictionary *)paramsDictionary{ objc_setAssociatedObject(self, &amp;kAssociatedParamsObjectKey, paramsDictionary, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (NSDictionary *)params{ return objc_getAssociatedObject(self, &amp;kAssociatedParamsObjectKey);} 这个绑定的过程是在match匹配完成的时候进行的。 12345678910111213- (UIViewController *)matchController:(NSString *)route{ NSDictionary *params = [self paramsInRoute:route]; Class controllerClass = params[@&quot;controller_class&quot;]; UIViewController *viewController = [[controllerClass alloc] init]; if ([viewController respondsToSelector:@selector(setParams:)]) { [viewController performSelector:@selector(setParams:) withObject:[params copy]]; } return viewController;} 最终得到的ViewController也是我们想要的。相应的参数都在它绑定的params属性的字典里面。 将上述过程图解出来，如下： MGJRouter JLRoutes 的问题主要在于查找 URL 的实现不够高效，通过遍历而不是匹配。还有就是功能偏多。 HHRouter 的 URL 查找是基于匹配，所以会更高效，MGJRouter 也是采用的这种方法，但它跟 ViewController 绑定地过于紧密，一定程度上降低了灵活性。 于是就有了 MGJRouter。 从数据结构来看，MGJRouter还是和HHRouter一模一样的 123@interface MGJRouter ()@property (nonatomic) NSMutableDictionary *routes;@end 那么我们就来看看它对HHRouter做了哪些优化改进。 1.MGJRouter支持openURL时，可以传一些 userinfo 过去 1[MGJRouter openURL:@&quot;mgj://category/travel&quot; withUserInfo:@{@&quot;user_id&quot;: @1900} completion:nil]; 这个对比HHRouter，仅仅只是写法上的一个语法糖，在HHRouter中虽然不支持带字典的参数，但是在URL后面可以用URL Query Parameter来弥补。 12345678910111213if (parameters) { MGJRouterHandler handler = parameters[@&quot;block&quot;]; if (completion) { parameters[MGJRouterParameterCompletion] = completion; } if (userInfo) { parameters[MGJRouterParameterUserInfo] = userInfo; } if (handler) { [parameters removeObjectForKey:@&quot;block&quot;]; handler(parameters); } } MGJRouter对userInfo的处理是直接把它封装到Key = MGJRouterParameterUserInfo对应的Value里面。 2.支持中文的URL。 12345[parameters enumerateKeysAndObjectsUsingBlock:^(id key, NSString *obj, BOOL *stop) { if ([obj isKindOfClass:[NSString class]]) { parameters[key] = [obj stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; } }]; 这里就是需要注意一下编码。 3.定义一个全局的 URL Pattern 作为 Fallback。 这一点是模仿的JLRoutes的匹配不到会自动降级到global的思想。 1234567if (parameters) { MGJRouterHandler handler = parameters[@&quot;block&quot;]; if (handler) { [parameters removeObjectForKey:@&quot;block&quot;]; handler(parameters); } } parameters字典里面会先存储下一个路由规则，存在block闭包中，在匹配的时候会取出这个handler，降级匹配到这个闭包中，进行最终的处理。 4.当 OpenURL 结束时，可以执行 Completion Block。 在MGJRouter里面，作者对原来的HHRouter字典里面存储的路由规则的结构进行了改造。 123NSString *const MGJRouterParameterURL = @&quot;MGJRouterParameterURL&quot;; NSString *const MGJRouterParameterCompletion = @&quot;MGJRouterParameterCompletion&quot;; NSString *const MGJRouterParameterUserInfo = @&quot;MGJRouterParameterUserInfo&quot;; 这3个key会分别保存一些信息： MGJRouterParameterURL保存的传进来的完整的URL信息。 MGJRouterParameterCompletion保存的是completion闭包。 MGJRouterParameterUserInfo保存的是UserInfo字典。 举个例子： 12345678910[MGJRouter registerURLPattern:@&quot;ele://name/:name&quot; toHandler:^(NSDictionary *routerParameters) { void (^completion)(NSString *) = routerParameters[MGJRouterParameterCompletion]; if (completion) { completion(@&quot;完成了&quot;); } }]; [MGJRouter openURL:@&quot;ele://name/halfrost/?age=20&quot; withUserInfo:@{@&quot;user_id&quot;: @1900} completion:^(id result) { NSLog(@&quot;result = %@&quot;,result); }]; 上面的URL会匹配成功，那么生成的参数字典结构如下： 12345678910{ MGJRouterParameterCompletion = &quot;&lt;__NSGlobalBlock__: 0x107ffe680&gt;&quot;; MGJRouterParameterURL = &quot;ele://name/halfrost/?age=20&quot;; MGJRouterParameterUserInfo = { &quot;user_id&quot; = 1900; }; age = 20; block = &quot;&lt;__NSMallocBlock__: 0x608000252120&gt;&quot;; name = halfrost;} 5.可以统一管理URL 这个功能非常有用。 URL 的处理一不小心，就容易散落在项目的各个角落，不容易管理。比如注册时的 pattern 是 mgj://beauty/:id，然后 open 时就是 mgj://beauty/123，这样到时候 url 有改动，处理起来就会很麻烦，不好统一管理。 所以 MGJRouter 提供了一个类方法来处理这个问题。 12345678#define TEMPLATE_URL @&quot;qq://name/:name&quot;[MGJRouter registerURLPattern:TEMPLATE_URL toHandler:^(NSDictionary *routerParameters) { NSLog(@&quot;routerParameters[name]:%@&quot;, routerParameters[@&quot;name&quot;]); // halfrost}];[MGJRouter openURL:[MGJRouter generateURLWithPattern:TEMPLATE_URL parameters:@[@&quot;halfrost&quot;]]];} generateURLWithPattern:函数会对我们定义的宏里面的所有的:进行替换，替换成后面的字符串数组，依次赋值。 将上述过程图解出来，如下： 蘑菇街为了区分开页面间调用和组件间调用，于是想出了一种新的方法。用Protocol的方法来进行组件间的调用。 每个组件之间都有一个 Entry，这个 Entry，主要做了三件事： 注册这个组件关心的 URL 注册这个组件能够被调用的方法/属性 在 App 生命周期的不同阶段做不同的响应 页面间的openURL调用就是如下的样子： 每个组件间都会向MGJRouter注册，组件间相互调用或者是其他的App都可以通过openURL:方法打开一个界面或者调用一个组件。 在组件间的调用，蘑菇街采用了Protocol的方式。 [ModuleManager registerClass:ClassA forProtocol:ProtocolA] 的结果就是在 MM 内部维护的 dict 里新加了一个映射关系。 [ModuleManager classForProtocol:ProtocolA] 的返回结果就是之前在 MM 内部 dict 里 protocol 对应的 class，使用方不需要关心这个 class 是个什么东东，反正实现了 ProtocolA 协议，拿来用就行。 这里需要有一个公共的地方来容纳这些 public protocl，也就是图中的 PublicProtocl.h。 我猜测，大概实现可能是下面的样子： 123456@interface ModuleProtocolManager : NSObject+ (void)registServiceProvide:(id)provide forProtocol:(Protocol*)protocol;+ (id)serviceProvideForProtocol:(Protocol *)protocol;@end 然后这是一个单例，在这里注册各个协议 12345678910111213141516171819202122232425262728293031323334353637@interface ModuleProtocolManager ()@property (nonatomic, strong) NSMutableDictionary *serviceProvideSource;@end@implementation ModuleProtocolManager+ (ModuleProtocolManager *)sharedInstance{ static ModuleProtocolManager * instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ instance = [[self alloc] init]; }); return instance;}- (instancetype)init{ self = [super init]; if (self) { _serviceProvideSource = [[NSMutableDictionary alloc] init]; } return self;}+ (void)registServiceProvide:(id)provide forProtocol:(Protocol*)protocol{ if (provide == nil || protocol == nil) return; [[self sharedInstance].serviceProvideSource setObject:provide forKey:NSStringFromProtocol(protocol)];}+ (id)serviceProvideForProtocol:(Protocol *)protocol{ return [[self sharedInstance].serviceProvideSource objectForKey:NSStringFromProtocol(protocol)];} 在ModuleProtocolManager中用一个字典保存每个注册的protocol。现在再来猜猜ModuleEntry的实现。 12345678#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@protocol DetailModuleEntryProtocol &lt;NSObject&gt;@required;- (UIViewController *)detailViewControllerWithId:(NSString*)Id Name:(NSString *)name;@end 然后每个模块内都有一个和暴露到外面的协议相连接的“接头”。 1234#import &lt;Foundation/Foundation.h&gt;@interface DetailModuleEntry : NSObject@end 在它的实现中，需要引入3个外部文件，一个是ModuleProtocolManager，一个是DetailModuleEntryProtocol，最后一个是所在模块需要跳转或者调用的组件或者页面。 123456789101112131415161718192021222324#import &quot;DetailModuleEntry.h&quot;#import &lt;DetailModuleEntryProtocol/DetailModuleEntryProtocol.h&gt;#import &lt;ModuleProtocolManager/ModuleProtocolManager.h&gt;#import &quot;DetailViewController.h&quot;@interface DetailModuleEntry()&lt;DetailModuleEntryProtocol&gt;@end@implementation DetailModuleEntry+ (void)load{ [ModuleProtocolManager registServiceProvide:[[self alloc] init] forProtocol:@protocol(DetailModuleEntryProtocol)];}- (UIViewController *)detailViewControllerWithId:(NSString*)Id Name:(NSString *)name{ DetailViewController *detailVC = [[DetailViewController alloc] initWithId:id Name:name]; return detailVC;}@end 至此基于Protocol的方案就完成了。如果需要调用某个组件或者跳转某个页面，只要先从ModuleProtocolManager的字典里面根据对应的ModuleEntryProtocol找到对应的DetailModuleEntry，找到了DetailModuleEntry就是找到了组件或者页面的“入口”了。再把参数传进去即可。 1234567- (void)didClickDetailButton:(UIButton *)button{ id&lt; DetailModuleEntryProtocol &gt; DetailModuleEntry = [ModuleProtocolManager serviceProvideForProtocol:@protocol(DetailModuleEntryProtocol)]; UIViewController *detailVC = [DetailModuleEntry detailViewControllerWithId:@“详情界面” Name:@“我的购物车”]; [self.navigationController pushViewController:detailVC animated:YES];} 这样就可以调用到组件或者界面了。 如果组件之间有相同的接口，那么还可以进一步的把这些接口都抽离出来。这些抽离出来的接口变成“元接口”，它们是可以足够支撑起整个组件一层的。 CTMediator 这方案是基于Mediator的。 传统的中间人Mediator的模式是这样的 这种模式每个页面或者组件都会依赖中间者，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator还是会依赖其他组件。那么这是最终方案了么？ 主要思想是利用了Target-Action简单粗暴的思想，利用Runtime解决解耦的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget{ NSString *targetClassString = [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName]; NSString *actionString = [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName]; Class targetClass; NSObject *target = self.cachedTarget[targetClassString]; if (target == nil) { targetClass = NSClassFromString(targetClassString); target = [[targetClass alloc] init]; } SEL action = NSSelectorFromString(actionString); if (target == nil) { // 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的 return nil; } if (shouldCacheTarget) { self.cachedTarget[targetClassString] = target; } if ([target respondsToSelector:action]) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [target performSelector:action withObject:params];#pragma clang diagnostic pop } else { // 有可能target是Swift对象 actionString = [NSString stringWithFormat:@&quot;Action_%@WithParams:&quot;, actionName]; action = NSSelectorFromString(actionString); if ([target respondsToSelector:action]) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [target performSelector:action withObject:params];#pragma clang diagnostic pop } else { // 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理 SEL action = NSSelectorFromString(@&quot;notFound:&quot;); if ([target respondsToSelector:action]) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [target performSelector:action withObject:params];#pragma clang diagnostic pop } else { // 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。 [self.cachedTarget removeObjectForKey:targetClassString]; return nil; } } }} targetName就是调用接口的Object，actionName就是调用方法的SEL，params是参数，shouldCacheTarget代表是否需要缓存，如果需要缓存就把target存起来，Key是targetClassString，Value是target。 通过这种方式进行改造的，外面调用的方法都很统一，都是调用performTarget: action: params: shouldCacheTarget:。第三个参数是一个字典，这个字典里面可以传很多参数，只要Key-Value写好就可以了。处理错误的方式也统一在一个地方了，target没有，或者是target无法响应相应的方法，都可以在Mediator这里进行统一出错处理。 但是在实际开发过程中，不管是界面调用，组件间调用，在Mediator中需要定义很多方法。于是作者又想出了建议我们用Category的方法，对Mediator的所有方法进行拆分，这样就就可以不会导致Mediator这个类过于庞大了。 123456789101112131415161718192021222324252627282930313233- (UIViewController *)CTMediator_viewControllerForDetail{ UIViewController *viewController = [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativFetchDetailViewController params:@{@&quot;key&quot;:@&quot;value&quot;} shouldCacheTarget:NO ]; if ([viewController isKindOfClass:[UIViewController class]]) { // view controller 交付出去之后，可以由外界选择是push还是present return viewController; } else { // 这里处理异常场景，具体如何处理取决于产品 return [[UIViewController alloc] init]; }}- (void)CTMediator_presentImage:(UIImage *)image{ if (image) { [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativePresentImage params:@{@&quot;image&quot;:image} shouldCacheTarget:NO]; } else { // 这里处理image为nil的场景，如何处理取决于产品 [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativeNoImage params:@{@&quot;image&quot;:[UIImage imageNamed:@&quot;noImage&quot;]} shouldCacheTarget:NO]; }} 把这些具体的方法一个个的都写在Category里面就好了，调用的方式都非常的一致，都是调用performTarget: action: params: shouldCacheTarget:方法。 最终去掉了中间者Mediator对组件的依赖，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator不依赖其他任何组件。 没有开源的解决方案 Uber在发现MVC的一些弊端之后：比如动辄上万行巨胖无比的VC，无法进行单元测试等缺点后，于是考虑把架构换成VIPER。但是VIPER也有一定的弊端。因为它的iOS特定的结构，意味着iOS必须为Android做出一些妥协的权衡。以视图为驱动的应用程序逻辑，代表应用程序状态由视图驱动，整个应用程序都锁定在视图树上。由操作应用程序状态所关联的业务逻辑的改变，就必须经过Presenter。因此会暴露业务逻辑。最终导致了视图树和业务树进行了紧紧的耦合。这样想实现一个紧紧只有业务逻辑的Node节点或者紧紧只有视图逻辑的Node节点就非常的困难了。 通过改进VIPER架构，吸收其优秀的特点，改进其缺点，就形成了Uber 骑手App的全新架构——Riblets(肋骨)。 在这个新的架构中，即使是相似的逻辑也会被区分成很小很小，相互独立，可以单独进行测试的组件。每个组件都有非常明确的用途。使用这些一小块一小块的Riblets(肋骨)，最终把整个App拼接成一颗Riblets(肋骨)树。 通过抽象，一个Riblets(肋骨)被定义成一下6个更小的组件，这些组件各自有各自的职责。通过一个Riblets(肋骨)进一步的抽象业务逻辑和视图逻辑 一个Riblets(肋骨)被设计成这样，那和之前的VIPER和MVC有什么区别呢？最大的区别在路由上面。 Riblets(肋骨)内的Router不再是视图逻辑驱动的，现在变成了业务逻辑驱动。这一重大改变就导致了整个App不再是由表现形式驱动，现在变成了由数据流驱动。 每一个Riblet都是由一个路由Router，一个关联器Interactor，一个构造器Builder和它们相关的组件构成的。所以它的命名（Router - Interactor - Builder，Rib）也由此得来。当然还可以有可选的展示器Presenter和视图View。路由Router和关联器Interactor处理业务逻辑，展示器Presenter和视图View处理视图逻辑。 重点分析一下Riblet里面路由的职责。 路由职责 在整个App的结构树中，路由的职责是用来关联和取消关联其他子Riblet的。至于决定是由关联器Interactor传递过来的。在状态转换过程中，关联和取消关联子Riblet的时候，路由也会影响到关联器Interactor的生命周期。路由只包含2个业务逻辑： 1.提供关联和取消关联其他路由的方法。 2.在多个孩子之间决定最终状态的状态转换逻辑 拼装 每一个Riblets只有一对Router路由和Interactor关联器。但是它们可以有多对视图。Riblets只处理业务逻辑，不处理视图相关的部分。Riblets可以拥有单一的视图（一个Presenter展示器和一个View视图），也可以拥有多个视图（一个Presenter展示器和多个View视图，或者多个Presenter展示器和多个View视图），甚至也可以能没有视图（没有Presenter展示器也没有View视图）。这种设计可以有助于业务逻辑树的构建，也可以和视图树做到很好的分离。 举个例子，骑手的Riblet是一个没有视图的Riblet，它用来检查当前用户是否有一个激活的路线。如果骑手确定了路线，那么这个Riblet就会关联到路线的Riblet上面。路线的Riblet会在地图上显示出路线图。如果没有确定路线，骑手的Riblet就会被关联到请求的Riblet上。请求的Riblet会在屏幕上显示等待被呼叫。像骑手的Riblet这样没有任何视图逻辑的Riblet，它分开了业务逻辑，在驱动App和支撑模块化架构起了重大作用。 在这个新的架构中，数据流动是单向的。Data数据流从service服务流到Model Stream生成Model流。Model流再从Model Stream流动到Interactor关联器。Interactor关联器，scheduler调度器，远程推送都可以想Service触发变化来引起Model Stream的改动。Model Stream生成不可改动的models。这个强制的要求就导致关联器只能通过Service层改变App的状态。 举两个例子： 数据从后台到视图View上 一个状态的改变，引起服务器后台触发推送到App。数据就被Push到App，然后生成不可变的数据流。关联器收到model之后，把它传递给展示器Presenter。展示器Presenter把model转换成view model传递给视图View。 数据从视图到服务器后台 当用户点击了一个按钮，比如登录按钮。视图View就会触发UI事件传递给展示器Presenter。展示器Presenter调用关联器Interactor登录方法。关联器Interactor又会调用Service call的实际登录方法。请求网络之后会把数据pull到后台服务器。 Riblet间的数据流 当一个关联器Interactor在处理业务逻辑的工程中，需要调用其他Riblet的事件的时候，关联器Interactor需要和子关联器Interactor进行关联。见上图5个步骤。 如果调用方法是从子调用父类，父类的Interactor的接口通常被定义成监听者listener。如果调用方法是从父类调用到子类，那么子类的接口通常是一个delegate，实现父类的一些Protocol。 在Riblet的方案中，路由Router仅仅只是用来维护一个树型关系，而关联器Interactor才担当的是用来决定触发组件间的逻辑跳转的角色。 各个方案对比 APP间跳转 URL Scheme方式 Universal Link方式 APP内路由跳转 URLRoute注册 Protocol-Class 注册 Target-Action 经过上面的分析，可以发现，路由的设计思路是从URLRoute -&gt;Protocol-class -&gt;Target-Action一步步的深入的过程。这也是逐渐深入本质的过程。 1. URLRoute注册方案的优缺点 首先URLRoute也许是借鉴前端Router和系统App内跳转的方式想出来的方法。它通过URL来请求资源。不管是H5，RN，Weex，iOS界面或者组件请求资源的方式就都统一了。URL里面也会带上参数，这样调用什么界面或者组件都可以。所以这种方式是最容易，也是最先可以想到的。 URLRoute的优点很多，最大的优点就是服务器可以动态的控制页面跳转，可以统一处理页面出问题之后的错误处理，可以统一三端，iOS，Android，H5 / RN / Weex 的请求方式。 但是这种方式也需要看不同公司的需求。如果公司里面已经完成了服务器端动态下发的脚手架工具，前端也完成了Native端如果出现错误了，可以随时替换相同业务界面的需求，那么这个时候可能选择URLRoute的几率会更大。 但是如果公司里面H5没有做相关出现问题后能替换的界面，H5开发人员觉得这是给他们增添负担。如果公司也没有完成服务器动态下发路由规则的那套系统，那么公司可能就不会采用URLRoute的方式。因为URLRoute带来的少量动态性，公司是可以用JSPatch来做到。线上出现bug了，可以立即用JSPatch修掉，而不采用URLRoute去做。 所以选择URLRoute这种方案，也要看公司的发展情况和人员分配，技术选型方面。 URLRoute方案也是存在一些缺点的，首先URL的map规则是需要注册的，它们会在load方法里面写。写在load方法里面是会影响App启动速度的。 其次是大量的硬编码。URL链接里面关于组件和页面的名字都是硬编码，参数也都是硬编码。而且每个URL参数字段都必须要一个文档进行维护，这个对于业务开发人员也是一个负担。而且URL短连接散落在整个App四处，维护起来实在有点麻烦，虽然蘑菇街想到了用宏统一管理这些链接，但是还是解决不了硬编码的问题。 真正一个好的路由是在无形当中服务整个App的，是一个无感知的过程，从这一点来说，略有点缺失。 最后一个缺点是，对于传递NSObject的参数，URL是不够友好的，它最多是传递一个字典。 2. Protocol-Class注册方案的优缺点 Protocol-Class方案的优点，这个方案没有硬编码。 Protocol-Class方案也是存在一些缺点的，每个Protocol都要向ModuleManager进行注册。 这种方案ModuleEntry是同时需要依赖ModuleManager和组件里面的页面或者组件两者的。当然ModuleEntry也是会依赖ModuleEntryProtocol的，但是这个依赖是可以去掉的，比如用Runtime的方法NSProtocolFromString，加上硬编码是可以去掉对Protocol的依赖的。但是考虑到硬编码的方式对出现bug，后期维护都是不友好的，所以对Protocol的依赖还是不要去除。 最后一个缺点是组件方法的调用是分散在各处的，没有统一的入口，也就没法做组件不存在时或者出现错误时的统一处理。 3. Target-Action方案的优缺点 Target-Action方案的优点，充分的利用Runtime的特性，无需注册这一步。Target-Action方案只有存在组件依赖Mediator这一层依赖关系。在Mediator中维护针对Mediator的Category，每个category对应一个Target，Categroy中的方法对应Action场景。Target-Action方案也统一了所有组件间调用入口。 Target-Action方案也能有一定的安全保证，它对url中进行Native前缀进行验证。 Target-Action方案的缺点，Target_Action在Category中将常规参数打包成字典，在Target处再把字典拆包成常规参数，这就造成了一部分的硬编码。","link":"/source/back/%E8%B7%AF%E7%94%B1.html"},{"title":"标签","text":"","link":"/source/tags/index.html"}],"posts":[{"title":"AddTwoNumber","text":"题目 AddTwoNumbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 解题报告 理解题意 2 个 非空链表，长度可能不相等 每个链表为逆序 返回两个链表的和 每个元素应该为正数 理解例子 2 -&gt; 4 -&gt; 3 = 342 5 -&gt; 6 -&gt; 4 = 465 342 + 465 = 807 答案 : 7 -&gt; 0 -&gt; 8 思路 将每一个链表变成整形，然后相加，结果分解成链表不大合适，还得处理越界的情况 比较合理的办法：是一边遍历一边生成链表 每一个生成的节点为两个数的和，有可能产生进位: 如 7+8=15 一个节点的结果为：sum = 前一个节点的进位+两个节点的和，res = sum % 10; 一个节点的结果几种情况 last_carry + left + right &lt; 10 last_carry + left + right &gt;= 10 只要有进位，就一定会有一个新的节点出现 代码 非递归 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { if (!l1) return l2; if (!l2) return l1; int carry = 0; ListNode dummy(0); ListNode *head = &amp;dummy; while (l1 || l2 || carry) { int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + carry; head-&gt;next = new ListNode (sum % 10); head = head-&gt;next; carry = sum / 10; if (l1) l1 = l1-&gt;next; if (l2) l2 = l2-&gt;next; } return dummy.next; }}; 12345678910111213141516171819202122232425262728293031public class ListNode { public var val: Int public var next: ListNode? public init(_ val: Int) { self.val = val self.next = nil }}class Solution { func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? { var l1 = l1 var l2 = l2 var prev = ListNode(0) var carry = 0 let head = prev while l1 != nil || l2 != nil || carry != 0 { let cur = ListNode(0) let sum = (l2 == nil ? 0 : l2!.val) + (l1 == nil ? 0 : l1!.val) + carry cur.val = sum % 10 carry = sum / 10 prev.next = cur prev = cur l1 = l1 == nil ? l1: l1?.next l2 = l2 == nil ? l2: l2?.next } return head.next }} 递归 这道题比较简单，递归模式也比较好想到 加法需要三个值，两个操作符（来自两个链表）以及一个进位标记。 因此递归模式为： 递归出口：两个链表都已经到达末尾，并且没有进位 递归实现： 当前节点的结果为：和/10 当前节点的next节点为：对于两个链表next节点的计算的结果 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {private: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2, int carry) { if (!l1 &amp;&amp; !l2 &amp;&amp; !carry) return nullptr; int sum = (l1?l1-&gt;val:0) + (l2?l2-&gt;val:0) + carry; ListNode *ans = new ListNode(sum % 10); ans-&gt;next = addTwoNumbers(l1?l1-&gt;next:nullptr, l2?l2-&gt;next:nullptr, sum / 10); return ans; }public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { return addTwoNumbers(l1, l2, 0); }}; 时间复杂度 遍历次数：max(len(l1), len(l2)) + 1，因此是线性时间 \\(\\) 空间复杂度 额外申请了和一个链表，因此空间复杂度也为 \\(\\)","link":"/2019/11/22/AddTwoNumber/"},{"title":"Basic Calculator","text":"题目 Basic Calculator Implement a basic calculator to evaluate a simple expression string. The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces . Example 1: 12Input: &quot;1 + 1&quot;Output: 2 Example 2: 12Input: &quot; 2-1 + 2 &quot;Output: 3 Example 3: 12Input: &quot;(1+(4+5+2)-3)+(6+8)&quot;Output: 23 Note: You may assume that the given expression is always valid. Do not use the eval built-in library function. 解题报告 思路 看到这种模式肯定要用到栈 stack 会有括号的处理，这块可能会复杂点，因为有可能会导致计算优先级改变。 说白了就是将整个过程看为求和，每个数分配一个操作符，用来求和 分析例子可以知道 &gt; * 每一个数字都会消耗掉一个符号(+、-) &gt; 每一个数字都会产生一个新的符号(+, -) &gt; 每一个 ( 都会复制当前的符号，这样的话他就能给该操作范围内的第一个数用， &gt; * 每一个 ) 都会关闭当前的操作范围，因此会丢弃掉当前的符号 代码 123456789101112131415161718192021222324class Solution{public: int calculate(string s) { int ans = 0; // 2 sign vector&lt;int&gt; sign(2, 1); for (int i = 0; i &lt; s.length();i++) { char c = s[i]; if (isdigit(c)) { int n = 0; while (i &lt; s.size() &amp;&amp; isdigit(s[i])) n = n * 10 + (s[i++] - '0'); ans += sign.back() * n; sign.pop_back(); i--; } else if (c == '(') { sign.pop_back(); } else if (c == ' ') { sign.push_back(sign.back() * (c == '-' ? -1 : 1)); } } return ans; }}; 例子 12345678910111213 remaining sign stack total3-(2+(9-4)) [1, 1] 0 -(2+(9-4)) [1] 3 (2+(9-4)) [1, -1] 3 2+(9-4)) [1, -1, -1] 3 +(9-4)) [1, -1] 1 (9-4)) [1, -1, -1] 1 9-4)) [1, -1, -1, -1] 1 -4)) [1, -1, -1] -8 4)) [1, -1, -1, 1] -8 )) [1, -1, -1] -4 ) [1, -1] -4 [1] -4 另一种解法 思路 括号内优先计算 碰到 ( ,将计算结果和操作符入栈 碰到数字就带着符号计算结果。 代码 1234567891011121314151617181920212223242526272829class Solution {public: int calculate(string s) { const int l = s.length(); int sign = 1, ans = 0; stack&lt;int&gt; stk_; for (int i = 0; i &lt; l; i++) { char c = s[i]; if (isdigit(c)) { int d = c - '0'; while (i+1 &lt; l &amp;&amp; isdigit(s[i+1])) { d = d * 10 + (s[++i] - '0'); } ans += d * sign; } else if (c == '+' || c == '-') { sign = c == '+' ? 1 : -1; } else if (c == '(') { stk_.push(ans); stk_.push(sign); ans = 0; sign = 1; } else if (c == ')') { ans *= stk_.top(); stk_.pop(); ans += stk_.top(); stk_.pop(); } } return ans; }};","link":"/2020/06/12/BasicCalculator/"},{"title":"BinaryTree","text":"二叉树总结 123456struct TreeNode{ int value; TreeNode *left; TreeNode *right TreeNode(int v): value(v),left(nullptr), right(nullptr) {}}; 遍历二叉树 前序遍历 递归 1234567891011121314class Solution{public: vector&lt;int&gt;preOrderTraversal(TreeNode* tree) { vector&lt;int&gt; ans; function&lt;void(TreeNode *)&gt; preOrderTraversalHelper = [&amp;](TreeNode *node){ if (!node) return; ans.push_back(node-&gt;val); preOrderTraversalHelper(node-&gt;left); preOrderTraversalHelper(node-&gt;right) }; preOrderTraversalHelper(tree); return ans; }}; 非递归 12345678910111213141516171819class Solution{public: vector&lt;int&gt;preOrderTraversal(TreeNode *node){ if (!node) return {}; vector&lt;int&gt; ans; stack&lt;TreeNode *&gt; stk_; stk_.push(node); while (!stk_.empty()) { TreeNode *root = stk_.top(); stk_.pop(); ans.(root-&gt;value); if (root-&gt;right) stk_.push(root-&gt;right); if (root-&gt;left) stk_.push(root-&gt;left); } return ans; }push_back}; 12345678910111213141516171819202122232425262728class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; nums; TreeNode* cur = nullptr; while (root) { if (root-&gt;right) { cur = root-&gt;right; while (cur-&gt;left &amp;&amp; cur-&gt;left != root) { cur = cur-&gt;left; } if (cur-&gt;left == root) { cur-&gt;left = nullptr; root = root-&gt;left; } else { nums.push_back(root-&gt;val); cur-&gt;left = root; root = root-&gt;right; } } else { nums.push_back(root-&gt;val); root = root-&gt;left; } } return nums; }} 中序遍历 递归 1234567891011121314class Solution {public: vector&lt;int&gt; inOrderTraversal(TreeNode *node) { vector&lt;int&gt; ans; function&lt;void(TreeNode *)&gt; inOrderTraversalHelper = [&amp;](TreeNode * root){ if (!root) return; inOrderTraversalHelper(root-&gt;left) ans.push_back(root-&gt;val); inOrderTraversalHelper(root-&gt;right); }; inOrderTraversalHelper(root); return ans; }}; 非递归 123456789101112131415161718class Solution{public: vector&lt;int&gt;inOrderTraversal(TreeNode *root){ if (!root) return {}; vector&lt;int&gt; ans; stack&lt;TreeNode *&gt; stk_; while (root || !stk_.empty()) { while (root) { stk_.push(root); root = root-&gt;left; } root = stk_.top(); stk_.pop(); ans.push_back(root-&gt;value); root = root-&gt;right; } return ans; }}; 后序遍历 递归 1234567891011121314class Solution {public: vector&lt;int&gt; postOrderTraversal(TreeNode *node) { vector&lt;int&gt; ans; function&lt;void(TreeNode *)&gt;postOrderTraversalHelper = [&amp;](TreeNode *root){ if (!root) return; postOrderTraversal(root-&gt;left); postOrderTraversal(root-&gt;right); ans.push_back(root); }; postOrderTraversal(node); return ans; }}; 非递归 &gt; two stack 123456789101112131415161718192021class Solution {public: vector&lt;int&gt; postOrderTraversal(TreeNode *root){ if (!root) return {}; stack&lt;TreeNode *&gt; stk_, _stk; stk_.push(root); TreeNode *node = nullptr; while (!stk_.empty()) { node = stk_.top();stk_.pop(); _stk.push(node); if (node-&gt;left) stk_.push(node-&gt;left); if (node-&gt;right) stk_.push(node-&gt;right); } while (!_stk.empty()) { ans.push_back(_stk.top()); _stk.pop(); } }}; one stack, 需要记录上一个输出的节点的指针， 12345678910111213141516171819202122232425class Solution {public: vector&lt;int&gt; postOrderTraversal(TreeNode *root) { if (!root) return {}; vector&lt;int&gt; ans; stack&lt;TreeNode *&gt;stk_; TreeNode *last = nullptr; while (root || !stk_.empty()) { if (root) { stk_.push(root); root = root-&gt;left; } else { TreeNode *node = stk_.top(); if (node-&gt;right &amp;&amp; last != node-&gt;right) { root = node-&gt;right; } else { ans.push_back(node-&gt;value); last = node; stk_.pop(); } } } return ans; }}; Morris Traversal O(n) time O(1) space 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Solution {public: vector&lt;int&gt; postorderTraversal(TreeNode* root) { vector&lt;int&gt; nodes; TreeNode* dummy = new TreeNode(0); dummy -&gt; left = root; TreeNode* cur = dummy; while (cur) { if (cur -&gt; left) { TreeNode* pre = cur -&gt; left; while (pre -&gt; right &amp;&amp; (pre -&gt; right != cur)) { pre = pre -&gt; right; } if (!(pre -&gt; right)) { pre -&gt; right = cur; cur = cur -&gt; left; } else { reverseAddNodes(cur -&gt; left, pre, nodes); pre -&gt; right = NULL; cur = cur -&gt; right; } } else { cur = cur -&gt; right; } } return nodes; }private: void reverseNodes(TreeNode* start, TreeNode* end) { if (start == end) { return; } TreeNode* x = start; TreeNode* y = start -&gt; right; TreeNode* z; while (x != end) { z = y -&gt; right; y -&gt; right = x; x = y; y = z; } } void reverseAddNodes(TreeNode* start, TreeNode* end, vector&lt;int&gt;&amp; nodes) { reverseNodes(start, end); TreeNode* node = end; while (true) { nodes.push_back(node -&gt; val); if (node == start) { break; } node = node -&gt; right; } reverseNodes(end, start); }};","link":"/2020/06/29/BinaryTree/"},{"title":"位操作","text":"位操作总结 基本上位操作就那么几个: 异或的特性 123456789x ^ 0 = xx ^ 11111……1111 = ~xx ^ (~x) = 11111……1111x ^ x = 0a ^ b = c =&gt; a ^ c = b =&gt; b ^ c = a (交换律) a ^ b ^ c = a ^ (b ^ c) = (a ^ b）^ c (结合律) 构造特殊的Mask 将 x 最右边的 n 位清零， x &amp; ( ~0 &lt;&lt; n ) 获取 x 的第 n 位值(0 或者 1)，(x &gt;&gt; n) &amp; 1 获取 x 的第 n 位的幂值，x &amp; (1 &lt;&lt; (n - 1)) 仅将第 n 位置为 1，x | (1 &lt;&lt; n) 仅将第 n 位置为 0，x &amp; (~(1 &lt;&lt; n)) 将 x 最⾼位⾄第 n 位(含)清零，x &amp; ((1 &lt;&lt; n) - 1) 将第 n 位⾄第 0 位(含)清零，x &amp; (~((1 &lt;&lt; (n + 1)) - 1) X &amp; 1 == 1 判断是否是奇数(偶数) X &amp; = (X - 1) 将最低位(LSB)的 1 清零 X &amp; -X 得到最低位(LSB)的 1 X &amp; ~X = 0","link":"/2020/08/11/BitManupulate/"},{"title":"Best Time To Buy Sell Stock IV","text":"题目 Best Time to Buy and Sell Stock IV Say you have an array for which the i-th element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most k transactions. Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). Example 1: 123Input: [2,4,1], k = 2Output: 2Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2. Example 2: 1234Input: [3,2,6,5,0,3], k = 2Output: 7Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3. 解题报告 思路 获取收益肯定应该在地点买入，高点卖出，假定 vally 表示低价格的索引，peak 表示高价格的索引，因此 (v1, p1) 和 (v2, p2) 表示两个连续的 valley-peak 的价格。考虑如下两个 case *prices[v1] &lt;= prices[v2] &amp;&amp; prices[p1] &lt;= prices[p2]，在该条件下，如果只能交易一次，那就是(v1, p2)。 如果是两个交易，那就是(v1, p1) 和 (v2, p2)。为了省事，将(v1, p2)看做为第一个交易，(v2, p1) 看做第二个交易. prices[v1] &gt;= prices[v2] || prices[p1] &gt;= prices[p2]，在该条件下，如果只能交易一次，要么就用(v1,p1)，要么就用 (v2,p2)。如果是两次交易，就全部使用。 步骤 找到全部的交易，并且记录每一笔的收益，使用 stack 记录每一对 vally-peak 。并且保证 vally 是按照升序排列。所有的收益都放在 vector 数组中，时间复杂度为 O(n). 找到前 k 个交易收益，时间复杂度为 O(n) 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Solution{public: int maxProfit(int k, vector&lt;int&gt;&amp; prices){ const int m = prices.size(); vector&lt;int&gt; profits; stack&lt;pair&lt;int,int&gt;&gt; vps; // vally-peak pairs int v = 0, p = -1; // padding p , so not using p-1 while (true) { // find next vally and peak for (v = p+1; v+1 &lt; m &amp;&amp; (prices[v] &gt;= prices[v+1]); v++); for (p = v; p+1 &lt; m &amp;&amp; (prices[p] &gt;= prices[p-1]); p++); if (v == p) break; // to the end of prices // v &lt; p // (v1,p1) (v2,p2) // if (prices[v1] &gt;= prices[v2]) no need to combine two transactions // after å top is (v1,p2), push p2-v1 into profit --&gt; step ∑ while (!vps.empty() &amp;&amp; (prices[v] &lt;= prics[vps.top().first])) { profits.push_back(prices[vps.top().second] - prices[vps.top().first]); vps.pop(); } // (v1, p1) (v2,p2) // if (prices[v1] &lt; prices[v2] &amp;&amp; prices[p1] &lt; prices[p2]) we need to combine two transactions // update (v1,p1) --&gt; (v1, p2) // p2-v2 + p1-v1 == p2-v1 + p1-v2 // after step ∑ top is (v1, p2) while (!vps.empty() &amp;&amp; (prices[p] &gt;= prices[vps.top().second])) { // save profit (v2, p1) profits.push_back(prices[vps.top().second] - prices[v]); // v1 --&gt; v v = vps.top()first; vps.pop(); // v is v1 // p is p2 // step å } // if step å (v1, p2) is top of vps vps.push(make_pair(v, p)); } } // calculate all the profits while (!vps.empty()) { profits.push_back(prices[vps.top().second] - prices[vps.top().first]); vps.pop(); } // calculate k highest profitœ int ans = 0; const int n = profits.size(); if (n &lt; = k) { accumulate(profits.begin(), profits.end(), 0); } else { nth_element(profits.begin(), profits.end() - k, profits.end()); accumulate(profits.end() - k,profit.end(), 0); } return ans;};","link":"/2020/06/07/BestTimeToBuyAndSellStockIV/"},{"title":"C++ 对象序列化","text":"背景 最近做的项目需要对C++对象进行序列化和反序列化，最主要的目的是将JSON和C++对象互转。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;map&gt;// sequence fortemplate &lt;typename T, T... S, typename F&gt;constexpr void for_sequence(std::integer_sequence&lt;T, S...&gt;, F&amp;&amp; f) { using unpack_t = int[]; (void)unpack_t{(static_cast&lt;void&gt;(f(std::integral_constant&lt;T, S&gt;{})), 0)..., 0};}// Sample implementation of a json-like data structure. It is only there for the example to compile and actually produce a testable outputnamespace Json { struct Value; struct ValueData { std::map&lt;std::string, Value&gt; subObject; std::string string; int number = 0; }; struct Value { ValueData data; Value&amp; operator[](std::string name) { return data.subObject[std::move(name)]; } const Value&amp; operator[](std::string name) const { auto it = data.subObject.find(std::move(name)); if (it != data.subObject.end()) { return it-&gt;second; } throw; } Value&amp; operator=(std::string value) { data.string = value; return *this; } Value&amp; operator=(double value) { data.number = value; return *this; } }; template&lt;typename T&gt; T&amp; asAny(Value&amp;); template&lt;typename T&gt; const T&amp; asAny(const Value&amp;); template&lt;&gt; int&amp; asAny&lt;int&gt;(Value&amp; value) { return value.data.number; } template&lt;&gt; const int&amp; asAny&lt;int&gt;(const Value&amp; value) { return value.data.number; } template&lt;&gt; const std::string&amp; asAny&lt;std::string&gt;(const Value&amp; value) { return value.data.string; } template&lt;&gt; std::string&amp; asAny&lt;std::string&gt;(Value&amp; value) { return value.data.string; }}template&lt;typename Class, typename T&gt;struct PropertyImpl { constexpr PropertyImpl(T Class::*aMember, const char* aName) : member{aMember}, name{aName} {} using Type = T; T Class::*member; const char* name;};// One could overload this function to accept both a getter and a setter instead of a member.template&lt;typename Class, typename T&gt;constexpr auto property(T Class::*member, const char* name) { return PropertyImpl&lt;Class, T&gt;{member, name};}// unserialize functiontemplate&lt;typename T&gt;T fromJson(const Json::Value&amp; data) { T object; // We first get the number of properties constexpr auto nbProperties = std::tuple_size&lt;decltype(T::properties)&gt;::value; // We iterate on the index sequence of size `nbProperties` for_sequence(std::make_index_sequence&lt;nbProperties&gt;{}, [&amp;](auto i){ // get the property constexpr auto property = std::get&lt;i&gt;(T::properties); // get the type of the property using Type = typename decltype(property)::Type; // set the value to the member object.*(property.member) = Json::asAny&lt;Type&gt;(data[property.name]); }); return object;}template&lt;typename T&gt;Json::Value toJson(const T&amp; object) { Json::Value data; // We first get the number of properties constexpr auto nbProperties = std::tuple_size&lt;decltype(T::properties)&gt;::value; // We iterate on the index sequence of size `nbProperties` for_sequence(std::make_index_sequence&lt;nbProperties&gt;{}, [&amp;](auto i){ // get the property constexpr auto property = std::get&lt;i&gt;(T::properties); // set the value to the member data[property.name] = object.*(property.member); }); return data;}namespace animal { struct Dog { std::string barkType; std::string color; int weight = 0; bool operator==(const Dog&amp; rhs) const { return barkType == rhs.barkType &amp;&amp; color == rhs.color &amp;&amp; weight == rhs.weight; } constexpr static auto properties = std::make_tuple(property(&amp;Dog::barkType, &quot;barkType&quot;), property(&amp;Dog::color, &quot;color&quot;), property(&amp;Dog::weight, &quot;weight&quot;)); };}int main() { animal::Dog dog; dog.color = &quot;green&quot;; dog.barkType = &quot;whaf&quot;; dog.weight = 30; Json::Value jsonDog = toJson(dog); // produces {&quot;color&quot;:&quot;green&quot;, &quot;barkType&quot;:&quot;whaf&quot;, &quot;weight&quot;: 30} auto dog2 = fromJson&lt;animal::Dog&gt;(jsonDog); std::cout &lt;&lt; std::boolalpha &lt;&lt; (dog == dog2) &lt;&lt; __FILE_NAME__ &lt;&lt; std::endl; // pass the test, both dog are equal! return 0;}","link":"/2019/11/22/C-Object-Serialization/"},{"title":"Boyer Moore Majority Vote Algorithm","text":"题目 MajorityElementII Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times. Note: The algorithm should run in linear time and in O(1) space. Example 1: 12Input: [3,2,3]Output: [3] Example 2: 12Input: [1,1,1,3,3,2,2,2]Output: [1,2] 解题报告 理解题意 给定一个数组，大小为 n，让找到所有出现多于⌊ n/3 ⌋次的元素 题目要求线性时间，以及 O(1) 的空间复杂度 Boyer-Moore majority vote algorithm 该算法来自一篇论文Boyer-Moore Majority Vote Algorithm，运行时间为O(n)，空间复杂度为O(1)，他只要求对输入遍历两次。虽然实现起来比较简单，但是理解起来还是需要花点时间。 第一遍 &gt; 1. 我们需要定义两个变量：candidate 和 count &gt; 2. 对于每一个输入的元素，首先看 count，如果 count 为 0，将当前位置元素赋给 candidate &gt; 3. 比较当前位置的元素 与 candidate，如果相等：count+1，如果不等 count-1 &gt; 说白了，就是不一样的就可以抵消一个，最后剩下的 candidate 就是候选，最后在确认一次即可。 123456789candidate = 0count = 0for value in input: if count == 0: candidate = value if candidate == value: count += 1 else: count -= 1 当执行完毕后，candidate 即为 majority value 如果存在的话。 第二遍 确定一下 candidate 是不是 majority 元素。","link":"/2019/11/22/BoyerMooreMajorityVoteAlgorithm/"},{"title":"探索 NSDictionary","text":"Exposing NSDictinoary The Class 相当多的类都是 class clusters，当然 NSDictionary 也不例外，曾经一段时间 NSDictinoary 使用了 CFDictionary 作为它的默认实现。然而，在 iOS 6以后事情改变了。。。 12(lldb) po [[NSDictionary new] class]__NSDictionaryI 和 __NSArrayM 一样， __NSDictionaryI 也是在 CoreFoundation Framework 中： 12345@interface __NSDictionaryI : NSDictionary{ NSUIngeter _used:58; NSUIngeter _szidx:6;} The Storage Instance Creation 想要理解 __NSDictionaryI 在哪里保存内容，我们来看看对象创建的过程，只有一个类方法负责创建实例：__NSDictionaryI。根据 class-dump 的输出，方法有如下的签名： 1+ (id)__new:(const id *)arg1:(const id *)arg2:(unsigned long long)arg3:(_Bool)arg4:(_Bool)arg5; 他需要5各参数，只有第一个是指名字，如果我们使用@selector 的方式来写的话，应该是这样 @selector(__new:::::)。前三个参数通过设置断点，然后看一下寄存器 x2、x3、x4的内容，看到他们是分别是：array 的 key、array 的 object、key（object） 的个数。注意和对外公布的 api 相比，参数的位置是互换的。 1+ (instancetype)dictionaryWithObjects:(const id [])objects forKeys:(const id &lt;NSCopying&gt; [])keys count:(NSUInteger)cnt; 其实参数定义为const id *或者const id []没有太大的关系。剩下的就是两个BOOL 类型的参数。第四个参数是指 key 是否需要被拷贝。第五个参数决定了参数是否不需要被 retain。我们可以重写该函数： 1+ (id)__new:(const id *)keys :(const id *)objects :(unsigned long long)count :(_Bool)copyKeys :(_Bool)dontRetain; Indexed ivars 除了函数+ __new:::::以外，malloc 和 calloc 并没有地方被调用。实际上，函数调用了 __CFAllocateObject2 方法，并且传递了 __NSDictionaryI 作为第一个参数，然后用需要的大小作为第二个参数。__CFAllocateObject2 实际上调用了 class_createInstance ，然后把同样的参数传给他。 class_createInstance(Class cls, size_t extraBytes) 调用了 _class_createInstanceFromZone 并且传个 nil 作为 zone 的参数。 123456789_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone){ ... size_t size = cls-&gt;alignedInstanceSize() + extraBytes; ... id obj = (id)calloc(1, size); ... return obj;} extreBytes 参数，calloc 函数调用确保了所有的 ivar 都是 0. indexed ivars就是在普通的 ivar 后面 剩下的就是分配内存了 1void *object_getIndexedIvars(id obj) 关于 indexed ivar 有一些比较好玩的事情。 * 每一个实例都可以有不同数量的 extraBytes指向他 * 存取速度很快。 * 可以对 class-dump 这样的工具隐藏实现细节。 但是：在 arc 环境下是不能直接编译 class_createInstance，需要增加 -fno-objc-arc 标志位。。运行时没有保存 indexed ivars 信息。 key &amp; 访问一个对象 C Code 1234567891011121314151617181920212223242526272829- (id)objectForKey:(id)aKey{ NSUInteger sizeIndex = _szidx; NSUInteger size = __NSDictionarySizes[sizeIndex]; id *storage = (id *)object_getIndexedIvars(dict); NSUInteger fetchIndex = [aKey hash] % size; for (int i = 0; i &lt; size; i++) { id fetchedKey = storage[2 * fetchIndex]; if (fetchedKey == nil) { return nil; } if (fetchedKey == aKey || [fetchedKey isEqual:aKey]) { return storage[2 * fetchIndex + 1]; } fetchIndex++; if (fetchIndex == size) { fetchIndex = 0; } } return nil;} 上述代码是从汇编反推出来的。","link":"/2019/12/04/Dive-Into-NSDictionary/"},{"title":"Construct Binary Tree from Preorder and Postorder Traversal","text":"题目 Construct Binary Tree from Preorder and Postorder Traversal Return any binary tree that matches the given preorder and postorder traversals. Values in the traversals pre and post are distinct positive integers. Example 1: 12Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]Output: [1,2,3,4,5,6,7] Note: 1231 &lt;= pre.length == post.length &lt;= 30pre[] and post[] are both permutations of 1, 2, ..., pre.length.It is guaranteed an answer exists. If there exists multiple answers, you can return any of them. 解题报告 理解题意 给定两个数组，分别表示先序遍历和后序遍历 要求根据两个遍历结果构造出原来的二叉树 思路 递归解法 创建一个节点 TreeNode[pre[preIndex]] 作为根节点 由于后序遍历中根节点是最后访问的，因此构造结束的条件就是：root-&gt;val == post[postIndex] 那么，如果还没有创建完二叉树，我们就递归的对于左子树和右子树调用构造函数。 12345678910111213141516class Solution {private: int preIndex = 0; int postIndex = 0;public: TreeNode *constructFromPrePost(vector&lt;int&gt;&amp; pre, vector&lt;int&gt;&amp; post) { TreeNode *root = new TreeNode(pre[preIndex++]); if (root-&gt;val != post[postIndex]) root-&gt;left = constructFromPrePost(pre, post); if (root-&gt;val != post[postIndex]) { root-&gt;right = constructFromPrePost(pre, post); } postIndex++; return root; }}; 非递归解法 使用栈，前序生成二叉树，将生成的结果 push 到 stack 中，然后使用后续 pop 出来 stack 保存的是当前的树 node == new TreeNode(pre[i]) ，如果没有左子节点，就把它作为左子节点，否则就是右子节点。 如果在前序遍历和后序遍历碰到了相同的值，那么就说明当前子树构造结束，将其 pop 出来 123456789101112131415161718192021class Solution {public: TreeNode * constructFromPrePost(vector&lt;int&gt;&amp;pre, vector&lt;int&gt; &amp;post) { vector&lt;TreeNode*&gt; stk_; stk_.push_back(new TreeNode(pre[0])); for (int i = 1, j = 0; i &lt; pre.size(); i++) { TreeNode *node = new TreeNode(pre[i]); while (stk_.back()-&gt;val == post[j]) { stk_.pop_back(); j++; } if (stk_.back()-&gt;left == nullptr) { stk_.back()-&gt;left = node; } else { stk_.back()-&gt;right = node; } stk_.push_back(node); } return stk_[0]; }}; 时间复杂度 遍历次数：O(n)，因此是线性时间，每个元素只遍历一次 空间复杂度 O(n) 表示栈的大小","link":"/2020/05/24/ConstructBinaryTreeFromPreorderAndPostorderTraversal/"},{"title":"FishHook 学习笔记","text":"0x0 什么是dyld dyld 是加载Mach-O的库，入口是_dyld_start,","link":"/2019/12/26/Dynamic-Library/"},{"title":"Find K-th Smallest Pair Distance","text":"题目 Find K-th Smallest Pair Distance Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B. 123456789101112131415Example 1:Input:nums = [1,3,1]k = 1Output: 0Explanation:Here are all the pairs:(1,3) -&gt; 2(1,1) -&gt; 0(3,1) -&gt; 2Then the 1st smallest distance pair is (1,1), and its distance is 0.Note:2 &lt;= len(nums) &lt;= 10000.0 &lt;= nums[i] &lt; 1000000.1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2. 解题报告 理解题意 给定数组，让在所有的距离对中求第 k 个最小的距离，然后给出距离对的定义是 (a,b) --&gt; a 和 b 的差值 理解例子 {1,3,1} 数组，可能有的距离对的个数为 n * (n - 1) / 2 所有的距离对为：(1, 3) (1, 1) (3, 1) 他们的距离值为: 2, 0 ,2 因此排在第 1 位的最小的距离对为 (1,1) 结果为 0 思路 首先想到的就是暴力解法，我们得知道所有可能的距离对，然后计算每个对的差值，求第 k 个。 转念一想，其实没必要把距离对求出来，只要求出所有可能的差值就行。 但差值可能有好几个，模式点像桶排序，O(n)时间就可完成排序，那么就得知道需要多少个桶。 所以对输入数据进行排序后，最大的值，就知道了，也就知道桶的个数了。 每个桶里放差值的个数即可，就能知道排在第几位的桶有多少个，也就能回答问题 代码 123456789101112131415161718class Solution {public: int smallestDistancePair(vector&lt;int&gt;&amp; nums, int k) { sort(nums.begin(), nums.end()); int n = nums.back(); const int m = nums.size(); vector&lt;int&gt; freq(n+1, 0); for (int i = 0; i &lt; m; i++) { for (int j = i+1; j &lt; m; j++) freq(nums[j]-nums[i])++; } for (int i = 0; i &lt; n; i++) { k -= freq[i]; if (k &lt;= 0) return i; } return 0; }}; 时间复杂度 \\(\\) 空间复杂度 因此空间复杂度也为 \\(\\) 优化 提交后通过了，但是所有的性能指标是在最后的最后，还是优化一下符合要求 桶排序的内存要求比较高，另外，在求所有元素对的地方耗费太多时间，那个地方也是优化点。 这道题目的步骤大概可以分为两个，首先的知道距离对的内容，然后就是找 k 个满足条件的距离对 距离对的内容，可以使用 dp 来解决，那么 dp 的状态转换方程应该怎么写呢？ 思路 由于题目让求排在第 k 位的最小的距离对。之前的 lower_bound 是查找≥某个数的第一个位置， upper_bound 是求＞某个数的第一个位置。因此这道题应该是让查：差值，这个差值还得满足至少有 k 个差值是小于等于它的。 因此如果要使用折半查找的数据内容是表示 以上内容的，就可以方便的使用折半查找了。 假定内容是升序排列，假定 d_ij 表示 对于(i,j) 距离对且 i &lt; j，那么 d_id = nums[j] - nums[i] 如果 i 位置不变的话，d_ij &lt;= num 就等价于 nums[j] &lt;= nums[i] + num 那么也就是说要去找最小的 j 保证 nums[j] &gt; nums[i] + num 计数也可以使用双指针，在线性时间下完成 &gt; * 假定两个起点 l1 &lt; l2，满足 nums[j1] &gt; nums[i1] + num 和 nums[j2] &gt; nums[i2] + num ---&gt; j2 &gt; j1","link":"/2020/07/04/FindKtheSmallestPairDistance/"},{"title":"Find the Duplicated Number","text":"题目 Find the Duplicated Number Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one. Example 1: 12Input: [1,3,4,2,2]Output: 2 Example 2: 12Input: [3,1,3,4,2]Output: 3 Note: You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once. 解题报告 理解题意 给定一个大小为 n+1 的数组，其中每一个数字都是在 1--N 的区间内, 证明至少有一个重复数字是存在的，假定只有唯一的一个重复数字，找到他 不能修改数组, 排序也就不能用了。 常量空间 运行时间要比 N^2要小，那就只剩下 O(n) O(nlogn) O(logn) 的算法可用。 理解例子 2 -&gt; 4 -&gt; 3 = 342 5 -&gt; 6 -&gt; 4 = 465 342 + 465 = 807 答案 : 7 -&gt; 0 -&gt; 8 思路 证明至少存在一个重复数字，如果元素是[1,n] 那么就存在 n 个不同的数字，分别将每一个位置都占据了，当数字个数为 n+1 时，那么最少有一个数字是重复的 由于数组的 n+1 个元素的取值范围为 1..n，假定映射关系为 f，那么就存在一个函数 f(i) --&gt; 可以取到 nums[i]，重复的情况就是说存在另一个数字 j，在i != j的前提下，存在 f(i) == f(j)， 那么剩下的问题就是如何将 f 表示出来 就是说使用函数 f。遍历整个数组，总会存在一个位置导致没有办法结束，走入无限循环，也就是类似链表存在环。 证明过程：证明过程 代码 1234567891011121314151617181920class Solution {public: int findDubplicated(vector&lt;int&gt;&amp; nums) { int slow = 0, fast = 0; while (true) { slow = nums[slow]; fast = nums[nums[fast]]; if (slow == fast) break; } int find = 0; while (true) { slow = nums[slow]; find = nums[find]; if (slow == find) break; } return find; }};","link":"/2020/06/27/FindTheDuplicatedNumber/"},{"title":"DynamicProgramming","text":"动态规划套路 有一个 m*n 大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法 暴力解法 从(1,1)-&gt;(m,n)的不同路径中有大量的重复，比如(1,1)-&gt;(i,j)有 k 条不同的路径，那么对于任何一条固定的路线(i,j)-&gt;(m,n)的路径，都需要走 k 遍来模拟。 不关心具体的走法，只关心状态，也就是走法的数量 同理，如果知道(i,j)-&gt;(m,n)有 k 条不同的路径，那么(1,1)-&gt;(i,j)-&gt;(m,n)的不同路径总数是k*s ##### 动态规划 令(i,j)表示从(1,1)-&gt;(i,j)的不同路径数量，f(i,j) = f(i-1,j) + f(i,j-1) 如果要求出 f(i,j) 只需要上一个结果即可， 也就是求解f(i,j) 需要求出子问题f(i',j') ##### 动态规划适用前提 ###### 无后效性 一旦确定f(i,j)，就不用关心如何计算出f(i,j) 想要确定f(i,j)，只要知道f(i-1,j)和f(i,j-1) ###### 最优子结构 f(i,j)的定义已经蕴含最优 大问题的最优解可以由若干小问题的最优解推出(min, max, sum) &gt; DP 适用的问题：可以将大问题拆成几个小问题，且无后效性，具有最优子结构的性质 ###### 记忆化递归 可以使用递归求解 有重复子问题，overlaping subproblem 套路一：基本类型（时间序列） House Robber 给一排房子，相邻的房子不能抢，问最多能抢的价值 房子只有抢和不抢两个状态 和时间相关的为第 i 轮 12345678910111213141516171819202122class Solution {public: int rob(vector&lt;int&gt;&amp; nums) { // 0 --&gt; max profit of not rob the i-th house // 1 --&gt; max profit of robbing the i-th house // corner case if (nums.empty()) return 0; vector&lt;vector&lt;int&gt;&gt; dp(nums.size() + 1, vector&lt;int&gt;(2,0)); // if not rob 0 max profit is 0 dp[0][0] = 0; // if rob 0, max profit is nums[0] dp[0][1] = nums[0]; for (int i = 1; i &lt; nums.size(); i++) { // if not rob the i-th roby, so the max profit will be the max value of rob/non-rob on last house // because if rob on a low price house will not be a good choice dp[i][0] = max(dp[i-1][0], dp[i-1][1]); // if decide to rob i-th , i-1-th must not be robbed dp[i][1] = dp[i-1][0] + nums[i]; } return max(dp[nums.size() - 1][0], dp[nums.size() - 1][1]); }}; House Robber II 给一圈“首尾相连”的房子，相邻的房子不能抢，问最多能抢的价值 假定有 n 个房子，因为 0 和 n-1 为相邻的房子。因此可抢的范围为 0 -&gt; n-2 或者 1 -&gt; n-1 因此结果就是两个中最大值。 12345678910111213141516171819class Solution {public: int rob(vector&lt;int&gt;&amp; houses) { const int m = nums.size(); if (m &lt; 2) return m ? nums[0] : 0; function&lt;int(int,int)&gt; robHelper = [&amp;](int l, int r){ vector&lt;vector&lt;int&gt;&gt; dp(m+1, vector&lt;int&gt;(2, 0)); dp[l][1] = nums[l]; for (int i = l; i &lt;= r; i++) { if (i == 0) continue; dp[i][0] = max(dp[i-1][0], dp[i-1][1]); dp[i][1] = dp[i-1][0] + nums[i]; } return max(dp[r][0], dp[r][1]); }; return max(robHelper(1, m-1), robHelper(0, m-2)); }}; Best Time to Buy and Sell Stock III 给定一系列每日股票的价格，每日只能买入、卖出、不操作。最多交易两次，问最大的收益 12345678910111213/* 0 表示这一轮我已经持有第一股的最大收益 1 表示这一轮我已经售出第一股的最大收益 2 表示这一轮我已经持有第二股的最大收益 3 表示这一轮我已经售出第二股的最大收益*/ for (int i = 1; i &lt;= n; i++) { dp[i][0] = max(dp[i-1][0], -val[i]); dp[i][1] = max(dp[i-1][1], dp[i-1][0] + val[i]); dp[i][2] = max(dp[i-1][2], dp[i-1][1] - val[i]); dp[i][3] = max(dp[i-1][3], dp[i-1][2] + val[i]); } ans = max{dp[n][i]} (i = 0,1,2,3) Best Time to buy and Sell Stock with cooldown 给定一系列股票的加个，每日只能买入、卖出、不操作。买入后要隔卖出，无总交易限制，问最大收益 1234567891011/* 0 表示本轮刚持有股票的最大收益 1 表示本轮持有一天以上的最大收益 2 表示我已清空股票的最大收益*/for(int i = 1; i &lt;= n; i++) { dp[i][0] = dp[i-1][2] - val[i]; dp[i][1] = max(dp[i-1][1], dp[i-1][0]); dp[i][2] = max(dp[i-1][2], dp[i-1][1] + val[i]);}ans = max{dp[i][n]} (n = 1, 2, 3) Wiggle Subsequence 给定一个序列 s， 求其最长的wiggle pattern subsequence (.... &gt;s[i] &lt; s[j] &gt; s[j+1]...) 12345678910111213/* 0 以当前元素结尾且上升 1 一当前元素结尾且下降*/for (int i = 1; i &lt;= N; i++) { if (nums[i] &gt; nums[i-1]) { dp[i][0] = dp[i-1][1] + 1; } if (nums[i] &lt; nums[i-1]) { dp[i][1] = dp[i-1][0] + 1; } ans = max(dp[N][i]) (i = 0, 1)} Paint Fence 给出 cost[i] 表示第 i 个房子喷涂第 j 中 漆的价格，相邻的房子不能涂同一种颜色，求喷涂所有房子的最小价格 paintFence.PNG 1234567/* dp[i][j] 表示第 i 间房子喷涂第 j 中颜色的代价*/for (int i = 1; i &lt;= N; i++) { dp[i][j] = min(dp[i-1][j], cost[j]) // j = 1,2,...,k}ans = min(dp[N][j]) (j = 0,1,2,...,k) To Do or Not To Do 很多不那么套路的 DP 题目，状态比较难以设计，某些题目会给你“行使某种策略的权利”，想买卖股票的题目，两个状态就分别为“行驶了某种权利”，“没有行使某种权利” 分别对应的价值 Max Consecutive One II 给定一个数组(0/1)，有最多一次从 0 翻转到 1 的权利，问最多可以有多少连续的 1 123456789/* 0 表示以当前元素结尾且没有行使翻转权利的最长连续 1 1 表示以当前元素结尾且已经行驶翻转权利的最长连续 1*/for (int i = 1; i &lt;= N; i++) { dp[i][0] = max(dp[i-1][0] + nums[i], nums[i]); dp[i][1] = max(dp[i-1][0],dp[i-1][1]+nums[i]);}ans = max(dp[i][j]) (for all possible i,j = 0,1) 套路二：基本类型 II（时间序列加强版） 给定一个序列（数组/字符串），其中每个元素可以认为一天，但今天的状态和之前的某一天有关，需要挑选。 套路 定义 dp[i] 表示第 i 轮的状态，一般这个状态要求和元素 i 直接有关系。 千方百计将 dp[i] 与之前的状态 dp[i'] 产生关系比如 sum,max,min, dp[i] 一定不能与大于 i 的轮次有关系，否则违反了 DP 的无后效性。 * 最终的结果是 dp[i] 中的某一个 Longest Increasing Subsequence 给定一个数组 s，求最长的递增子序列的长度 状态定义： 照抄问题，dp[i]--&gt; s[1:i]里面以 s[i]为结尾的、最长的递增子序列的长度。 状态转移：寻找最优解的前驱状态 j，将 dp[i] 与 dp[j] 产生联系 12345678for (int i = 1; i &lt;= N; i++) { //i 表示 LIS 的最大元素，搜索该 LIS 的第二大元素 for (int j = 1; j &lt; i; j++) { if (nums[i] &lt; nums[j]) dp[i] = max(dp[i], dp[j]+1); }}ans = max(dp[i]), for i in 1,...N Largest Divisible Subset 给定一个数组 s，求最大子集，使得里面的所有元素之间都可以相互整除。 状态定义：照抄问题，dp[i]--&gt; s[1:i] 以 s[i]为结尾，满足题目要求的最大子集的数目。 状态转移：寻找最优的前驱状态 j，将 dp[i] 与 dp[j] 产生联系 123456789sort(nums);for (int i = 1; i &lt;= N; i++) { // i 表示该集合的最大元素，搜索该子集的第二大元素 j for (int j = 1; j &lt; i; j++) { if (nums[i] % nums[j] == 0) dp[i] = max(dp[i], dp[j]+1); }}ans = max(dp[i]) for i in 1,...,N Filling Bookcase Shelves 给定 N 本书（宽高各异）的序列要求按照所给的顺序摆放，相邻的若干本书可以放一层，但同一层的高度不能超过 w。问这个书架最矮可以有多高 将数组 S 分成若干个子数组，最小化“每个数组的最大值之和”，输出该值 状态定义：照抄问题 dp[i]--&gt;将数组S[1,...N] 分成若干个子数组，最小化“每个子数组的最大值之和”，保存该值 状态转移：寻找最优的前驱状态 j，将 dp[i] 与 dp[j] 产生联系 第 i 本书所在的这一层可能有多高？取决于上一层的最后一本书放在那里 12345678910for (int i = 1; i &lt;= N; i++) { // i 表示本层最后一本书，搜索上一层最后一本的位置 for (int j = i-1; j &gt;= 1; j--) { if (totalWidth[j+1:i] &lt;= W) dp[i] = min(dp[i], dp[j] + maxHeight[j+1:i]); else break; }}ans = dp[N]; 套路三：双序列类型 给出两个序列 s 和 t（数组/字符串），对他们搞事情 套路 定义 dp[i][j]: 表示针对 s[1:i] 和 t[1:j] 的子问题求解答 千方百计将 dp[i][j] 与之前的状态之间转移 dp[i-1][j], dp[i][j-1] , dp[i-1][j-1] 最终的结果是 dp[m][n] Longest Common subsequences 求字符串 s 和 t 的 length of LCS 状态定义：照抄问题 dp[i][j]--&gt; s[1:i] t[1:j]的 length of LCS 状态转移：外面两大层循环编译 i 和 j，核心从 s[i] 与 t[j] 的关系作为突破口，往 dp[i-1][j], dp[i][j-1], dpp[i-1][j] 转移 12345678910111213/* s:XXXXXi t:YYYj*/for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { if (s[i] == t[j]) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } }} Shortest Common Supersequence 求字符串 s 和 t 的 length of SCS 状态定义：照抄问题 dp[i][j]--&gt; s[1:i] 和 t[1:j] 的 length of SCS 状态转移：外面两层大循环遍历 i 和 j ：核心从 s[i] 与 t[j] 的关系作为突破口，拼命往 dp[i-1][j], dp[i][j-1], dp[i-1][j-1] 转移 123456789for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { if (s[i] == t[j]) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1); } }} Edit Distance 求字符串 s 和 t 的 min edit distance 状态定义：照抄问题 dp[i][j]--&gt; s[1:i] 和 t[1:j] 的 min edit distance 状态转移：外面两层大循环遍历 i 和 j ：核心从 s[i] 与 t[j] 的关系作为突破口，拼命往 dp[i-1][j], dp[i][j-1], dp[i-1][j-1] 转移 套路四：第一类区间类型 套路五：第二类取件类型 套路六：背包入门 状态压缩","link":"/2020/06/04/DynamicProgramming/"},{"title":"Gray Code Conversion","text":"来自维基百科 12345678910111213141516171819202122232425/* The purpose of this function is to convert an unsigned binary number to reflected binary Gray code. The operator &gt;&gt; is shift right. The operator ^ is exclusive or.*/unsigned int binaryToGray(unsigned int num){ return (num &gt;&gt; 1) ^ num;}/* The purpose of this function is to convert a reflected binary Gray code number to a binary number.*/unsigned int grayToBinary(unsigned int num){ unsigned int mask; for (mask = num &gt;&gt; 1; mask != 0; mask = mask &gt;&gt; 1) { num = num ^ mask; } return num;}","link":"/2020/05/22/GrayCode-Conversion/"},{"title":"Groking The coding Interview","text":"滑动窗口 AddTwoNumbers You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Example: 123Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)Output: 7 -&gt; 0 -&gt; 8Explanation: 342 + 465 = 807. 解题报告 理解题意 2 个 非空链表，长度可能不相等 每个链表为逆序 返回两个链表的和 每个元素应该为正数 理解例子 2 -&gt; 4 -&gt; 3 = 342 5 -&gt; 6 -&gt; 4 = 465 342 + 465 = 807 答案 : 7 -&gt; 0 -&gt; 8 思路 将每一个链表变成整形，然后相加，结果分解成链表不大合适，还得处理越界的情况 比较合理的办法：是一边遍历一边生成链表 每一个生成的节点为两个数的和，有可能产生进位: 如 7+8=15 一个节点的结果为：sum = 前一个节点的进位+两个节点的和，res = sum % 10; 一个节点的结果几种情况 last_carry + left + right &lt; 10 last_carry + left + right &gt;= 10 只要有进位，就一定会有一个新的节点出现 代码 非递归 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { if (!l1) return l2; if (!l2) return l1; int carry = 0; ListNode dummy(0); ListNode *head = &amp;dummy; while (l1 || l2 || carry) { int sum = (l1 ? l1-&gt;val : 0) + (l2 ? l2-&gt;val : 0) + carry; head-&gt;next = new ListNode (sum % 10); head = head-&gt;next; carry = sum / 10; if (l1) l1 = l1-&gt;next; if (l2) l2 = l2-&gt;next; } return dummy.next; }}; 12345678910111213141516171819202122232425262728293031public class ListNode { public var val: Int public var next: ListNode? public init(_ val: Int) { self.val = val self.next = nil }}class Solution { func addTwoNumbers(_ l1: ListNode?, _ l2: ListNode?) -&gt; ListNode? { var l1 = l1 var l2 = l2 var prev = ListNode(0) var carry = 0 let head = prev while l1 != nil || l2 != nil || carry != 0 { let cur = ListNode(0) let sum = (l2 == nil ? 0 : l2!.val) + (l1 == nil ? 0 : l1!.val) + carry cur.val = sum % 10 carry = sum / 10 prev.next = cur prev = cur l1 = l1 == nil ? l1: l1?.next l2 = l2 == nil ? l2: l2?.next } return head.next }} 递归 这道题比较简单，递归模式也比较好想到 加法需要三个值，两个操作符（来自两个链表）以及一个进位标记。 因此递归模式为： 递归出口：两个链表都已经到达末尾，并且没有进位 递归实现： 当前节点的结果为：和/10 当前节点的next节点为：对于两个链表next节点的计算的结果 12345678910111213141516171819202122/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {private: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2, int carry) { if (!l1 &amp;&amp; !l2 &amp;&amp; !carry) return nullptr; int sum = (l1?l1-&gt;val:0) + (l2?l2-&gt;val:0) + carry; ListNode *ans = new ListNode(sum % 10); ans-&gt;next = addTwoNumbers(l1?l1-&gt;next:nullptr, l2?l2-&gt;next:nullptr, sum / 10); return ans; }public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) { return addTwoNumbers(l1, l2, 0); }}; 时间复杂度 遍历次数：max(len(l1), len(l2)) + 1，因此是线性时间 \\(\\) 空间复杂度 额外申请了和一个链表，因此空间复杂度也为 \\(\\)","link":"/2020/11/16/GrokingTheCodeInterview/"},{"title":"单例如何释放","text":"iOS weak关键字 weak 关键字的运用在 iOS 当中属于基础知识，在面试的时候问 weak 的用处，就像两个 iOS 程序员见面寒暄问候一样普通了。 weak 的常见场景是在 delegate，block，NSTimer 中使用，以避免循环引用所带来的内存泄漏，这是教科书式的用法。 编程语言是工具，语言特性只是工具的特性，工具怎么用在于使用者。weak 关键字的方便之处绝不局限于避免循环引用，适当脑洞，可以在其他场景下带来一些有趣的应用。 weak 的用处用一句话可归纳为：弱引用，在对象释放后置为 nil，避免错误的内存访问。用更通俗的话来表述是：weak 可以在不增加对象的引用计数的同时，又使得指针的访问是安全的。 weak singleton 之前见过一篇文章介绍了一个新 pattern 叫 「weak singleton」。这种特殊的单例有一个有意思的特性：在所有使用该单例的对象都释放后，单例对象本身也会自己释放。我所见过的大部分单例使用场景，被创建都单例最后都会一直存活着，比如注册登录模块所需要共享状态所创建的 XXLoginManager，即使在用户注册成功进入主界面之后也不会被显式的释放，这在一定程度上会带来内存使用的浪费。所谓的「weak singleton」代码很简单： 123456789101112+ (id)sharedInstance{ static __weak ASingletonClass *instance; ASingletonClass *strongInstance = instance; @synchronized(self) { if (strongInstance == nil) { strongInstance = [[[self class] alloc] init]; instance = strongInstance; } } return strongInstance;} 「weak singleton」这个漂亮名字背后其实只是简单而巧妙的利用了 weak 特性，sharedInstance 中的 weak 就像是一个智能管家，在无人使用 instance 之后就置为 nil 销毁，当 sharedInstance 再次被调用时，instance 又会重新被创建。 PS: 还有另一个方式可以释放单例 主要思路是单例是靠 dispatch_once_t 类型的 token 来确保初始化，只执行一次，来实现单例。 1234567891011121314static dispatch_once_t * once_token_factory;+ (ZDocUIFactory *)sharedInstance{ static dispatch_once_t onceToken; once_token_factory = &amp;onceToken; static id factory = nil; dispatch_once(&amp;onceToken, ^{ factory = [[ZDocUIFactory alloc] init]; }); return factory;}- (void)destoryFactory{ *once_token_factory = 0;}","link":"/2019/12/04/How-To-Release-Singleton-iOS/"},{"title":"LinkedList","text":"链表总结 12345struct ListNode{ int value; ListNode* next; ListNode(int v) : value(v), next(nullptr) { }}; 常见题型 给定链表，删除所有重复元素，使得每一个元素只出现一次 123456789101112131415class Solution{public: ListNode *deleteDuplicates(ListNode *root) { if (!root) return root; ListNode dummy(0); ListNode *pre = &amp;dummy, pre-&gt;next = root; while (root) { while(root &amp;&amp; root-&gt;value == pre-&gt;next-&gt;value) root = root-&gt;next; pre-&gt;next-&gt;next = root; pre = pre-&gt;next; } return dummy.next; }}; 12345678910111213class Solution {public: ListNode* deleteDuplicates(ListNode* head) { ListNode *cur = head; while (cur &amp;&amp; cur-&gt;next) { if (cur-&gt;value == cur-&gt;next-&gt;value) cur-&gt;next = cur-&gt;next-&gt;next; else cur = cur-&gt;next; } return head; }}; 给定链表，删除所有的重复元素 树是递归定义的，因此可以用递归求解 1234567891011121314class Solution{public: ListNode* deleteDuplicates(ListNode* head) { if (!head) return head; if (head-&gt;next &amp;&amp; head-&gt;value == head-&gt;next-&gt;value) { while (head &amp;&amp; head-&gt;next &amp;&amp; head-&gt;value == head-&gt;next-&gt;value) { head = head-&gt;next; } return deleteDuplicates(head-&gt;next); } head-&gt;next = deleteDuplicates(head-&gt;next); return head; };}; 翻转链表 非递归 12345678910111213class Solution {public: ListNode *reverseList(ListNode *head) { ListNode *cur = nullptr; while (head) { ListNode *next = head-&gt;next; head-&gt;next = cur; cur = head; head = next; } return cur; }}; 递归 1234567891011class Solution {public: ListNode *reverseList(ListNode *head){ if (!head || !head-&gt;next) return head; ListNode *node = reverseList(head-&gt;next); head-&gt;next-&gt;next = head; head-&gt;next = nullptr; return node; }}; Merge Two Lists 1234567891011121314151617class Solution {public: ListNode *mergeTwoList(ListNode *l1, ListNode *l2) { if (!l1) return l2; if (!l2) return l1; ListNode *cur = nullptr; if (l1-&gt;val &lt; l2-&gt;val) { cur = l1; cur-&gt;next = mergeTwoLists(cur-&gt;next, l2); } else { cur = l2; cur-&gt;next = mergeTwoLists(l1, cur-&gt;next); } return cur; }};","link":"/2020/06/30/LinkedList/"},{"title":"LongestSubstringWithoutRepeatingCharacters","text":"题目 Longest Substring Without Repeating Characters Given a string, find the length of the longest substring without repeating characters. Example 1: 123Input: &quot;abcabcbb&quot;Output: 3Explanation: The answer is &quot;abc&quot;, with the length of 3. Example 2: 123Input: &quot;bbbbb&quot;Output: 1Explanation: The answer is &quot;b&quot;, with the length of 1. Example 3: 1234Input: &quot;pwwkew&quot;Output: 3Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 解题报告 理解题意 给定一个字符串，求最长的无重复字符的子串 子串：没有重复的字符 子串长度：右边-左边 理解例子 例子 1 输入：abcabcbb 输出：3 最长的子串：abc/bca/cab 长度为 3 思路 题目要求计算最长子串长度，并且是无重复的子串。 字符串的长度的计算：当前位置-开始位置 那么随后的问题就是如何计算开始位置。 如果没有重复子串出现过，那么开始位置就是0，如果重复子串出现过，那么开始位置就是这个位置的下一个位置。 需要一个数据结构来记录每一个字符上一次出现的位置 流程 遍历整个字符串 针对每一个字符，在合适的时候更新left，那么剩下的问题就是何时更新left 针对每一个字符，计算并保存最大的长度 遍历完成后返回最大的长度 时间复杂度：线性时间 \\(\\) 代码 1234567891011121314class Solution {public: int lengthOfLongestSubstring(string s) { if (s.empty()) return 0; vector&lt;int&gt; pos_map(256, -1); int start = 0, ans = 0; for (int i = 0; i &lt; s.length(); i++) { start = max(pos_map[s[i]]+1, start); pos_map[s[i]] = i; ans = max(ans, i - start+1); } return ans; }}; 时间复杂度 如一开始分析：时间复杂度：线性时间 \\(\\) 空间复杂度 额外申请了和一个链表，因此空间复杂度也为 \\(\\)","link":"/2019/11/22/LongestSubstringWithoutRepeatingCharacters/"},{"title":"Longest Valid Parentheses","text":"题目 Longest Valid Parentheses Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring. Example 1: 1234Input: &quot;(()&quot;Output: 2Explanation: The longest valid parentheses substring is &quot;()&quot; Example 2: 123Input: &quot;)()())&quot;Output: 4Explanation: The longest valid parentheses substring is &quot;()()&quot; 解题报告 理解题意 给定字符串，只包含：( , ) 要求找出最长的合法的括号对长度 理解例子 (() = 2 第一个 ( 不能与后面的组成合法括号对，所以最长为 2 )()()) = 4 因为只有中间的两对为合法括号对，因此为 4 思路 括号配对一般都用栈 : stack 既然是计数，就得知道从哪个地方开始，匹配的括号肯定是以 ( 作为初始值，但要求最长就肯定得知道什么时候连续匹配被截断 如果有匹配的 () 那么就会以(为计数的起点计数。 如果没有匹配的 () 像 ) 计数就得从头开始 需要保存到目前为止的最大值 代码 栈 1234567891011121314151617class Solution { int longestValidParentheses(string&amp; s) { stack&lt;int&gt; stk_; int ans = 0, start = 0; for (int i = 0; i &lt; s.length(); i++) { if (s[i]=='('){ stk_.push(i); } else { if (stk_.empty()) { start = i + 1; } int curLen = stk_.empy() ? i - start + 1 : i - stk.top(); ans = max(ans, curLen); } } }}; 时间复杂度 遍历次数：O(n)，因此是线性时间，每个元素只遍历一次 空间复杂度 O(n) 表示栈的大小","link":"/2020/04/20/LongestValidParentheses/"},{"title":"LowerBound","text":"LowerBound Lower Bound 是使用二分查找的办法求 大于等于 i 的第一个位置 代码 123456789101112131415class Solution {public: int lowerBound(vector&lt;int&gt;&amp; nums, int i) { int l = 0, r = nums.size(); while (l &lt; r) { int mid = (l + r) / 2; if (nums[mid] &gt;= i) { r = mid; } else { l = mid + 1; } } return l; }}; 时间复杂度 O(logn) 空间复杂度 O(1)","link":"/2020/04/25/LowerBound/"},{"title":"Mac_NSTextView_中英混输情况下_inline_上下抖动","text":"问题由来 今天在做项目的时候，发现自定义的 NSTextView 出现了几种情况比较蛋疼 对齐问题，英文对齐，中文偏移 在中英文混输的情况下，会出现之前的文字上下抖动的情况，可以拿出来钉钉试试 先在输入框中输入中文（啊），空格上屏后，再输入一个英文字符 a 不断地尝试删除 a，再输入 a 你会看到 啊 会随着你的输入和删除上下做轻微的抖动，感觉在拍抖音，给个背景音乐很应景 自己的项目 出现了同样的问题，而且更严重的是，同样的输入框，在作为用户签名的时候，中文会有明显的偏移 &gt; 英文对齐，中文上偏 解决 尝试了很多办法，其实比较简单，让自定义的 layoutManager 和 textContainer 去适配一下。 关键代码如下 123textStorage.addLayoutManager(layoutManager)layoutManager.addTextContainer(textContainer)layoutManager.typesetterBehavior = .behavior_10_2_WithCompatibility 前后比较一下，所有问题都消失了","link":"/2020/10/05/Mac-NSTextView-%E4%B8%AD%E8%8B%B1%E6%B7%B7%E8%BE%93%E6%83%85%E5%86%B5%E4%B8%8B-inline-%E4%B8%8A%E4%B8%8B%E6%8A%96%E5%8A%A8/"},{"title":"Majority Element","text":"题目 Majority Element Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Example 1: 12Input: [3,2,3]Output: 3 Example 2: 12Input: [2,2,1,1,1,2,2]Output: 2 解题报告 哈希表 对每一个元素计数，找到大于 n/2 的元素返回即可 1234567891011class Solution {public: int majorityElement(vector&lt;int&gt;&amp; numbers) { unordered_map&lt;int,int&gt; map_; for (int num:numbers) { if (++map_[num] &gt; numbers.size() / 2) return num; } return 0; }}; 排序 因为满足需求的个数是至少 n / 2， 因此只需要找到排序后处于一半位置的元素就是答案。 1234567class Solution {public: int majorityElement(vector&lt;int&gt;&amp; numbers) { nth_element(numbers.begin(), numbers.begin() + numbers.size() / 2, numbers.end()); return numbers[numbers.size()/2]; }}; Divide and Conquer 递归的找两部分的 majority，最后合并结果，递归出口就是单个元素 algorithm 中有个 count 函数，类似于 find，主要是使用一对迭代器和一个值作为参数，返回值出现的次数。 123456789101112131415class Solution {public: int majorityElement(vector&lt;int&gt;&amp; numbers) { function&lt;int(vector&lt;int&gt;, int ,int )&gt; majorityElementHelper = [&amp;](vector&lt;int&gt; element, int l, int r){ if (l == r) return element[l]; int m = l + (r-l)/2; int lm = majorityElementHelper(elements, l, m); int rm = majorityElementHelper(elements, m+1, r); if (lm == rm) return lm; return count(nums.begin() + l, nums.begin() + r + 1, lm) &gt; count(nums.begin() + l, nums.begin() + r + 1, rm) ? lm : rm; }; return majorityElementHelper(numbers,0, numbers.size() - 1); }}; Moore Voting Algorithm 123456789101112class Solution { int majorityElement(vector&lt;int&gt;&amp;numbers) { int count = 0, majority; for (auto num:numbers) { if (!count) { majority = num; } count += (num == majority) 1 : -1; } return majority; }}; 位操作 123456789101112131415161718class Solution { int majorityElement(vector&lt;int&gt;&amp;numbers) { int majority = 0; for (unsigned int i = 0, mask = 1; i &lt; 32; i++, mask &lt;&lt;= 1) { int bits = 0; for (int num : numbers) { if (num &amp; mask) { bits++; } } if (bits &gt; numbers.size() / 2) { majority |= mask; } } return majority; }};","link":"/2020/06/04/MajorityElement/"},{"title":"MedianOfTwoSortedArrays","text":"题目 Median of Two Sorted Arrays There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 解题报告 理解题意 两个数组：m &amp; n （已排好序） 找到两个数组的中间节点 时间复杂度要求：\\(\\) 理解例子 例子 1 nums1：[1, 3] nums2：[2] 中间的元素为 2， 因为总共3个元素：1，2，3； 例子 2 nums1：[1, 2] nums2：[3，4] 中间的元素为 2.5， 因为总共4个元素：[1，2，3，4]；（2+3）/2 = 2.5 思路 从例子来看，把两个数组的元素分别插入到一个新的数组，然后再遍历找到居中的元素，时间复杂度为\\(\\)。 要求时间复杂度为 \\(\\)，这个算是比较强烈的提示（对n个元素折半查找-BinarySearch就是 \\(\\)） 那么剩下的问题就是如何折半，哪里到哪里折半，怎么调整lr. 其实最终的找到的点：左半部分小于右半部分。第一个数组的左半部分小于第二个数组的右半部分，第二个数组的左半部分小于第二个数组的右半部分。并且是合并后数组中间的部分。 12345678910111213141516171819202122232425// 非递归版本int binarySearch(vector&lt;int&gt; &amp;vec, int result){ int l = 0, r = vec.size(); while (l &lt; r) { int mid = (r + l)/2; if (vec[mid] == result) return mid; // found the result if (vec[mid] &gt; result) { // the index is on the left side of mid r = mid; } else { l = mid+1; } } return l;}// 递归版本int binarySearch(vector&lt;int&gt; &amp;vec, int l, int r, int result){ int mid = (l + r) / 2; if (vec[mid] == result) return mid; if (vec[mid] &gt; result) { return binarySearch(vec, l, mid, result); } else { return binarySearch(vec, mid+1, r, result); }} 假定合并后的数组为C 从第一个数组取m1个元素，第二个元素取m2个元素，来构成前k个元素，来满足第k/k+1个元素就是中位数的候选数。其中k = m1 + m2 = (m + n + 1)/2。加 1 是为了不用考虑奇偶。 找到的元素为 \\(\\),根据总数奇数和偶数。 流程 如果某一个为空，则返回另一个数组的中间元素即可 遍历完成后返回最大的长度 时间复杂度：线性时间 \\(\\) 代码 123456789class Solution {public: int findMediaSortedArrays(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2) { const int m = nums1.size(); const int n = nums2.size(); if (m &gt; n) return findMediaSortedArrays(nums2, nums1); }}; 时间复杂度 如一开始分析：时间复杂度：线性时间 \\(\\) 空间复杂度 额外申请了和一个链表，因此空间复杂度也为 \\(\\)","link":"/2019/11/23/MedianOfTwoSortedArrays/"},{"title":"Minimum Number of Flips to Convert Binary Matrix to Zero Matrix","text":"题目 Minimum Number of Flips to Convert Binary Matrix to Zero Matrix Given a m x n binary matrix mat. In one step, you can choose one cell and flip it and all the four neighbours of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighboors if they share one edge. Return the minimum number of steps required to convert mat to a zero matrix or -1 if you cannot. Binary matrix is a matrix with all cells equal to 0 or 1 only. Zero matrix is a matrix with all cells equal to 0. Example 1: 123Input: mat = [[0,0],[0,1]]Output: 3Explanation: One possible solution is to flip (1, 0) then (0, 1) and finally (1, 1) as shown. Example 2: 123Input: mat = [[0]]Output: 0Explanation: Given matrix is a zero matrix. We don't need to change it. Example 3: 1234567Input: mat = [[1,1,1],[1,0,1],[0,0,0]]Output: 6Example 4:Input: mat = [[1,0,0],[1,0,0]]Output: -1Explanation: Given matrix can't be a zero matrix Constraints: 12345m == mat.lengthn == mat[0].length1 &lt;= m &lt;= 31 &lt;= n &lt;= 3mat[i][j] is 0 or 1. 解题报告 理解题意 给定一个数组 m * n 数字只有 0 或者 1 flip 时必须：五个相邻数字（自己、上、下、左、右）。 目标状态为全部为 0 理解例子 例子 1 S：[[0, 0], [0, 1]] 结果：3 0 0 0 1 思路 看到题目应该就会反映到会使用BFS来解决问题：（每次拓展上下左右和自己） 每次拓展的时候回尝试将周边的数字进行翻转 终止状态：找到全0、全部遍历完毕，并且记录步数。 因为只有0/1两个数字。因此可以考虑使用状态压缩来将二维数组进行降维。 考虑将例子中的二维数组：[[0,0],[0,1]] ---&gt; [0001],这样时间复杂度就会缩短。 划分 可以把划分想象成两个部分，左边和右边。 左边：是从 0...j 进行 k-1 次的划分。右边： 一次划分（）。 dp_[i][k] = min{dp_[i][k], dp_[j][k-1] + dp_change[j][i]} dp_change[j][i] 表示从j到i 的最小更换次数。 更改字符 如果划分确定后，如何更改字符就比较好确定了 回文字符串应该从中间开始构建，并且向两边拓展 如果前后两个字符相等(str[i] == str[j]): dp_change[i][j] = dp_change[i+1][j-1] 如果前后两个字符不等(str[i] != str[j]): dp_change[i][j] = 1 + dp_change[i+1][j-1] dp_change[i][j] = (str[i] != str[j]) + dp_change[i+1][j-1] 解决了以上两个问题，那完整的问题，就解决了 流程 异常判断 针对所有的位置，尝试所有的分割， 伪代码 1234int palindromePartition(string &amp;str, int k){} 代码 123456789class Solution {public: int findMediaSortedArrays(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2) { const int m = nums1.size(); const int n = nums2.size(); if (m &gt; n) return findMediaSortedArrays(nums2, nums1); }}; 时间复杂度 如一开始分析：时间复杂度：线性时间 \\(\\) 空间复杂度 额外申请了和一个链表，因此空间复杂度也为 \\(\\)","link":"/2019/12/11/MinimumNumberofFlipsToConvertBinaryMatrixToZero/"},{"title":"莫里斯遍历二叉树","text":"问题 遍历二叉树 O(1)的时间复杂度 二叉树的形状不能破坏 常规遍历 常规遍历使用递归，一般需要O(n)的空间复杂度和O(n)的时间复杂度。 You may assume nums1 and nums2 cannot be both empty. Example 1: 1234nums1 = [1, 3]nums2 = [2]The median is 2.0 Example 2: 1234nums1 = [1, 2]nums2 = [3, 4]The median is (2 + 3)/2 = 2.5 解题报告 理解题意 两个数组：m &amp; n （已排好序） 找到两个数组的中间节点 时间复杂度要求：\\(\\) 理解例子 例子 1 nums1：[1, 3] nums2：[2] 中间的元素为 2， 因为总共3个元素：1，2，3； 例子 2 nums1：[1, 2] nums2：[3，4] 中间的元素为 2.5， 因为总共4个元素：[1，2，3，4]；（2+3）/2 = 2.5 思路 从例子来看，把两个数组的元素分别插入到一个新的数组，然后再遍历找到居中的元素，时间复杂度为\\(\\)。 要求时间复杂度为 \\(\\)，这个算是比较强烈的提示（对n个元素折半查找-BinarySearch就是 \\(\\)） 顺着思路想：折半查找的问题就是如何使用折半查找找到需要的数， 12345678910111213141516171819202122232425// 非递归版本int binarySearch(vector&lt;int&gt; &amp;vec, int result){ int l = 0, r = vec.size(); while (l &lt; r) { int mid = (r + l)/2; if (vec[mid] == result) return mid; // found the result if (vec[mid] &gt; result) { // the index is on the left side of mid r = mid; } else { l = mid+1; } } return l;}// 递归版本int binarySearch(vector&lt;int&gt; &amp;vec, int l, int r, int result){ int mid = (l + r) / 2; if (vec[mid] == result) return mid; if (vec[mid] &gt; result) { return binarySearch(vec, l, mid, result); } else { return binarySearch(vec, mid+1, r, result); }} 假定合并后的数组为C 从第一个数组取m1个元素，第二个元素取m2个元素，来构成前k个元素，来满足第k/k+1个元素就是中位数的候选数。其中k = m1 + m2 = (m + n + 1)/2。 找到的元素为 \\(\\),根据总数奇数和偶数。 对左边的数组，在左边数组的区间内进行二分搜索， ， 流程 如果某一个为空，则返回另一个数组的中间元素即可 遍历完成后返回最大的长度 时间复杂度：线性时间 \\(\\) 代码 123456789class Solution {public: int findMediaSortedArrays(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2) { const int m = nums1.size(); const int n = nums2.size(); if (m &gt; n) return findMediaSortedArrays(nums2, nums1); }}; 时间复杂度 如一开始分析：时间复杂度：线性时间 \\(\\) 空间复杂度 额外申请了和一个链表，因此空间复杂度也为 \\(\\)","link":"/2019/12/03/Moris-Traversal-Binary-Tree/"},{"title":"Palindrome Paritioning III","text":"题目 Palindrome Partitioning III You are given a string s containing lowercase letters and an integer k. You need to : First, change some characters of s to other lowercase English letters. Then divide s into k non-empty disjoint substrings such that each substring is palindrome. Return the minimal number of characters that you need to change to divide the string. 1234567891011121314Example 1:Input: s = &quot;abc&quot;, k = 2Output: 1Explanation: You can split the string into &quot;ab&quot; and &quot;c&quot;, and change 1 character in &quot;ab&quot; to make it palindrome.Example 2:Input: s = &quot;aabbc&quot;, k = 3Output: 0Explanation: You can split the string into &quot;aa&quot;, &quot;bb&quot; and &quot;c&quot;, all of them are palindrome.Example 3:Input: s = &quot;leetcode&quot;, k = 8Output: 0 Constraints: 1 &lt;= k &lt;= s.length &lt;= 100. s only contains lowercase English letters. 解题报告 理解题意 给定字符串s，和整数k 改变s中的一些字符 将s划分问k个非空回文子串 求最小的更改字符的次数 强烈提示：字符串长度最长100 --&gt; 时间复杂度最多10^6 （也就是n^3） 理解例子 例子 1 S：abc K：2 结果：1 将S划分为两个部分：ab、c，修改ab中的一个字符即可变成回文 例子 2 S：aabbc K：3 结果：0 将S划分为：aa、bb、c，所有的都是回文，不需要更改。 思路 强烈提示：数据规模 -- 10^2，也就是说期望的时间复杂度为 n^3 or n^2 * k 计数问题，一般可以用动态规划解决。 题目要求k次划分，如何划分需要解决，使用动态规划一般和 k-1 有关系。 划分后，针对子串如何更换，也需要解决，并且求最小值。 所以就两个子问题：1. 如何划分。2.如何更换。 dp_[i][k],表示0...i的字符，进行k次划分的最小交换次数 划分 可以把划分想象成两个部分，左边和右边。 左边：是从 0...j 进行 k-1 次的划分。右边： 一次划分（）。 dp_[i][k] = min{dp_[i][k], dp_[j][k-1] + dp_change[j][i]} dp_change[j][i] 表示从j到i 的最小更换次数。 更改字符 如果划分确定后，如何更改字符就比较好确定了 回文字符串应该从中间开始构建，并且向两边拓展 如果前后两个字符相等(str[i] == str[j]): dp_change[i][j] = dp_change[i+1][j-1] 如果前后两个字符不等(str[i] != str[j]): dp_change[i][j] = 1 + dp_change[i+1][j-1] dp_change[i][j] = (str[i] != str[j]) + dp_change[i+1][j-1] 解决了以上两个问题，那完整的问题，就解决了 流程 异常判断 针对所有的位置，尝试所有的分割， 伪代码 1234int palindromePartition(string &amp;str, int k){} 代码 123456789class Solution {public: int findMediaSortedArrays(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2) { const int m = nums1.size(); const int n = nums2.size(); if (m &gt; n) return findMediaSortedArrays(nums2, nums1); }}; 时间复杂度 如一开始分析：时间复杂度：线性时间 \\(\\) 空间复杂度 额外申请了和一个链表，因此空间复杂度也为 \\(\\)","link":"/2019/12/04/ParlindromPartition-III/"},{"title":"Range Sum Query","text":"Range Sum Query Immutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. Example: 12345678Given nums = [-2, 0, 3, -5, 2, -1]sumRange(0, 2) -&gt; 1sumRange(2, 5) -&gt; -1sumRange(0, 5) -&gt; -3Note:You may assume that the array does not change.There are many calls to sumRange function. 思路 比较简单的 Range Sum Query，只要知道前缀和就可以计算出不变数组的任意区间的和。 代码 12345678910111213141516class NumArray {private: vector&lt;int&gt; v_;public: NumArray(vector&lt;int&gt;&amp; nums) { v_.push_back(nums[0]); for (int num:nums) { v_.push_back(v_.back() + num); } // O(n) } int sumRange(int i, int j) { return v_[j+1] - v_[i]; // O(1) }}; Range Sum Query 2D - Immutable Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2). Range Sum Query 2D The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8. Example: 1234567891011Given matrix = [ [3, 0, 1, 4, 2], [5, 6, 3, 2, 1], [1, 2, 0, 1, 5], [4, 1, 0, 1, 7], [1, 0, 3, 0, 5]]sumRegion(2, 1, 4, 3) -&gt; 8sumRegion(1, 1, 2, 2) -&gt; 11sumRegion(1, 2, 2, 4) -&gt; 12 Note: You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2. 思路 参考之前Range Sum Query 的思想，肯定是要提前计算出需要的数据，最后计算和相当于查表。 那么 2D 数组如何计算使用类似的思想呢 矩形区域的和相当于多个矩形区域进行叠加后减去重复计算的区域，如下图所示，小矩形区域可以看做三个以左上角（0，0）为顶点的矩形区域与大的矩形区域的操作后的结果 12345678910111213141516for a 2D array sum[row+1][col+1]sums[i+1][j+1] represents the sum of area from matrix[0][0] to matrix[i][j](notice: we add additional blank row sums[0][col+1]={0} and blank column sums[row+1][0]={0} to remove the edge case checking), so, we can have the following definition+-----+-+-------+ +--------+-----+ +-----+---------+ +-----+--------+| | | | | | | | | | | | || | | | | | | | | | | | |+-----+-+ | +--------+ | | | | +-----+ || | | | = | | + | | | - | |+-----+-+ | | | +-----+ | | || | | | | | | || | | | | | | |+---------------+ +--------------+ +---------------+ +--------------+ sums[i][j] = sums[i-1][j] + sums[i][j-1] - sums[i-1][j-1] + matrix[i-1][j-1] 因此使用同样的思路计算区域如下 123456789+---------------+ +--------------+ +---------------+ +--------------+ +--------------+| | | | | | | | | | | | | || (r1,c1) | | | | | | | | | | | | || +------+ | | | | | | | +---------+ | +---+ || | | | = | | | - | | | - | (r1,c2) | + | (r1,c1) || | | | | | | | | | | | | || +------+ | +---------+ | +---+ | | | | || (r2,c2)| | (r2,c2)| | (r2,c1) | | | | |+---------------+ +--------------+ +---------------+ +--------------+ +--------------+ 代码 12345678910111213141516171819class NumMatrix{private: vector&lt;vector&lt;int&gt;&gt; sum;public: NumMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) { const int m = matrix.size(); const int n = m &gt; 0 ? matrix[0].size() : 0; sum = vector&lt;vector&lt;int&gt;&gt;(m+1, vector&lt;int&gt;(n+1, 0)); for (int i = 0; i &lt;= m; i++) { for (int j = 0; j &lt;= n; j++) { sum[i][j] = sum[i-1][j-1] + sum[i][j-1] - sum[i-1][j-1] + matrix[i-1][j-1]; } } } int sumRegion(int row1, int col1, int row2, int col2) { return sums[row2+1][col2+1] - sums[row2+1][col1] - sums[row1][col2+1] + sums[row1][col1]; }}; Range Sum Query Mutable Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive. The update(i, val) function modifies nums by updating the element at index i to val. Example: 12345Given nums = [1, 3, 5]-sumRange(0, 2) -&gt; 9update(1, 2)sumRange(0, 2) -&gt; 8 Note: The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly. Fenwick Tree (Binary Index Tree) 树状数组，我们需要两个数组来存储，原始数组和 bit 数组 * 假定 i 为左子节点，那么其父节点的坐标为 (i + lowbit(i)) * 假定 i 为右子节点，那么其父节点的坐标为 (i - lowbit(i)) * update(int i, int delta) --&gt; 更新前缀和数组中每一个受影响前缀和，从 i 到 最后一个位置 O (n) * query(int) --&gt; 直接返回 idx + 1 的前缀和 O(1) * 求 i 到 j 的前缀和 就可用 query(j+1) - query(i) 来计算 * 求和的基本思想，给定要求和的位置 i，可以用二级制表示法来分段求和，以 13 为例 13 = 2^3 + 2 ^2 + 2 ^ 0; * 因此 prefixSum(13) = Range(1, 8) + Range(9, 12) + Range(13) // Range(i, j) 表示 i 到 j 的数字求和 * arr = [1, 7, 3, 0, 5, 8, 3, 2, 6, 2, 1, 1, 4, 5] prefixSum(13) = RANGE(1, 8) + RANGE(9, 12) + RANGE(13, 13) = 29 + 10 + 4 = 43 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class FenwickTree{private: vector&lt;int&gt; sum_; static inline lowbit(int x) { return x &amp; (-x); }public: FenwickTree(int n) : sum(n+1, 0) { } // 更新一个值，坐标 为 i，需要修改 bit 数组中涵盖了 原始数组 arr[i] 的值 --&gt; 下标 i 以及所有的父节点 void update(int i, int delta) { while (i &lt; sum.size()) { sum_[i] += delta; i += lowbit(i); } } // 区间求和，假定求 i --&gt; j 的数值之和，可以求 0 --&gt; i-1 , 0 --&gt; j，再相减 int query(int i) const { int sum = 0; while (i &gt; 0) { sum += sum_[i]; i -= lowbit(i); } return sum; } // 区间求和 和 更新数组 都是 O(logn)};class NumArray {private: vector&lt;int&gt; nums_; FenwickTree tree_;public: NumArray(vector&lt;int&gt; nums): nums_(move(nums)), tree_(nums.size()) { for (int i = 0; i &lt; nums_.size(); i++) { tree_.update(i+1, nums[i]); } } void update(int i, int val) { tree_.update(i, val - nums[i]); nums_[i] -= val; } int sumQuery(int i, int j) { return tree_.query(j+1) - tree_.query(i); }}; Segment Tree 12345678910111213141516171819class SegmentNode{private: int start; int end; int sum; SegmentNode *left; SegmentNode *right;public: SegmentNode(int start, int end, int sum, SegmentNode *left = nullptr, SegmentNode *right = nullptr): start(start), end(end), sum(sum), left(left), right(right); SegmentNode(const SegmentNode&amp;) = delete; SegmentNode&amp; operator=(const SegmentNode&amp;) = delete; ~SegmentNode() { delete left; delete right; left = right = nullptr; }};","link":"/2020/07/11/RangeSumQuery/"},{"title":"Single Number II","text":"题目 Single Number II Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one. Note: Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? Example 1: 12Input: [2,2,3,2]Output: 3 Example 2: 12Input: [0,1,0,1,0,1,99]Output: 99 解题报告 理解题意 给定一个数组，里面的元素均出现了 K(K &gt; 1) 次,出了一个元素出现 P(P&gt;=1 , P % K != 0) 次，让找到这个元素。 gi 思路 首先构建一个计数器，可以实现对 01 数组进行计数，每次遇见1 counter 自增，如果自增至 K，则 counter 重至为 0 123456def counter: for i in array: if i: count += 1 if counter == k: count = 0 那么什么位操作遇到 0 不变，遇到 1 自增，也就是资深取反（因为自增碰到 1 会变成 0） 对于某一位数字 0 或者 1 来讲： 碰到 0 不变的操作有两个： x = x | 0 另一个是 x = x ^ 0 但异或(XOR)操作明显更加合适: 1 ^ 1 = 0 , 0 ^ 1 = 1, 0 ^ 0 = 0 因此对于 counter 来讲， counter = counter ^ 1 但题目需要覆盖 K 位，那就是 2 ^ m &gt;= K，因此需要 最少 logk 个 因此 m 位从高到低为C[m], C[m-1],... C[1] 对于最低位 : C[1] = C[1] ^ i; 对于C[2]，只有前一位为 1 的时候才进位，C[2] = C[2] ^ (C[1] &amp; i) 对于C[k], 进位条件 i == 1 &amp;&amp; C[j] == 1 for all j &lt; k 1234567def update: for i in array: C[m] ^= (c[m-1] &amp; c[m-2] &amp; .... C[1] &amp; i) ... C[2] ^= C[1] &amp; i C[1] ^= i // 要从最高位开始更新 但更新策略还不完整，需要达到阈值的时候变成 0 因此需要一个 mask = 0 if counter == k else 1 于是每次更新的时候 C[i] &amp; mask 假设 k 的二进制形式为 k[m], k[m-1]...k[1] 那么 mask = ~(y1 &amp; y2 ... &amp; ym) where yj = cj if kj = 1 else yj = ~ cj 这样子的话当c == k时，yj全部等于1，mask值为0，而 c != k时，yj必不全为1，则mask值必为1. 1234567891011121314for i in array: c[m] ^= (c[m-1] &amp; c[m-2] &amp; ... &amp; c[1] &amp; i) ... c[2] ^= (c[1] &amp; i) c[1] ^= i # 注意要先从高位开始更新 for j in range(m): y[j] = c[j] if k[j] else ~c[j] mask = ~(y[1] &amp; y[2] ... &amp; y[m]) for j in range(m): c[m] &amp;= mask ... c[1] &amp;= mask 代码 12345678910c1 = 0c2 = 0m = 0for i in nums: c2 ^= c1 &amp; i c1 ^= i mask = ~(c1 &amp; c2) # k = 3, 二进制形式为11，则c1和c2都不用取反 c1 &amp;= mask c2 &amp;= maskreturn c1 # p = 1, 则最后c1 = single","link":"/2020/05/30/SingleNumberII/"},{"title":"SuperSign","text":"超级签名 证书类型 整数类型 使用场景 开发(Development)证书和描述文件 用于开发测试，在Xcode中打包后，可在真机环境调试、安装 发布(Distribution)证书和描述文件 * 发布(Distribution)证书和描述文件:用于提交Appstore，在Xcode中打包后，可使用Xcode、Application Loader提交到Appstore审核发布 证书作用 证书 文件后缀 文件类型 作用 Provisioning Profile .mobileprovision 描述文件 绑定设备UDID，所以在申请开发描述文件之前，先添加调试的设备。 Signing Certificate .cer/.p12 证书文件 有开发和发布的证书，可以在钥匙串查看安装的可用的证书，过期时间等。p12是一个加密的文件，只要知道其密码，就可以供给所有的 Mac 设备使用，是这个应用的唯一标识证书和开发者，用于对应 bundleID 的应用开发和打包测试 如果是团队开发，一般会生成 p12 给组员使用，方便管理证书 证书名字 类型 证书用途 adhocXXX.mobileprovision 描述文件 用于生成 adhoc 包时，描述可以安装ipa包的设备UDID和证书关系。（包含推送、apple pay等权限声明内容） devXXX.mobileprovision 描述文件 用于生成 dev 包时，描述可以安装ipa包的设备UDID和证书关系。（包含推送、apple pay等权限声明内容） devXXXPushXXX.p12 推送证书 用于 dev 包推送时，认证和关联 应用bundleID 的证书关系 devXXX.p12 开发证书 用于打包App时，生成 dev 的 ipa 包需要的开发者信息。 disXXX.mobileprovision 描述文件 用于生成 dis 包时，描述应用bundleID与证书的关系。（包含推送、apple pay等权限声明内容）。 disXXXPushXXX.p12 推送证书 用于 dis（或adhoc） 包推送时，认证和关联 应用bundleID 的证书关系。 disXXX.p12 发布证书 用于打包App时，生成 dis (或adhoc) 的 ipa 包需要的开发者信息。 证书类型的说明 用途 dev adhoc dis 企业证书 用于送审 F T T F 未越狱，未在证书中的设备能否安装 F F F T 未越狱，在证书中的设备能否安装 T T F T 越狱能否安装 T T T T 能否用于送审 TestFlight F F T F 不越狱能否打开应用的 Document 等 T F F F 如果需要添加新设备的 UDID，只要更新 .mobileprovision 描述文件既可以 如果证书过期，.p12 和 .mobileprovision 文件需要重新生成，如果 revoke后生成新的证书，旧的证书和证书对应的 ipa 不能再安装在设备上 描述文件保存在 macOS 路径： 1~/Library/MobileDevice/Provisioning\\ Profiles/ 查看安装的证书使用命令： 1security find-identity -p codesigning -v 获取 UDID 使用配置文件获取 123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt; &lt;dict&gt; &lt;key&gt;PayloadContent&lt;/key&gt; &lt;dict&gt; &lt;key&gt;URL&lt;/key&gt; &lt;string&gt;https://your.hostname/receive.php&lt;/string&gt; &lt;!--接收数据的接口地址--&gt; &lt;key&gt;DeviceAttributes&lt;/key&gt; &lt;array&gt; &lt;string&gt;UDID&lt;/string&gt; &lt;string&gt;IMEI&lt;/string&gt; &lt;string&gt;ICCID&lt;/string&gt; &lt;string&gt;VERSION&lt;/string&gt; &lt;string&gt;PRODUCT&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;key&gt;PayloadOrganization&lt;/key&gt; &lt;string&gt;your orignation name&lt;/string&gt; &lt;!--组织名称--&gt; &lt;key&gt;PayloadDisplayName&lt;/key&gt; &lt;string&gt;Obtain UDID&lt;/string&gt; &lt;!--安装时显示的标题--&gt; &lt;key&gt;PayloadVersion&lt;/key&gt; &lt;integer&gt;1&lt;/integer&gt; &lt;key&gt;PayloadUUID&lt;/key&gt; &lt;string&gt;3C4DC7D2-E475-3375-489C-0BB8D737A653&lt;/string&gt; &lt;!--自己随机填写的唯一字符串，生成的就可以--&gt; &lt;key&gt;PayloadIdentifier&lt;/key&gt; &lt;string&gt;your identifier&lt;/string&gt; &lt;key&gt;PayloadDescription&lt;/key&gt; &lt;string&gt;Obtaining UDID&lt;/string&gt; &lt;!--描述--&gt; &lt;key&gt;PayloadType&lt;/key&gt; &lt;string&gt;Profile Service&lt;/string&gt; &lt;/dict&gt;&lt;/plist&gt; 需要填写回调数据的 URL 和 PayloadUUID。该PayloadUUID仅仅是随机生成的唯一字符串,类似bundleid，一般是域名倒置，用来标识唯一。 mobileconfig中的URL要用https地址。否则 https://your.hostname/receive.php 会报ATS错误。 mobileconfig 文件签名 1security cms -S -N &quot;Apple Development: XXX&quot; -i udid.mobileconfig -o udid.signed.mobileconfig 这个地方使用自己的开发者账号就行，具体的内容打开keychain，我的账号是绑定在公司的 team 里面，就用它签名就行 receive.php 安装成功后，系统会自动回调 mobileconfig 中的地址 服务器端支持 ssl 这块在本地我用的 mamp pro 来搞的，比较傻瓜化 index.php 为了测试方便，就放了个按钮，指向旁边的 mobileconfig 文件 123&lt;div class=&quot;title-box&quot;&gt;&lt;a class=&quot;buttons&quot; href=&quot;udid.signed.mobileconfig&quot;target=&quot;_blank&quot;&gt;获取UDID&lt;/a&gt; receive.php 主要做的事情是解析上传的内容，并且跳转到新的页面 跳转是必须的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php$data = file_get_contents('php://input');$plistBegin = '&lt;?xml version=&quot;1.0&quot;';$plistEnd = '&lt;/plist&gt;';$pos1 = strpos($data, $plistBegin);$pos2 = strpos($data, $plistEnd);$data2 = substr ($data,$pos1,$pos2-$pos1);$xml = xml_parser_create();xml_parse_into_struct($xml, $data2, $vs);xml_parser_free($xml);$UDID = &quot;&quot;;$CHALLENGE = &quot;&quot;;$DEVICE_NAME = &quot;&quot;;$DEVICE_PRODUCT = &quot;&quot;;$DEVICE_VERSION = &quot;&quot;;$iterator = 0;$arrayCleaned = array();foreach($vs as $v){ if($v['level'] == 3 &amp;&amp; $v['type'] == 'complete'){ $arrayCleaned[]= $v; } $iterator++;}$data = &quot;&quot;;$iterator = 0;foreach($arrayCleaned as $elem){ $data .= &quot;\\n==&quot;.$elem['tag'].&quot; -&gt; &quot;.$elem['value'].&quot;&lt;br/&gt;&quot;; switch ($elem['value']) { case &quot;CHALLENGE&quot;: $CHALLENGE = $arrayCleaned[$iterator+1]['value']; break; case &quot;DEVICE_NAME&quot;: $DEVICE_NAME = $arrayCleaned[$iterator+1]['value']; break; case &quot;PRODUCT&quot;: $DEVICE_PRODUCT = $arrayCleaned[$iterator+1]['value']; break; case &quot;UDID&quot;: $UDID = $arrayCleaned[$iterator+1]['value']; break; case &quot;VERSION&quot;: $DEVICE_VERSION = $arrayCleaned[$iterator+1]['value']; break; } $iterator++;}$params = &quot;UDID=&quot;.$UDID.&quot;&amp;CHALLENGE=&quot;.$CHALLENGE.&quot;&amp;DEVICE_NAME=&quot;.$DEVICE_NAME.&quot;&amp;DEVICE_PR ODUCT=&quot;.$DEVICE_PRODUCT.&quot;&amp;DEVICE_VERSION=&quot;.$DEVICE_VERSION;header('HTTP/1.1 301 Moved Permanently');header(&quot;Location: https://your.hostname/receive.php?&quot;.$params);?&gt; 前期工作准备好之后 如下是在手机端的截图，能看到 mobileconfig 是签名过的，并且还有回调地址。 * mobileconfig 文件下载显示已签名 INSTALL_PROFILE.PNG 查看签名信息 OBTAIN_UDID.PNG 安装成功后，系统会自动的访问 mobileconfig 中的地址，返回数据 RESIGN.PNG 使用 fastlane 对 ipa 进行重签名 安装 fastlane 安装 ruby 由于系统自带 ruby，因此安装任何包需要 root 权限，为了防止更新系统导致兼容性等问题，故全新安装 ruby，将 local 和 system 的 ruby 隔离 1brew install ruby 并且根据提示将 ruby 加入到 path 中 1export PATH=&quot;/usr/local/opt/ruby/bin:$PATH&quot; 安装 fastlane 以及依赖 12gem install prygem install fastlane 测试安装是否正确 尝试拉取一下 1234567891011require &quot;spaceship&quot;Spaceship.login('your_developerapple_id','your_pass_word')Spaceship.certificate.all.each do |cert| cert_type = Spaceship::Portal::Certificate::CERTIFICATE_TYPE_IDS[cert.type_display_id].to_s.split(&quot;::&quot;)[-1] puts &quot;Cert id: #{cert.id}, name: #{cert.name}, expires: #{cert.expires.strftime(&quot;%Y-%m-%d&quot;)}, type: #{cert_type}&quot;endall_devices = Spaceship::Portal.device.all.each do |device| puts &quot;device id: #{device.id}, name: #{device.name}, udid: #{device.udid}&quot;end 结果如下，只截取关键部分 12345Cert id: XXXXXX, name: Development, expires: 2021-01-15, type: AppleDevelopment.....// 另外还有 device 列表device id: XXXX, name: bbbb, udid: XXXXXXXX 将获取到的 UDID 加入到设备列表中 需要将获取到的 UDID 加入到 team 的设备列表里面，才能够将重签名的 ipa 下发给需要的设备安装使用。 如下的代码从文件中读取上传来的 UDID 和设备名称，加入到所有的 ad_hoc 的描述文件中 123456789101112131415161718file = File.open(&quot;devices-udid-name-ios.txt&quot;) #文本文件里录入的udid和设备名用tab分隔 file.each do |line| arr = line.strip.split(&quot; &quot;) device = Spaceship.device.create!(name: arr[1], udid: arr[0]) puts &quot;add device: #{device.name} #{device.udid} #{device.model}&quot; end devices = Spaceship.device.all profiles = Array.new profiles += Spaceship.provisioning_profile.development.all profiles += Spaceship.provisioning_profile.ad_hoc.all profiles.each do |p| puts &quot;Updating #{p.name}&quot; p.devices = devices p.update! end 运行结果能看到 12Updating Test01Updating adHocResign 已经将获取到的 UDID 加到 ad_hoc 中 provision 位置 如果需要查看系统中已经保存的描述文件： 1~/Library/MobileDevice/Provisioning\\ Profiles/ 签名 1fastlane sigh resign your.ipa --signing_identity 'iPhone Distribution: XXXX' -p your.mobileprovision 使用 Linux 对 ipa 进行签名 zsign GitHub - zhlynn/zsign: Maybe is the most quickly codesign alternative for iOS12+ in the world, cross-platform ( Linux &amp; macOS ), more features. sign! 从介绍看只需要提供 p12 文件和 provisioning profile 即可完成签名 生成 p12 安装 openssl 1brew install openssl 生成 csr 文件 12openssl genrsa -out ios_distribution.key 2048openssl req -new -key ios_distribution.key -out ios_distribution.csr -subj '/emailAddress=me@example.com, CN=Example, C=US' 将生成的文件上传到开发者网站创建 Provisioning Profile 下载生成好的文件（证书）生成 PEM 文件 1openssl x509 -inform der -in ios_distribution.cer -outform PEM -out ios_distribution.pem 下载根证书并且转为 PEM 文件 12wget http://developer.apple.com/certificationauthority/AppleWWDRCA.ceropenssl x509 -in AppleWWDRCA.cer -inform DER -out AppleWWDRCA.pem -outform PEM 导出P12 1openssl pkcs12 -export -out ios_distribution.p12 -inkey ios_distribution.key -in ios_distribution.pem -certfile AppleWWDRCA.pem 安装 zsign 1g++ *.cpp common/*.cpp -lcrypto -I/usr/local/Cellar/openssl@1.1/1.1.1f/include -L/usr/local/Cellar/openssl@1.1/1.1.1f/lib -O3 -o zsign 注意指定头文件和库文件 使用 zsign 签名 1234567891011121314151617181920Usage: zsign [-options] [-k privkey.pem] [-m dev.prov] [-o output.ipa] file|folderoptions:-k, --pkey Path to private key or p12 file. (PEM or DER format)-m, --prov Path to mobile provisioning profile.-c, --cert Path to certificate file. (PEM or DER format)-d, --debug Generate debug output files. (.zsign_debug folder)-f, --force Force sign without cache when signing folder.-o, --output Path to output ipa file.-p, --password Password for private key or p12 file.-b, --bundleid New bundle id to change.-n, --bundlename New bundle name to change.-e, --entitlements New entitlements to change.-z, --ziplevel Compressed level when output the ipa file. (0-9)-l, --dylib Path to inject dylib file.-w, --weak Inject dylib as LC_LOAD_WEAK_DYLIB.-i, --install Install ipa file using ideviceinstaller command for test.-q, --quiet Quiet operation.-v, --version Show version.-h, --help Show help. 123456789101112131415161718192021222324252627282930/usr/local/bin/zsign -f -k ios_distribution.p12 -p 123456 -m adHocResign.mobileprovision -b 'com.your.package.BundleId' -n 'your.app.name' -o your.ipa -z 9 your.signed.ipa&gt;&gt;&gt; Unzip: your..ipa (21.26 MB) -&gt; /tmp/zsign_folder_1586264064122616 ...&gt;&gt;&gt; Unzip OK! (0.318s, 317925us)&gt;&gt;&gt; BundleId: your.bundle.id -&gt; your.new.bundle.id&gt;&gt;&gt; BundleName: -&gt; ToTok&gt;&gt;&gt; Signing: /tmp/zsign_folder_1586264064122616/Payload/your.app ...&gt;&gt;&gt; AppName: your.app.name&gt;&gt;&gt; BundleId: com.your.package.BundleId&gt;&gt;&gt; TeamId: XXXXXXX&gt;&gt;&gt; SubjectCN: Apple Distribution: XXXXXXX&gt;&gt;&gt; ReadCache: NO&gt;&gt;&gt; SignFile: libswiftRemoteMirror.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftCoreImage.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftObjectiveC.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftCore.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftCoreGraphics.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftUIKit.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftMetal.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftDispatch.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftos.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftCoreFoundation.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftDarwin.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftQuartzCore.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftFoundation.dylib&gt;&gt;&gt; SignFile: Frameworks/libswiftSwiftOnoneSupport.dylib&gt;&gt;&gt; SignFolder: your.singed.app, (your.app.name)&gt;&gt;&gt; Signed OK! (0.746s, 745663us)&gt;&gt;&gt; Archiving: your.singed.appipa ...&gt;&gt;&gt; Archive OK! (21.23 MB) (2.342s, 2341848us)&gt;&gt;&gt; Done. (3.422s, 3421883us) 安装成功，并且可以正常打开 超级签名脚本 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199require 'docopt'require 'spaceship'require 'pathname'doc = &lt;&lt;DOCOPTUsage: #{__FILE__} --apple_id=&lt;apple_id&gt; --password=&lt;password&gt; --bundle_id=&lt;bundle_id&gt; --input_ipa=&lt;input_ipa&gt; #{__FILE__} --help | -h #{__FILE__} --input_file=&lt;file_name&gt;DOCOPTbegin args = Docopt::docopt(doc)rescue Docopt::Exit =&gt; e puts e.message exitend# args.each do |key, value|# case key# when &quot;--apple_id&quot; then## end# # puts key# # puts value# endclass DevelopPortalHandle def initialize(userName, passwd, bundleID) puts(&quot; &quot;) puts (&quot;====== initialize ======&quot;) @userName = userName @bundleID = bundleID @passwd = passwd list = bundleID.split(&quot;.&quot;) appidLastName = list.last @appName = appidLastName @provisionName = appidLastName end def login() puts(&quot; &quot;) puts (&quot;====== login ======&quot;) Spaceship::Portal.login(@userName,@passwd) Spaceship::Portal.select_team # 让用户可以选择 team # Spaceship.client.team_id = &quot;这里输入TeamId&quot; end def allApp() puts(&quot; &quot;) puts (&quot;====== allApp ======&quot;) Spaceship::Portal.app.all.collect do |app| puts &quot;app.name: #{app.name}, app id #{app.app_id}, bundle id :#{app.bundle_id}&quot; end end def createApp() puts(&quot; &quot;) puts (&quot;====== createApp ======&quot;) puts &quot;createApp find: bundle id = #{@bundleID} appName = #{@appName}&quot; app = Spaceship::Portal.app.find(@bundleID) if !app then puts(&quot;can't find #{@bundleID} create a new one&quot;) app = Spaceship::Portal.app.create!(bundle_id: @bundleID, name: @appName) puts &quot;createApp #{app}&quot; end end def createDistributionProvision(provisioningClass) puts(&quot; &quot;) puts (&quot;====== createDistributionProvision ======&quot;) cert = Spaceship::Portal.certificate.production.all.last provisionNameDis = @provisionName + '_dis' profile = provisioningClass.create!(bundle_id: @bundleID,certificate:cert,name:@provisionName) return profile end def downloadDistributionProvision(provisioningClass) puts(&quot; &quot;) puts (&quot;====== downloadDistributionProvision ======&quot;) filtered_profiles = provisioningClass.find_by_bundle_id(bundle_id: @bundleID) profile = nil if 0 &lt; filtered_profiles.length then profile = filtered_profiles[0] elsif 0 == filtered_profiles.length then profile = createProvision(provisioningClass) end provisionNameDis = @provisionName + '_dis' provisionFileName = provisionNameDis + '.mobileprovision' File.write(provisionFileName, profile.download) return provisionFileName end def downloadAdHocProvision() puts(&quot; &quot;) puts (&quot;====== downloadAdHocProvision ======&quot;) filtered_profiles = Spaceship::Portal.provisioning_profile.ad_hoc.find_by_bundle_id(bundle_id: @bundleID) profile = nil if 0 &lt; filtered_profiles.length then puts (&quot;#{@bundleID}'s provisioning profile exist&quot;) profile = filtered_profiles[0] elsif 0 == filtered_profiles.length then puts (&quot;createProvision&quot;) profile = createProvision(provisioningClass) end provisionNameAdHoc = @provisionName + '_adhoc' provisionFileName = provisionNameAdHoc + '.mobileprovision' absolutePath = Pathname.new(File.dirname(__FILE__)).realpath.to_s &lt;&lt; &quot;/&quot; &lt;&lt; provisionFileName puts(&quot;absolutePath = #{absolutePath};&quot;) File.write(absolutePath, profile.download) return absolutePath end def createDevelopProvision() puts(&quot; &quot;) puts (&quot;====== createDevelopProvision ======&quot;) dev_certs = Spaceship::Portal.certificate.development.all all_devices = Spaceship::Portal.device.all provisionNameDev = @provisionName + '_dev' profile = Spaceship::Portal.provisioning_profile.development.create!(bundle_id: @bundleID,certificate: dev_certs,name: provisionNameDev,devices:all_devices) return profile end def downloadDevelopProvision() puts(&quot; &quot;) puts (&quot;====== downloadDevelopProvision ======&quot;) filtered_profiles = Spaceship::Portal.provisioning_profile.development.find_by_bundle_id(bundle_id: @bundleID) profile = nil if 0 &lt; filtered_profiles.length then profile = filtered_profiles[0] elsif 0 == filtered_profiles.length then profile = createDevelopProvision() end provisionNameDev = @provisionName + '_dev' provisionFileName = provisionNameDev + '.mobileprovision' File.write(provisionFileName, profile.download) return provisionFileName end def addServices(appServiceObj) puts(&quot; &quot;) puts (&quot;====== addServices ======&quot;) puts(&quot; add #{appServiceObj}&quot;) app = Spaceship::Portal.app.find(@bundleID) app.update_service(appServiceObj) end def addDevices(fileName) puts(&quot; &quot;) puts (&quot;====== addDevices ======&quot;) file = File.open(fileName) file.each do |line| arr = line.strip.split(&quot; &quot;) device = Spaceship.device.create!(name: arr[1], udid: arr[0]) puts &quot;add device: name = #{device.name}; udid = #{device.udid}; model = #{device.model}&quot; end puts (&quot;====== addDevices-updateAdHoc ======&quot;) profiles = Array.new profiles += Spaceship.provisioning_profile.ad_hoc.all devices = Spaceship.device.all profiles.each do |p| puts &quot;Updating #{p.name}&quot; p.devices = devices p.update! end end def resign(provisionFile,inputIpa) puts(&quot; &quot;) puts (&quot;====== resign ======&quot;) resignCmd = &quot;/usr/local/bin/zsign -f -k adHoc_resign.p12 -p 123456&quot; resignCmd &lt;&lt; &quot; -m &quot; &lt;&lt; provisionFile resignCmd &lt;&lt; &quot; -b &quot; &lt;&lt; &quot;'#{@bundleID}'&quot; resignCmd &lt;&lt; &quot; -n 'ToTok'&quot; resignCmd &lt;&lt; &quot; -o ToTok_AD_HOC_signed.ipa&quot; resignCmd &lt;&lt; &quot; -z 9&quot; resignCmd &lt;&lt; &quot; &quot; &lt;&lt; inputIpa puts (&quot;resign cmd = #{resignCmd};&quot;) exec(resignCmd) endendhandle = DevelopPortalHandle.new(args['--apple_id'], args['--password'], args['--bundle_id'])handle.login()handle.createApp()handle.addDevices(&quot;udid.txt&quot;)handle.addServices(Spaceship::Portal.app_service.push_notification.on)provisionPath = handle.downloadAdHocProvision()handle.resign(provisionPath, args['--input_ipa']) 脚本运行 1ruby resignIPAWithUDID.rb --apple_id=your.apple.id --password=your.password --bundle_id=your.bundle.id --input_ipa=your.signed.ipa Trouble shooting ruby 脚本不能执行 因为在服务器端执行的 ruby 脚本的用户和我测试用的用户不是同一个用户，因此 ruby 的环境不一样，尤其是 gem 解决办法： 将 ruby 脚本封装成 shell 脚本，并且在执行 shell 脚本的时候重新制定 ruby 环境 123export GEM_HOME='/home/www/.rvm/gems/ruby-2.3.0';export GEM_PATH='/home/www/.rvm/gems/ruby-2.3.0:/home/www/.rvm/gems/ruby-2.3.0@global';export MY_RUBY_HOME='/home/www/.rvm/rubies/ruby-2.3.0'; 换了用户会弹出两步验证 参考文档： Continuous Integration - fastlane docs 生成 fastlane session 1fastlane spaceauth -u user@email.com 将生成的内容放到脚本里 1export FASTLANE_SESSION='XXXXXX\\n' 访问重签名页面调用脚本即可","link":"/2020/04/17/SuperSign/"},{"title":"SweepLine","text":"起因 今天做了一道题，LeetCode 560. Subarray Sum Equals K，有点蒙蔽，看了答案发现比较简单，记录一下 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 12345678示例 1 :输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。说明 :数组的长度为 [1, 20,000]。数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 题解 题目的意思比较明确，要求找到 n 个连续的子数组，并且这些连续子数组的和为 k 子数组求和 子数组求和可以使用前缀和，那么如何知道它能够满足需求? 前缀和可以知道具体区间的和，那么区间终点的值 -k，就是这段区间的起点。 需要一个哈希表，来记录上次出现该值得地方，找到 cur-k 就是找到了和位 k 的区间起点。 12345678910111213141516class Solution {public: int subArraySum(vector&lt;int&gt; &amp;nums, int k) { int ans = 0, pre = 0; unordered_map&lt;int, int&gt; memo_; memo_[0] = 1; for (const auto &amp;num : nums) { pre += num; if (memo_.find(pre - k) != memo_.end()) { ans += memo_[pre - k]; } memo_[pre]++; } return ans; }};","link":"/2020/09/22/SweepLine/"},{"title":"Swift-Algorithm-Stack","text":"题目 TwoSum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 解题报告 理解题意 整形数组 nums 是否有序未知 \\(=- | idx1 idx2\\) 一定有解 同样元素不能用两次 理解例子 nums = [2, 7, 11, 15] target = 9 对于 idx = 0. nums[idx] = 2 需要找到 nums[idx2] = target - nums[idx] --&gt; 7 nums[idx2] = 7 idx2 = 1 [0, 1] 思路 例子中，找到 target-nums[idx] 并不够，还要找到 target-nums[idx] 对应的index 因此需要建立 index 和 value 的关系 关系建立好之后 对于每一个元素 idx ，查找 target-nums[idx] 以及对应的index 找到就返回结果，未找到返回空 出入参合法性判断 需要的数据结构： unordered_map&lt;int,int&gt; 哈希表，分别存放 value,index 代码 123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { if(nums.empty()) return {}; unordered_map&lt;int,int&gt; map_; for (int i = 0; i &lt; nums.size(); i++) { if (!map_.count(nums[i])) { map_[nums[i]] = i; } int num_to_find = target-nums[i]; if (map_.count(num_to_find) &amp;&amp; map_[num_to_find] != i) { return {i, map_[num_to_find]}; } } return {}; }}; 时间复杂度 每个元素只遍历一次，因此是线性时间 \\(\\) 空间复杂度 额外申请了和数组长度一样的哈希表，因此空间复杂度也为 \\(\\)","link":"/2019/11/22/SwiftAlgorithm-Stack/"},{"title":"TwoSum","text":"题目 TwoSum Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example: 1234Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 解题报告 理解题意 整形数组 nums 是否有序未知 \\(=- | idx1 idx2\\) 一定有解 同样元素不能用两次 理解例子 nums = [2, 7, 11, 15] target = 9 对于 idx = 0. nums[idx] = 2 需要找到 nums[idx2] = target - nums[idx] --&gt; 7 nums[idx2] = 7 idx2 = 1 [0, 1] 思路 例子中，找到 target-nums[idx] 并不够，还要找到 target-nums[idx] 对应的index 因此需要建立 index 和 value 的关系 关系建立好之后 对于每一个元素 idx ，查找 target-nums[idx] 以及对应的index 找到就返回结果，未找到返回空 出入参合法性判断 需要的数据结构： unordered_map&lt;int,int&gt; 哈希表，分别存放 value,index 代码 123456789101112131415161718class Solution {public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { if(nums.empty()) return {}; unordered_map&lt;int,int&gt; map_; for (int i = 0; i &lt; nums.size(); i++) { if (!map_.count(nums[i])) { map_[nums[i]] = i; } int num_to_find = target-nums[i]; if (map_.count(num_to_find) &amp;&amp; map_[num_to_find] != i) { return {i, map_[num_to_find]}; } } return {}; }}; 123456789101112class Solution { func twoSum(_ nums: [Int], _ target: Int) -&gt; [Int] { var dict = [Int:Int]() for (i, num) in nums.enumerated() { if let lastIdx = dict[target - num] { return [lastIdx, i] } dict[num] = i } return [] }} 时间复杂度 每个元素只遍历一次，因此是线性时间 \\(\\) 空间复杂度 额外申请了和数组长度一样的哈希表，因此空间复杂度也为 \\(\\)","link":"/2019/11/22/TwoSum/"},{"title":"UpperBound","text":"UpperBound Upper Bound 是使用二分查找的办法求 大于 i 的第一个位置 代码 12345678910111213141516class Solution {public: int upperBound(vector&lt;int&gt;&amp; nums, int i) { int l = 0, r = nums.size(); while (l &lt; r) { int mid = (l + r) / 2; if (nums[mid] &gt; i) { r = mid; } else { l = mid + 1; } } return l; }}; 时间复杂度 O (logn) 空间复杂度 O(1)","link":"/2020/04/25/UpperBound/"},{"title":"VIPER架构落地IM","text":"问题由来 来新公司也大半年了，发现之前的工程实现的非常不合理，维护成本极高，内部吐槽严重，BUG 叠 BUG，修老 BUG 引入的新 BUG 层出不穷，质量堪忧。 Pros &amp; Cons 拿到代码后简单的看了一下: 使用 MVC 模式，并且由于各种原因，说白了就是写的挫。将 MCV(Model-View-Controller) 写成了 MVC(Massive View Controller) View Controller 写的极为笨重，几乎流程都写在几个比较大的 View Controller 中。牵一发而动全身，能不出错么。 目前的时机比较不错，新项目要开始了，及得想办法复用之前的逻辑，又得写的没什么问题。 很久不写这种流程了，还是需要仔细的回归练习一下，而且还能练练 swift，何乐而不为呢 VIPER 结构简介 VIPER 是视图 (View)，交互器 (Interactor)，展示器 (Presenter)，实体 (Entity) 以及路由 (Routing) 的首字母缩写。这样根据逻辑结构的不同可以划分为不同的责任层。使得依赖更容易隔离，比如说数据库，也更容易单独测试，边界清晰。 他们的关系大概是这样的 如下图所示： VIPER 为什么要用 VIPER 互联网企业都要求快速迭代，要求周期短，质量高。如何快速的在满足需求的前提下下交付质量好的产品，是大家都想解决的问题。对于一个处于一线的程序员来讲，从根上推动整个流程的变化是不切实际的。比较稳妥且的办法是采用技术手段来提高自己的效率，降低出错的概率。 对于源源不断的需求，以及不断的需求变化。除了默默的问候这些 PM，不还是得一个字一个字的敲出来。做的不好，大家会怀疑你的能力。面子上挂不住。活那么多，身体抗不住，身为一个快乐的程序员，在减少秃头的情况下得想办法让自己轻松点嘛。 步入正题 VIPER 的好处就是模块之前关系比较松散，模块划分清晰，几乎做到了彻底解耦。每个（VIPER）子模块都可以单独的测试， 避免掉了 MVC -&gt; M(assive)VC 的情况，VC 里面几乎就是个接口调用，几乎就是完成业务流程的胶水代码，而且都是 Protocol 的接口，业务比较清晰。 数据模型的处理，单独的放到了 Interactor 内部，这一块对于其他模块几乎是透明。 VC 彻底细化为View 和 Presenter，三者的交互可以参考 MVP 模式，不多说。 Router 作为业务的入口和跳转的枢纽，将跳转逻辑也吃掉了。 最终 VIPER 化之后，代码量会变多、文件会变多，逻辑变得清晰可维护。 不同的 VIPER 模块 通信只有两个途径，一个是通过 ROUTER，另一个是通过 INTERACTOR 开始落地 设计图 VIPER 模板 每次手工新建五个文件着实比较蛋疼，那么使用 XCode 模板每次自动新建不是很爽。链接就是新建好的模板。方便省事，目前只有 Mac 版本，改吧改吧 iOS 版本也不是啥难事 以聊天页为例 VIPER 落地 从图中可以看到该页面比较简单，聊天页面大概分两个部分，左边应该是 thread 列表，右边是 消息流。 窗体的样式几乎都是自定义的。 顶部存在多 TAB，方便切换不同的显示内容。 由于是 IM，那就存在登陆和非登陆，因此需要目前两个 VIPER 模块。 从设计来看，各种 UI 组件都需要自定义，因此需要提供一个 UI 基础组件库，给工程提供子弹。吃掉 UI 的内部细节。只要对外提供行为即可。 登陆 VIPER 结构 登陆需要简单的输入用户名和密码，然后呢对于登陆成功的状况，会有账户维护和消息同步。 设计有要求在登录页内部玩各种花活。因此目前沟通后，登录页划分为登陆输入页，和登陆行为页，两个页面的逻辑和流程不大一样。 登陆输入页的协议定义如下 1234567891011121314151617181920// MARK: Wireframe - 这块 Wireframe 就是 ROUTERprotocol AZLoginMainWireframeProtocol: class {}// MARK: Presenter -protocol AZLoginMainViewPresenterProtocol: class { // 目前只有注册的行为，因此定义好接口供 VC 使用 func startRegistration()}// MARK: Interactor -protocol AZLoginMainInteractorProtocol: class { var presenter: AZLoginMainViewPresenterProtocol? { get set } //给 PRESENTER 提供的接口，真正的注册行为是在 INTERACTOR 中发生的 func startRegistration()}// MARK: View -protocol AZLoginMainViewProtocol: class { var presenter: AZLoginMainViewPresenterProtocol? { get set }} 登陆页 登陆行为页 12345678910111213141516171819202122232425262728// MARK: Wireframe -protocol AZLoginActionWireframeProtocol: class { //根据业务需要，这块有可能需要直接的显示到主界面 func showMainWindow()}// MARK: Presenter -protocol AZLoginActionPresenterProtocol: class { // 给 VC 提供的接口可以注册和忘记密码，并且在登陆成功后可以有接口给 INTERACTOR 调用(finish) func login(email: String?, password: String?) func finished(login error: AZError?) func forgetPassword()}// MARK: Interactor -protocol AZLoginActionInteractorProtocol: class { var presenter: AZLoginActionPresenterProtocol? { get set } // 真正的接口，具体的行为是在 INTERACTOR 中发生的， func login(email: String?, password: String?) func forgetPassword()}// MARK: View -protocol AZLoginActionViewProtocol: class { var presenter: AZLoginActionPresenterProtocol? { get set } // 更新 View 的接口 func loginError(_ error: AZError) func closeWindow()} 一个简单的功能，写了这么多是不是很蛋疼，明明只需要一个 VC 就可以搞定的事情，非得这么麻烦么？ 其实在真正实现之后，发现除了文件多点以为，登陆的逻辑和流程非常清晰，真正地做到了代码自解释，不同结构之间通过接口来实现交互。将与其他模块无关的功能对外隐藏,而且真正的收益是在整个工程的逻辑和功能变得越来越复杂之后才体现出来。 聊天 VIPER 登陆成功后，界面会由登陆 VIPER 模块路由到主界面 VIPER，如下图，那么界面就可以正常的切换过来了 路由切换 搭建几个重要 VIPER 子结构 通过分析具体的业务流程和要完成的功能 不断地补充接口，篇幅问题，省略掉大部分细节，以切换 tab 为例。 123456789101112131415161718192021222324252627// MARK: Wireframe -protocol AZMainWindowWireframeProtocol: class { //...}// MARK: Presenter -protocol AZMainWindowPresenterProtocol: class { var router: AZMainWindowWireframeProtocol { get } //... func switchMainWindowTabContent(_ userInfo: [AnyHashable: Any]) //...}// MARK: Interactor -protocol AZMainWindowInteractorProtocol: class { var presenter: AZMainWindowPresenterProtocol? { get set } //... func swithMainWindowTab(_ tab: AZTitlebarTag) //...}// MARK: View -protocol AZMainWindowViewProtocol: class { var presenter: AZMainWindowPresenterProtocol? { get set } //... func switchMainWindowTabContent(_ userInfo: [AnyHashable: Any]) //...} 随着功能的逐渐叠加，VIPER 中不同的子结构的代码增加都很平稳，不会出现某一个模块代码量指数级的增加。 从前任写完的第一个版本的 bug 叠 bug，到这个版本的内部备受好评，其实基础功能都一致，只不过是界面看上去有着巨大的差别。但是从结果来看维护成本和收益都很不错，但实际上改变的是整个项目的基础结构，开发流程，并且带动了大家往着更合理的方向前进 。 从这个过程中，内部总结出了，代码规范，提交规范，开发规范，这么看来，每个人都应该有着不少的收获.","link":"/2025/01/15/VIPER%E6%9E%B6%E6%9E%84%E8%90%BD%E5%9C%B0%E5%88%B0IM/"},{"title":"VSCode C++ 配置","text":"配置 经常用 VSCode 来开发 C++，但是调试和配置每次都很头疼，现记录一下配置，备忘 tasks.json 1234567891011121314151617181920212223242526272829{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;clang++ build active file&quot;, &quot;command&quot;: &quot;/usr/bin/clang++&quot;, &quot;args&quot;: [ &quot;-std=c++17&quot;, &quot;-stdlib=libc++&quot;, &quot;-g&quot;, // &quot;${workspaceFolder}/*.cpp&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}/${fileBasenameNoExtension}&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;${workspaceFolder}&quot; }, &quot;problemMatcher&quot;: [&quot;$gcc&quot;], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true }, } ] } launch.json build and debug 12345678910111213141516171819202122232425{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;C++ - Build and debug active file&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: true, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;lldb&quot;, &quot;preLaunchTask&quot;: &quot;clang++ build active file&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ], } ]} c_cpp_cofiguration.json 123456789101112131415161718{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Mac&quot;, &quot;includePath&quot;: [&quot;${workspaceFolder}/**&quot;, &quot;/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/&quot;], &quot;defines&quot;: [], &quot;macFrameworkPath&quot;: [ &quot;/System/Library/Frameworks&quot;, &quot;/Library/Frameworks&quot; ], &quot;compilerPath&quot;: &quot;/usr/bin/clang&quot;, &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;c++17&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot; } ], &quot;version&quot;: 4 }","link":"/2020/10/03/VSCode-C/"},{"title":"Weakly Contest 169","text":"题目 Weakly Contest 169 ### 题目一 5295. Find N Unique Integers Sum up to Zero Given an integer n, return any array containing n unique integers such that they add up to 0. Example 1: 123Input: n = 5Output: [-7,-1,1,3,4]Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4]. Example 2: 12345678910Input: n = 3Output: [-1,0,1]Example 3:Input: n = 1Output: [0]Constraints:1 &lt;= n &lt;= 1000 解题报告 理解题意 这是一道简单题 给定一个数，求数组 要求数组的所有元素和位0 思路 给的数有可能为奇数、也有可能为偶数 如果是奇数：从0开始向左右拓展，最后加上0即可 如果为偶数：从0开始向左右拓展 代码 123456789101112class Solution {public: vector&lt;int&gt; sumZero(int n) { vector&lt;int&gt; ans; if (n % 2 != 0) ans.push_back(0); for (int i = 1; i &lt;= n / 2; i++) { ans.push_back(i); ans.push_back(-i); } return ans; }}; 题目二 5296. All Elements in Two Binary Search Trees My SubmissionsBack to Contest Given two binary search trees root1 and root2. Return a list containing all the integers from both trees sorted in ascending order. Example 1: 12345678910111213141516171819202122232425Input: root1 = [2,1,4], root2 = [1,0,3]Output: [0,1,1,2,3,4]Example 2:Input: root1 = [0,-10,10], root2 = [5,1,7,0,2]Output: [-10,0,0,1,2,5,7,10]Example 3:Input: root1 = [], root2 = [5,1,7,0,2]Output: [0,1,2,5,7]Example 4:Input: root1 = [0,-10,10], root2 = []Output: [-10,0,10]Example 5:Input: root1 = [1,null,8], root2 = [8,1]Output: [1,1,8,8]Constraints:Each tree has at most 5000 nodes.Each node's value is between [-10^5, 10^5]. 解题报告 理解题意 这是一道中档难度题 给定两个二叉排序树，要求返回一个包含所有元素并且是递增顺序的列表 思路 给定的两个二叉搜索树有可能为空 二叉搜索树中序遍历即为递增排序 遍历两个二叉搜索树，然后对归并排序，时间复杂度为 \\(\\) 代码 123456789101112131415161718class Solution {public: vector&lt;int&gt; getAllElements(TreeNode* root1, TreeNode* root2) { function&lt;void(TreeNode*, vector&lt;int&gt;&amp;)&gt; inorder = [&amp;](TreeNode* root, vector&lt;int&gt;&amp; t) { if (!root) return; inorder(root-&gt;left, t); t.push_back(root-&gt;val); inorder(root-&gt;right, t); }; vector&lt;int&gt; t1; vector&lt;int&gt; t2; inorder(root1, t1); inorder(root2, t2); vector&lt;int&gt; m; std::merge(begin(t1), end(t1), begin(t2),end(t2), std::back_inserter(m)); return m; }};","link":"/2019/12/29/Weakly-Contest-169/"},{"title":"Wild Card Matching","text":"题目 Wild Card Matchin Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'. '?' Matches any single character. '*' Matches any sequence of characters (including the empty sequence). The matching should cover the entire input string (not partial). Note: s could be empty and contains only lowercase letters a-z. p could be empty and contains only lowercase letters a-z, and characters like ? or *. Example 1: 12345Input:s = &quot;aa&quot;p = &quot;a&quot;Output: falseExplanation: &quot;a&quot; does not match the entire string &quot;aa&quot;. Example 2: 12345Input:s = &quot;aa&quot;p = &quot;*&quot;Output: trueExplanation: '*' matches any sequence. Example 3: 12345Input:s = &quot;cb&quot;p = &quot;?a&quot;Output: falseExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'. Example 4: 12345Input:s = &quot;adceb&quot;p = &quot;*a*b&quot;Output: trueExplanation: The first '*' matches the empty sequence, while the second '*' matches the substring &quot;dce&quot;. Example 5: 1234Input:s = &quot;acdcb&quot;p = &quot;a*c?b&quot;Output: false 解题报告 理解题意 2 个 字符串，长度可能不相等，一个输入字符串，一个是模式字符串 ? 表示匹配任意单一字符串 * 表示匹配任意字符串序列（包含空字符串） 对完整的输入字符串匹配 输入的还有：小写字母 或者空字符 理解例子 aa 与 a ，单独的 a 不能完整匹配 aa aa 与 * ，* 可以匹配任意字符串 cb 与 ?a, 从后往前看 a 和 b 并不匹配 abceb 与 *a*b 如下图 acdcb 与 a*c?b 如下图 思路 碰到字符且模式串也是字符，直接比较就行 碰到 ? 跳过往前匹配即可，? 就表示匹配， 碰到 * 会比较麻烦，因为会匹配 &gt;= 0个字符 但一般这种类型的题目可以使用动态规划来解决 代码 Dynamic Programming 假定dp_[i][j] 表示 匹配串(长为 i) s[0..i-1] 与模式串(长为 j) p[0..j-1] 是否匹配， 首先什么都没有肯定是相互匹配的，那么 dp_[0][0] = true dp_[1...i-1][0] = false 表示什么都没有和字符串不匹配 dp_[0][j] = dp_[0][j-1] 如果 p[j-1] == * 12345678910111213141516171819202122232425class Solution {public: bool isMatching(string s, string p) { const int m = s.length(); const int n = s.length(); vector&lt;vector&lt;bool&gt;&gt; dp_ (m+1, vector&lt;bool&gt;(n+1, false)); dp_[0][0] = true; // for (int i = 1; i &lt;= m; i++) { // dp_[i][0] = false; // } for (int i = 1; i &lt;= n; i++) { dp_[0][j] = dp[0][j-1] &amp;&amp; (p[j-1] == '*'); } for (int i = 1; i &lt;= m; i++) { for (int j = 1; j &lt;= n; j++) { if(p[j-1] == '*') { dp[i][j] = dp_[i][j-1] || dp_[i-1][j]; } else { dp_[i][j] = dp_[i-1][j-1] &amp;&amp; (s[i-1] == p[j-1] || p[j-1] == '?'); } } } return dp_[i][j]; }}; 递归 时间复杂度 O(m*n) 空间复杂度 O(m*n)","link":"/2020/04/25/WildcardMatching/"},{"title":"iOS 端启动速度优化","text":"应用启动流程 iOS 启动可以分为pre-main阶段和main()阶段 ### pre-main阶段 * 加载可执行文件 * 加载动态链接库加载器 dyld * 递归加载动态链接库 dylib main 阶段 dyld 调用 main 调用 UIApplicationMain 调用 applicationWillFinishLaunching 调用 didFinishLaunchingWithOptions 耗时测量 pre-main 阶段 Xcode 的环境变量中 DYLD_PRINT_STATICTICS = 1 日志里面会有详细的内容 main 阶段 测量 main -&gt; didFinishLaunchingWithOptions 的时间 优化思路 dyld 加载步骤 Load dylibs &gt; 分析依赖、Mach-o文件、验证有效性、代码签名注册到内核、对 dylib 的 segment 调用 mmap &gt; * 避免使用 embedded dylib &gt; * 合并已有的 dylib , 使用静态库 &gt; * 懒加载 dylib Rebase/Bind &gt; Rebase 读入镜像、修正 ASLR 导致的内存地址的偏差。消耗在文件 I/O。 &gt; Bind 查询符号表、设置镜像的外部指针。消耗在 CPU 计算 &gt; * 减少ObjC的 Class 、Selector、 Category 数量 &gt; * 减少C++ 虚函数数量（创建虚函数表有开销） &gt; * 使用 Swift struct（内部做了优化、符号开销少） Object setup &gt; dyld 会注册声明过的 ObjC 类，将分类方法插入到类的方法列表中、检查 selector 的唯一性 Initializers &gt; dyld 开始运行程序的初始化函数、调用每个 ObjC 类和分类的 +load 方法，调用 C/C++ 中的构造器函数 ( __attibute__(constructor)修饰的函数)， 创建非基本类型的 C++ 静态全局变量，随后调用 main 函数 &gt; * 减少 +load 函数做的事情，推迟到 +initialize 中 &gt; * 减少构造器函数的个数，在构造器函数里少作些事情 &gt; * 减少 C++ 静态全局变量个数 main 阶段 减少 didFinishLaunchingWithOptions 方法里的事情 * 梳理依赖库、延迟加载可以延迟加载的库 * 把可以延迟执行的逻辑，放到后面。 * 避免复杂/多余计算 * 避免在 viewDidLoad 和 viewWillAppear中做太多的事情 * 首页控制器用纯代码方式构建","link":"/2020/02/19/iOS%E7%AB%AF%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/"},{"title":"背包九讲","text":"背包九讲读书笔记 0-1 背包问题 基本题目套路 有 N 件物品和一个容量为 V 的背包，放入第 i 件物品消耗的费用是 Ci， 得到的价值是 Wi。 求解将哪些物品装入背包，可使总价值总和最大。 基本题目思路 特点：每件物品只有一个，选择：放 or 不放。 子问题：F[i, v]： 前 i 件物品恰好放入容量 v 的背包，可以获得的最大价值 状态转移：F[i, v] = max{F[i-1, v], F[i-1, v-Ci] + Wi} 当前的价值，只和之前的价值有关，因此两个选择下的价值为： 如果 i 不选，价值：前 i-1 件，放入容量 v 的背包（F[i-1, v]） 如果 i 选择，价值：前 i-1 件，放入容量（v-Ci）的背包（确保 i 能放下去，得减去 i 占用的容量）+ 放入 i 的价值 Wi 伪代码 1234F[0, 0..V] &lt;- 0for i &lt;- 1 to N for v &lt;- Ci to V F[i, v] &lt;- max{F[i-1, v], F[i-1, v-Ci] + Wi} 优化 时间复杂度：O(VN) 空间复杂度：滚动数组（逆序计算 F[v]，才能保证正确的顺序） 1234F[0..V] &lt;- 0for i &lt;- 1 to N for v &lt;- V to Ci F[v] &lt;- max{F[v], F[v-Ci] + Wi} 123def ZeroOnePack(F,C,W) for v &lt;- V to C F[v] &lt;- max(F[v], F[C-v] + W) 123F[0..V] &lt;- 0 for i &lt;- 1 to N ZeroOnePack(F,Ci,Wi) 完全背包问题 题目基本套路 N 种物品和容量为 V 的背包，每种物品都有无限件可以用，放入第 i 件物品消耗的费用是 Ci， 得到的价值是 Wi。 求解将哪些物品装入背包，可使物品总消耗费用不超过背包容量，且价值总和最大。 基本套路 每种物品无限件，因此每个物品的策略不是：选和不选。而是选几件 状态转移：F[i, v] = max{F[i-1, v-kCi] + kWi | 0 ≤ kCi ≤ v} 简单有效的优化 若两件物品i, j 满足 Ci ≤ Cj 且 Wi ≥ Wj，则可以将 j 直接去掉，不用考虑 (任何情况下，都可以将价值小费用高的 j 换成物美价廉的 i) 或者 将费用大于 V 的物品去掉 转换为 0-1 背包问题 第 i 种物品最多选：V/Ci 种，把第 i 种物品转化为 V/Ci 件费用及价值不变的物品。 （将一种物品转化为多件只能选 0 或者 1 件的 0-1 背包问题） 二进制：第 i 种物品拆成费用为 Ci2^k，价值为 Wi2^k 的若干件物品。 k 满足 Ci2^k ≤ V 的非负整数。","link":"/2020/11/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","link":"/tags/LeetCode/"},{"name":"Medium","slug":"Medium","link":"/tags/Medium/"},{"name":"Hard","slug":"Hard","link":"/tags/Hard/"},{"name":"Bit Manupulate","slug":"Bit-Manupulate","link":"/tags/Bit-Manupulate/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"iOS","slug":"iOS","link":"/tags/iOS/"},{"name":"NSDictionary","slug":"NSDictionary","link":"/tags/NSDictionary/"},{"name":"FishHook","slug":"FishHook","link":"/tags/FishHook/"},{"name":"educative.io","slug":"educative-io","link":"/tags/educative-io/"},{"name":"单例","slug":"单例","link":"/tags/%E5%8D%95%E4%BE%8B/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Mac Develop","slug":"Mac-Develop","link":"/tags/Mac-Develop/"},{"name":"Swift","slug":"Swift","link":"/tags/Swift/"},{"name":"SuperSign","slug":"SuperSign","link":"/tags/SuperSign/"},{"name":"超级签名","slug":"超级签名","link":"/tags/%E8%B6%85%E7%BA%A7%E7%AD%BE%E5%90%8D/"},{"name":"Easy","slug":"Easy","link":"/tags/Easy/"},{"name":"VSCode","slug":"VSCode","link":"/tags/VSCode/"},{"name":"Weakly Contest","slug":"Weakly-Contest","link":"/tags/Weakly-Contest/"},{"name":"Dynamic Programming","slug":"Dynamic-Programming","link":"/tags/Dynamic-Programming/"},{"name":"启动速度","slug":"启动速度","link":"/tags/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6/"},{"name":"背包问题","slug":"背包问题","link":"/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"}],"categories":[{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"C++","slug":"C","link":"/categories/C/"},{"name":"瞎逼逼","slug":"瞎逼逼","link":"/categories/%E7%9E%8E%E9%80%BC%E9%80%BC/"},{"name":"Groking The Coding Interview","slug":"Groking-The-Coding-Interview","link":"/categories/Groking-The-Coding-Interview/"},{"name":"iOS","slug":"iOS","link":"/categories/iOS/"},{"name":"Mac Develop","slug":"Mac-Develop","link":"/categories/Mac-Develop/"},{"name":"Swift","slug":"Mac-Develop/Swift","link":"/categories/Mac-Develop/Swift/"},{"name":"Binary Tree","slug":"Binary-Tree","link":"/categories/Binary-Tree/"},{"name":"Super Sign","slug":"Super-Sign","link":"/categories/Super-Sign/"},{"name":"Algorithm","slug":"Algorithm","link":"/categories/Algorithm/"},{"name":"Swift","slug":"Algorithm/Swift","link":"/categories/Algorithm/Swift/"},{"name":"VSCode","slug":"VSCode","link":"/categories/VSCode/"},{"name":"背包问题","slug":"背包问题","link":"/categories/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"}]}