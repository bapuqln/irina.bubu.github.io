<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AddTwoNumber</title>
    <url>/2019/11/22/AddTwoNumber/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/add-two-numbers/">AddTwoNumbers</a><br>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li><code>2</code> 个 <code>非空</code>链表，长度可能不相等</li>
<li>每个链表为<code>逆序</code></li>
<li>返回两个链表的和</li>
<li>每个元素应该为正数</li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><ul>
<li><code>2 -&gt; 4 -&gt; 3</code> = <code>342</code></li>
<li><code>5 -&gt; 6 -&gt; 4</code> = <code>465</code></li>
<li><code>342 + 465 = 807</code></li>
<li>答案 : <code>7 -&gt; 0 -&gt; 8</code></li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>将每一个链表变成整形，然后相加，结果分解成链表不大合适，还得处理越界的情况</li>
<li>比较合理的办法：是一边遍历一边生成链表</li>
<li>每一个生成的节点为两个数的和，有可能产生进位: 如 <code>7+8=15</code></li>
<li>一个节点的结果为：<code>sum = 前一个节点的进位+两个节点的和</code>，<code>res = sum % 10</code>;</li>
<li>一个节点的结果几种情况<ul>
<li><code>last_carry + left + right &lt; 10</code></li>
<li><code>last_carry + left + right &gt;= 10</code></li>
<li><code>只要有进位，就一定会有一个新的节点出现</code></li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *head = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="type">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span> (sum % <span class="number">10</span>);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">var</span> val: <span class="type">Int</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">var</span> next: <span class="type">ListNode</span>?</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">val</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">     <span class="keyword">self</span>.val <span class="operator">=</span> val</span><br><span class="line">     <span class="keyword">self</span>.next <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">addTwoNumbers</span>(<span class="keyword">_</span> <span class="params">l1</span>: <span class="type">ListNode</span>?, <span class="keyword">_</span> <span class="params">l2</span>: <span class="type">ListNode</span>?) -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">    	<span class="keyword">var</span> l1 <span class="operator">=</span> l1</span><br><span class="line">        <span class="keyword">var</span> l2 <span class="operator">=</span> l2</span><br><span class="line">        <span class="keyword">var</span> prev <span class="operator">=</span> <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> carry <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> head <span class="operator">=</span> prev</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">||</span> l2 <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">||</span> carry <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> cur <span class="operator">=</span> <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">let</span> sum <span class="operator">=</span> (l2 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> <span class="number">0</span> : l2<span class="operator">!</span>.val) <span class="operator">+</span> (l1 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> <span class="number">0</span> : l1<span class="operator">!</span>.val) <span class="operator">+</span> carry</span><br><span class="line">            cur.val <span class="operator">=</span> sum <span class="operator">%</span> <span class="number">10</span></span><br><span class="line">            carry <span class="operator">=</span> sum <span class="operator">/</span> <span class="number">10</span></span><br><span class="line">            prev.next <span class="operator">=</span> cur</span><br><span class="line">            prev <span class="operator">=</span> cur</span><br><span class="line">            l1 <span class="operator">=</span> l1 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> l1: l1<span class="operator">?</span>.next</span><br><span class="line">            l2 <span class="operator">=</span> l2 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> l2: l2<span class="operator">?</span>.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>这道题比较简单，递归模式也比较好想到<br>加法需要三个值，两个操作符（来自两个链表）以及一个进位标记。<br>因此递归模式为：</p>
<ul>
<li>递归出口：两个链表都已经到达末尾，并且没有进位</li>
<li>递归实现：<ul>
<li>当前节点的结果为：和/10</li>
<li>当前节点的next节点为：对于两个链表next节点的计算的结果</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2 &amp;&amp; !carry) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> sum = (l1?l1-&gt;val:<span class="number">0</span>) + (l2?l2-&gt;val:<span class="number">0</span>) + carry;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        ans-&gt;next = <span class="built_in">addTwoNumbers</span>(l1?l1-&gt;next:<span class="literal">nullptr</span>, l2?l2-&gt;next:<span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">addTwoNumbers</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>遍历次数：<code>max(len(l1), len(l2)) + 1</code>，因此是线性时间 \(\mathcal{O(max(len(l1), len(l2)))}\)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>额外申请了和一个链表，因此空间复杂度也为 \(\mathcal{O(max(len(l1), len(l2)))}\)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Basic Calculator</title>
    <url>/2020/06/12/BasicCalculator/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/basic-calculator/">Basic Calculator</a><br>Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p>
<p>Example 1:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;1 + 1&quot;</span></span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot; 2-1 + 2 &quot;</span></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 3:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;(1+(4+5+2)-3)+(6+8)&quot;</span></span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></p>
<p>Note:<br>You may assume that the given expression is always valid.<br>Do not use the eval built-in library function.</p>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>看到这种模式肯定要用到栈 <code>stack</code></li>
<li>会有括号的处理，这块可能会复杂点，因为有可能会导致计算优先级改变。</li>
<li>说白了就是将整个过程看为求和，每个数分配一个操作符，用来求和</li>
<li>分析例子可以知道<blockquote>
<ul>
<li>每一个数字都会消耗掉一个符号(+、-)</li>
<li>每一个数字都会产生一个新的符号(+, -)</li>
<li>每一个 <code>(</code> 都会复制当前的符号，这样的话他就能给该操作范围内的第一个数用，</li>
<li>每一个 <code>)</code> 都会关闭当前的操作范围，因此会丢弃掉当前的符号</li>
</ul>
</blockquote>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2 sign</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sign</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">                    n = n * <span class="number">10</span> + (s[i++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                ans += sign.<span class="built_in">back</span>() * n;</span><br><span class="line">                sign.<span class="built_in">pop_back</span>();</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                sign.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sign.<span class="built_in">push_back</span>(sign.<span class="built_in">back</span>() * (c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> remaining   sign stack      total</span><br><span class="line"><span class="number">3</span>-(<span class="number">2</span>+(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">1</span>]            <span class="number">0</span></span><br><span class="line"> -(<span class="number">2</span>+(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>]               <span class="number">3</span></span><br><span class="line">  (<span class="number">2</span>+(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>]           <span class="number">3</span></span><br><span class="line">   <span class="number">2</span>+(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>]       <span class="number">3</span></span><br><span class="line">    +(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>]           <span class="number">1</span></span><br><span class="line">     (<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>]       <span class="number">1</span></span><br><span class="line">      <span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]   <span class="number">1</span></span><br><span class="line">       <span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>]      <span class="number">-8</span></span><br><span class="line">        <span class="number">4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>]   <span class="number">-8</span></span><br><span class="line">         ))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>]      <span class="number">-4</span></span><br><span class="line">          )   [<span class="number">1</span>, <span class="number">-1</span>]          <span class="number">-4</span></span><br><span class="line">              [<span class="number">1</span>]              <span class="number">-4</span></span><br></pre></td></tr></table></figure>
<h2 id="另一种解法"><a href="#另一种解法" class="headerlink" title="另一种解法"></a>另一种解法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li>括号内优先计算</li>
<li>碰到 <code>(</code> ,将计算结果和操作符入栈</li>
<li>碰到数字就带着符号计算结果。</li>
</ul>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> l = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk_;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                <span class="type">int</span> d = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span> (i<span class="number">+1</span> &lt; l &amp;&amp; <span class="built_in">isdigit</span>(s[i<span class="number">+1</span>])) &#123;</span><br><span class="line">                    d = d * <span class="number">10</span> + (s[++i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ans += d * sign;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stk_.<span class="built_in">push</span>(ans);</span><br><span class="line">                stk_.<span class="built_in">push</span>(sign);</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                ans *= stk_.<span class="built_in">top</span>(); stk_.<span class="built_in">pop</span>();</span><br><span class="line">                ans += stk_.<span class="built_in">top</span>(); stk_.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>Best Time To Buy Sell Stock IV</title>
    <url>/2020/06/07/BestTimeToBuyAndSellStockIV/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">Best Time to Buy and Sell Stock IV</a><br>Say you have an array for which the i-th element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p>
<p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>Example 1:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [2,4,1], k = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</span><br></pre></td></tr></table></figure><br>Example 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [3,2,6,5,0,3], k = 2</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.</span><br><span class="line">             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>获取收益肯定应该在地点买入，高点卖出，假定 <code>vally</code> 表示低价格的索引，<code>peak</code> 表示高价格的索引，因此 <code>(v1, p1)</code> 和 <code>(v2, p2)</code> 表示两个连续的 <code>valley-peak</code> 的价格。考虑如下两个 case<br>*<code>prices[v1] &lt;= prices[v2] &amp;&amp; prices[p1] &lt;= prices[p2]</code>，在该条件下，如果只能交易一次，那就是<code>(v1, p2)</code>。 如果是两个交易，那就是<code>(v1, p1)</code> 和 <code>(v2, p2)</code>。为了省事，将<code>(v1, p2)</code>看做为第一个交易，<code>(v2, p1)</code> 看做第二个交易.</li>
<li><code>prices[v1] &gt;= prices[v2] || prices[p1] &gt;= prices[p2]</code>，在该条件下，如果只能交易一次，要么就用<code>(v1,p1)</code>，要么就用 <code>(v2,p2)</code>。如果是两次交易，就全部使用。</li>
</ul>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul>
<li>找到全部的交易，并且记录每一笔的收益，使用 <code>stack</code> 记录每一对 <code>vally-peak</code> 。并且保证 <code>vally</code> 是按照升序排列。所有的收益都放在 <code>vector</code> 数组中，时间复杂度为 <code>O(n)</code>.</li>
<li>找到前 <code>k</code> 个交易收益，时间复杂度为 <code>O(n)</code></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; profits;</span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; vps; <span class="comment">// vally-peak pairs</span></span><br><span class="line">        <span class="type">int</span> v = <span class="number">0</span>, p = <span class="number">-1</span>; <span class="comment">// padding p , so not using p-1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// find next vally and peak</span></span><br><span class="line">            <span class="keyword">for</span> (v = p<span class="number">+1</span>; v<span class="number">+1</span> &lt; m &amp;&amp; (prices[v] &gt;= prices[v<span class="number">+1</span>]); v++);</span><br><span class="line">            <span class="keyword">for</span> (p = v;   p<span class="number">+1</span> &lt; m &amp;&amp; (prices[p] &gt;= prices[p<span class="number">-1</span>]); p++);</span><br><span class="line">            <span class="keyword">if</span> (v == p) <span class="keyword">break</span>; <span class="comment">// to the end of prices</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// v &lt; p</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// (v1,p1) (v2,p2)</span></span><br><span class="line">            <span class="comment">// if (prices[v1] &gt;= prices[v2]) no need to combine two transactions</span></span><br><span class="line">            <span class="comment">// after å top is (v1,p2), push p2-v1 into profit --&gt; step ∑</span></span><br><span class="line">            <span class="keyword">while</span> (!vps.<span class="built_in">empty</span>() &amp;&amp; (prices[v] &lt;= prics[vps.<span class="built_in">top</span>().first])) &#123;</span><br><span class="line">                profits.<span class="built_in">push_back</span>(prices[vps.<span class="built_in">top</span>().second] - prices[vps.<span class="built_in">top</span>().first]);</span><br><span class="line">                vps.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// (v1, p1) (v2,p2)</span></span><br><span class="line">            <span class="comment">// if (prices[v1] &lt; prices[v2] &amp;&amp; prices[p1] &lt; prices[p2]) we need to combine two transactions</span></span><br><span class="line">            <span class="comment">// update (v1,p1) --&gt; (v1, p2)</span></span><br><span class="line">            <span class="comment">// p2-v2 + p1-v1 == p2-v1 + p1-v2</span></span><br><span class="line">            <span class="comment">// after step ∑ top is (v1, p2)</span></span><br><span class="line">            <span class="keyword">while</span> (!vps.<span class="built_in">empty</span>() &amp;&amp; (prices[p] &gt;= prices[vps.<span class="built_in">top</span>().second])) &#123;</span><br><span class="line">                <span class="comment">// save profit (v2, p1)</span></span><br><span class="line">                profits.<span class="built_in">push_back</span>(prices[vps.<span class="built_in">top</span>().second] - prices[v]);</span><br><span class="line">                <span class="comment">// v1 --&gt; v</span></span><br><span class="line">                v = vps.<span class="built_in">top</span>()first;</span><br><span class="line">                vps.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// v is v1</span></span><br><span class="line">                <span class="comment">// p is p2</span></span><br><span class="line">                <span class="comment">// step å</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if step å  (v1, p2) is top of vps</span></span><br><span class="line">            vps.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(v, p));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate all the profits</span></span><br><span class="line">    <span class="keyword">while</span> (!vps.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        profits.<span class="built_in">push_back</span>(prices[vps.<span class="built_in">top</span>().second] - prices[vps.<span class="built_in">top</span>().first]);</span><br><span class="line">        vps.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate k highest profitœ</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = profits.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; = k) &#123;</span><br><span class="line">        <span class="built_in">accumulate</span>(profits.<span class="built_in">begin</span>(), profits.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">nth_element</span>(profits.<span class="built_in">begin</span>(), profits.<span class="built_in">end</span>() - k, profits.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">accumulate</span>(profits.<span class="built_in">end</span>() - k,profit.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>位操作</title>
    <url>/2020/08/11/BitManupulate/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"> <span id="more"></span>
<h1 id="位操作总结"><a href="#位操作总结" class="headerlink" title="位操作总结"></a>位操作总结</h1><p>基本上位操作就那么几个:</p>
<h2 id="异或的特性"><a href="#异或的特性" class="headerlink" title="异或的特性"></a>异或的特性</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x ^ <span class="number">0</span> = x</span><br><span class="line"></span><br><span class="line">x ^ <span class="number">11111</span>……<span class="number">1111</span> = ~x</span><br><span class="line"></span><br><span class="line">x ^ (~x) = <span class="number">11111</span>……<span class="number">1111</span></span><br><span class="line"></span><br><span class="line">x ^ x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">a ^ b = c =&gt; a ^ c = b =&gt; b ^ c = <span class="built_in">a</span> (交换律) a ^ b ^ c = a ^ (b ^ c) = (a ^ b）^ <span class="built_in">c</span> (结合律)</span><br></pre></td></tr></table></figure>
<h2 id="构造特殊的Mask"><a href="#构造特殊的Mask" class="headerlink" title="构造特殊的Mask"></a>构造特殊的Mask</h2><ul>
<li>将 <code>x</code> 最右边的 <code>n</code> 位清零， <code>x &amp; ( ~0 &lt;&lt; n )</code></li>
<li>获取 <code>x</code> 的第 <code>n</code> 位值(0 或者 1)，<code>(x &gt;&gt; n) &amp; 1</code></li>
<li>获取 <code>x</code> 的第 <code>n</code> 位的幂值，<code>x &amp; (1 &lt;&lt; (n - 1))</code></li>
<li>仅将第 <code>n</code> 位置为 <code>1</code>，<code>x | (1 &lt;&lt; n)</code></li>
<li>仅将第 <code>n</code> 位置为 <code>0</code>，<code>x &amp; (~(1 &lt;&lt; n))</code></li>
<li>将 <code>x</code> 最⾼位⾄第 <code>n</code> 位(含)清零，<code>x &amp; ((1 &lt;&lt; n) - 1)</code></li>
<li>将第 <code>n</code> 位⾄第 <code>0</code> 位(含)清零，<code>x &amp; (~((1 &lt;&lt; (n + 1)) - 1)</code></li>
</ul>
<h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><p><code>X &amp; 1 == 1</code> 判断是否是奇数(偶数)<br><code>X &amp; = (X - 1)</code> 将最低位(LSB)的 1 清零<br><code>X &amp; -X</code> 得到最低位(LSB)的 1</p>
<p><code>X &amp; ~X = 0</code></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit Manupulate</tag>
      </tags>
  </entry>
  <entry>
    <title>Boyer Moore Majority Vote Algorithm</title>
    <url>/2019/11/22/BoyerMooreMajorityVoteAlgorithm/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/majority-element-ii/">MajorityElementII</a><br>Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</p>
<p>Note: The algorithm should run in linear time and in O(1) space.</p>
<ul>
<li><p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: [3]</span><br></pre></td></tr></table></figure>
</li>
<li><p>Example 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [1,1,1,3,3,2,2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure>
<span id="more"></span>
</li>
</ul>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li>给定一个数组，大小为 <code>n</code>，让找到所有出现多于<code>⌊ n/3 ⌋</code>次的元素</li>
<li>题目要求线性时间，以及 O(1) 的空间复杂度</li>
</ul>
<h3 id="Boyer-Moore-majority-vote-algorithm"><a href="#Boyer-Moore-majority-vote-algorithm" class="headerlink" title="Boyer-Moore majority vote algorithm"></a>Boyer-Moore majority vote algorithm</h3><p>该算法来自一篇论文<a href="http://www.cs.rug.nl/~wim/pub/whh348.pdf">Boyer-Moore Majority Vote Algorithm</a>，运行时间为O(n)，空间复杂度为O(1)，他只要求对输入遍历两次。虽然实现起来比较简单，但是理解起来还是需要花点时间。</p>
<ul>
<li>第一遍<blockquote>
<ol>
<li>我们需要定义两个变量：candidate 和  count</li>
<li>对于每一个输入的元素，首先看 count，如果 count 为 0，将当前位置元素赋给 candidate</li>
<li>比较当前位置的元素 与 candidate，如果相等：count+1，如果不等 count-1<br>说白了，就是不一样的就可以抵消一个，最后剩下的 candidate 就是候选，最后在确认一次即可。</li>
</ol>
</blockquote>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">candidate = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> <span class="built_in">input</span>:</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">        candidate = value</span><br><span class="line">    <span class="keyword">if</span> candidate == value:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当执行完毕后，candidate 即为 majority value 如果存在的话。</p>
</blockquote>
<ul>
<li>第二遍<br>确定一下 candidate 是不是 majority 元素。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 对象序列化</title>
    <url>/2019/11/22/C-Object-Serialization/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近做的项目需要对C++对象进行序列化和反序列化，最主要的目的是将JSON和C++对象互转。</p>
<span id="more"></span>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sequence for</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T... S, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">for_sequence</span><span class="params">(std::integer_sequence&lt;T, S...&gt;, F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="type">unpack_t</span> = <span class="type">int</span>[];</span><br><span class="line">    (<span class="type">void</span>)<span class="type">unpack_t</span>&#123;(<span class="built_in">static_cast</span>&lt;<span class="type">void</span>&gt;(<span class="built_in">f</span>(std::integral_constant&lt;T, S&gt;&#123;&#125;)), <span class="number">0</span>)..., <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample implementation of a json-like data structure. It is only there for the example to compile and actually produce a testable output</span></span><br><span class="line"><span class="keyword">namespace</span> Json &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Value</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">ValueData</span> &#123;</span><br><span class="line">        std::map&lt;std::string, Value&gt; subObject;</span><br><span class="line">        std::string string;</span><br><span class="line">        <span class="type">int</span> number = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Value</span> &#123;</span><br><span class="line">        ValueData data;</span><br><span class="line"></span><br><span class="line">        Value&amp; <span class="keyword">operator</span>[](std::string name) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.subObject[std::<span class="built_in">move</span>(name)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">const</span> Value&amp; <span class="keyword">operator</span>[](std::string name) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = data.subObject.<span class="built_in">find</span>(std::<span class="built_in">move</span>(name));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (it != data.subObject.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Value&amp; <span class="keyword">operator</span>=(std::string value) &#123;</span><br><span class="line">            data.string = value;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Value&amp; <span class="keyword">operator</span>=(<span class="type">double</span> value) &#123;</span><br><span class="line">            data.number = value;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T&amp; <span class="title">asAny</span><span class="params">(Value&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="type">const</span> T&amp; <span class="title">asAny</span><span class="params">(<span class="type">const</span> Value&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">int</span>&amp; <span class="built_in">asAny</span>&lt;<span class="type">int</span>&gt;(Value&amp; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.data.number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; <span class="built_in">asAny</span>&lt;<span class="type">int</span>&gt;(<span class="type">const</span> Value&amp; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.data.number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="type">const</span> std::string&amp; <span class="built_in">asAny</span>&lt;std::string&gt;(<span class="type">const</span> Value&amp; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.data.string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    std::string&amp; <span class="built_in">asAny</span>&lt;std::string&gt;(Value&amp; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.data.string;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Class, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PropertyImpl</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">PropertyImpl</span><span class="params">(T Class::*aMember, <span class="type">const</span> <span class="type">char</span>* aName)</span> : member&#123;</span>aMember&#125;, name&#123;aName&#125; &#123;&#125;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">    T Class::*member;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// One could overload this function to accept both a getter and a setter instead of a member.</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Class, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">property</span><span class="params">(T Class::*member, <span class="type">const</span> <span class="type">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PropertyImpl&lt;Class, T&gt;&#123;member, name&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// unserialize function</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">fromJson</span><span class="params">(<span class="type">const</span> Json::Value&amp; data)</span> </span>&#123;</span><br><span class="line">    T object;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We first get the number of properties</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> nbProperties = std::tuple_size&lt;<span class="keyword">decltype</span>(T::properties)&gt;::value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We iterate on the index sequence of size `nbProperties`</span></span><br><span class="line">    for_sequence(std::make_index_sequence&lt;nbProperties&gt;&#123;&#125;, [&amp;](<span class="keyword">auto</span> i)&#123;</span><br><span class="line">        <span class="comment">// get the property</span></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> property = std::<span class="built_in">get</span>&lt;i&gt;(T::properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the type of the property</span></span><br><span class="line">        <span class="keyword">using</span> Type = <span class="keyword">typename</span> <span class="keyword">decltype</span>(property)::Type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set the value to the member</span></span><br><span class="line">        object.*(property.member) = Json::<span class="built_in">asAny</span>&lt;Type&gt;(data[property.name]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">Json::Value <span class="title">toJson</span><span class="params">(<span class="type">const</span> T&amp; object)</span> </span>&#123;</span><br><span class="line">    Json::Value data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We first get the number of properties</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> nbProperties = std::tuple_size&lt;<span class="keyword">decltype</span>(T::properties)&gt;::value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We iterate on the index sequence of size `nbProperties`</span></span><br><span class="line">    for_sequence(std::make_index_sequence&lt;nbProperties&gt;&#123;&#125;, [&amp;](<span class="keyword">auto</span> i)&#123;</span><br><span class="line">        <span class="comment">// get the property</span></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> property = std::<span class="built_in">get</span>&lt;i&gt;(T::properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set the value to the member</span></span><br><span class="line">        data[property.name] = object.*(property.member);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> animal &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">        std::string barkType;</span><br><span class="line">        std::string color;</span><br><span class="line">        <span class="type">int</span> weight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Dog&amp; rhs) <span class="type">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> barkType == rhs.barkType &amp;&amp; color == rhs.color &amp;&amp; weight == rhs.weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="type">static</span> <span class="keyword">auto</span> properties = std::<span class="built_in">make_tuple</span>(<span class="built_in">property</span>(&amp;Dog::barkType, <span class="string">&quot;barkType&quot;</span>), <span class="built_in">property</span>(&amp;Dog::color, <span class="string">&quot;color&quot;</span>), <span class="built_in">property</span>(&amp;Dog::weight, <span class="string">&quot;weight&quot;</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    animal::Dog dog;</span><br><span class="line"></span><br><span class="line">    dog.color = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">    dog.barkType = <span class="string">&quot;whaf&quot;</span>;</span><br><span class="line">    dog.weight = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    Json::Value jsonDog = <span class="built_in">toJson</span>(dog); <span class="comment">// produces &#123;&quot;color&quot;:&quot;green&quot;, &quot;barkType&quot;:&quot;whaf&quot;, &quot;weight&quot;: 30&#125;</span></span><br><span class="line">    <span class="keyword">auto</span> dog2 = <span class="built_in">fromJson</span>&lt;animal::Dog&gt;(jsonDog);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::boolalpha &lt;&lt; (dog == dog2) &lt;&lt; __FILE_NAME__ &lt;&lt; std::endl; <span class="comment">// pass the test, both dog are equal!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>BinaryTree</title>
    <url>/2020/06/29/BinaryTree/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="二叉树总结"><a href="#二叉树总结" class="headerlink" title="二叉树总结"></a>二叉树总结</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    <span class="function">TreeNode *right</span></span><br><span class="line"><span class="function">    <span class="title">TreeNode</span><span class="params">(<span class="type">int</span> v)</span>: value(v),left(nullptr), right(nullptr) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><ul>
<li>递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">preOrderTraversal</span>(TreeNode* tree) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        function&lt;<span class="type">void</span>(TreeNode *)&gt; preOrderTraversalHelper = [&amp;](TreeNode *node)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="built_in">preOrderTraversalHelper</span>(node-&gt;left);</span><br><span class="line">            <span class="built_in">preOrderTraversalHelper</span>(node-&gt;right)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">preOrderTraversalHelper</span>(tree);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>非递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">preOrderTraversal</span>(TreeNode *node)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk_;</span><br><span class="line">        stk_.<span class="built_in">push</span>(node);</span><br><span class="line">        <span class="keyword">while</span> (!stk_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *root = stk_.<span class="built_in">top</span>();</span><br><span class="line">            stk_.<span class="built_in">pop</span>();</span><br><span class="line">            ans.(root-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">                stk_.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">                stk_.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;push_back</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        TreeNode* cur = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                cur = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span> (cur-&gt;left &amp;&amp; cur-&gt;left != root) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left == root) &#123;</span><br><span class="line">                    cur-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                    cur-&gt;left = root;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul>
<li>递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inOrderTraversal</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        function&lt;<span class="type">void</span>(TreeNode *)&gt; inOrderTraversalHelper = [&amp;](TreeNode * root)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">inOrderTraversalHelper</span>(root-&gt;left)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">inOrderTraversalHelper</span>(root-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">inOrderTraversalHelper</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>非递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">inOrderTraversal</span>(TreeNode *root)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk_;</span><br><span class="line">        <span class="keyword">while</span> (root || !stk_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                stk_.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk_.<span class="built_in">top</span>(); stk_.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;value);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ul>
<li>递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        function&lt;<span class="type">void</span>(TreeNode *)&gt;postOrderTraversalHelper = [&amp;](TreeNode *root)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">postOrderTraversal</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">postOrderTraversal</span>(root-&gt;right);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">postOrderTraversal</span>(node);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>非递归<blockquote>
<p>two stack</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk_, _stk;</span><br><span class="line">        stk_.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode *node = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            node = stk_.<span class="built_in">top</span>();stk_.<span class="built_in">pop</span>();</span><br><span class="line">            _stk.<span class="built_in">push</span>(node);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                stk_.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                stk_.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(_stk.<span class="built_in">top</span>());</span><br><span class="line">            _stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>one stack, 需要记录上一个输出的节点的指针，<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode *&gt;stk_;</span><br><span class="line">        TreeNode *last = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root || !stk_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root) &#123;</span><br><span class="line">                stk_.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode *node = stk_.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right &amp;&amp; last != node-&gt;right) &#123;</span><br><span class="line">                    root = node-&gt;right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(node-&gt;value);</span><br><span class="line">                    last = node;</span><br><span class="line">                    stk_.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Morris Traversal O(n) time O(1) space</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nodes;</span><br><span class="line">        TreeNode* dummy = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy -&gt; left = root;</span><br><span class="line">        TreeNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; left) &#123;</span><br><span class="line">                TreeNode* pre = cur -&gt; left;</span><br><span class="line">                <span class="keyword">while</span> (pre -&gt; right &amp;&amp; (pre -&gt; right != cur)) &#123;</span><br><span class="line">                    pre = pre -&gt; right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!(pre -&gt; right)) &#123;</span><br><span class="line">                    pre -&gt; right = cur;</span><br><span class="line">                    cur = cur -&gt; left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">reverseAddNodes</span>(cur -&gt; left, pre, nodes);</span><br><span class="line">                    pre -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">                    cur = cur -&gt; right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur -&gt; right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseNodes</span><span class="params">(TreeNode* start, TreeNode* end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* x = start;</span><br><span class="line">        TreeNode* y = start -&gt; right;</span><br><span class="line">        TreeNode* z;</span><br><span class="line">        <span class="keyword">while</span> (x != end) &#123;</span><br><span class="line">            z = y -&gt; right;</span><br><span class="line">            y -&gt; right = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseAddNodes</span><span class="params">(TreeNode* start, TreeNode* end, vector&lt;<span class="type">int</span>&gt;&amp; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverseNodes</span>(start, end);</span><br><span class="line">        TreeNode* node = end;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            nodes.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">            <span class="keyword">if</span> (node == start) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverseNodes</span>(end, start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Construct Binary Tree from Preorder and Postorder Traversal</title>
    <url>/2020/05/24/ConstructBinaryTreeFromPreorderAndPostorderTraversal/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">Construct Binary Tree from Preorder and Postorder Traversal</a><br>Return any binary tree that matches the given preorder and postorder traversals.</p>
<p>Values in the traversals pre and post are distinct positive integers.</p>
<p>Example 1:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]</span><br><span class="line">Output: [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure></p>
<p>Note:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= pre.length == post.length &lt;= 30</span><br><span class="line">pre[] and post[] are both permutations of 1, 2, ..., pre.length.</span><br><span class="line">It is guaranteed an answer exists. If there exists multiple answers, you can <span class="built_in">return</span> any of them.</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li>给定两个数组，分别表示先序遍历和后序遍历</li>
<li>要求根据两个遍历结果构造出原来的二叉树</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><ul>
<li>创建一个节点 <code>TreeNode[pre[preIndex]]</code> 作为根节点</li>
<li>由于后序遍历中根节点是最后访问的，因此构造结束的条件就是：<code>root-&gt;val == post[postIndex]</code></li>
<li>那么，如果还没有创建完二叉树，我们就递归的对于左子树和右子树调用构造函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> preIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> postIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">constructFromPrePost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pre, vector&lt;<span class="type">int</span>&gt;&amp; post)</span> </span>&#123;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[preIndex++]);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val != post[postIndex])</span><br><span class="line">            root-&gt;left = <span class="built_in">constructFromPrePost</span>(pre, post);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val != post[postIndex]) &#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">constructFromPrePost</span>(pre, post);</span><br><span class="line">        &#125;</span><br><span class="line">        postIndex++;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h4><ul>
<li>使用栈，前序生成二叉树，将生成的结果 <code>push</code> 到 <code>stack</code> 中，然后使用后续 <code>pop</code> 出来</li>
<li><code>stack</code> 保存的是当前的树</li>
<li><code>node == new TreeNode(pre[i])</code> ，如果没有左子节点，就把它作为左子节点，否则就是右子节点。</li>
<li>如果在前序遍历和后序遍历碰到了相同的值，那么就说明当前子树构造结束，将其 <code>pop</code> 出来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode * <span class="title">constructFromPrePost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;pre, vector&lt;<span class="type">int</span>&gt; &amp;post)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; stk_;</span><br><span class="line">        stk_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; pre.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[i]);</span><br><span class="line">            <span class="keyword">while</span> (stk_.<span class="built_in">back</span>()-&gt;val == post[j]) &#123;</span><br><span class="line">                stk_.<span class="built_in">pop_back</span>();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stk_.<span class="built_in">back</span>()-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk_.<span class="built_in">back</span>()-&gt;left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk_.<span class="built_in">back</span>()-&gt;right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            stk_.<span class="built_in">push_back</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk_[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>遍历次数：<code>O(n)</code>，因此是线性时间，每个元素只遍历一次</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><code>O(n)</code> 表示栈的大小</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>探索 NSDictionary</title>
    <url>/2019/12/04/Dive-Into-NSDictionary/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Exposing-NSDictinoary"><a href="#Exposing-NSDictinoary" class="headerlink" title="Exposing NSDictinoary"></a>Exposing NSDictinoary</h1><h2 id="The-Class"><a href="#The-Class" class="headerlink" title="The Class"></a>The Class</h2><p>相当多的类都是 class clusters，当然 NSDictionary 也不例外，曾经一段时间 NSDictinoary 使用了 CFDictionary 作为它的默认实现。然而，在 iOS 6以后事情改变了。。。</p>
<span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(lldb) po [[NSDictionary new] class]</span><br><span class="line">__NSDictionaryI</span><br></pre></td></tr></table></figure>
<p>和 <strong>NSArrayM 一样， </strong>NSDictionaryI 也是在 CoreFoundation Framework 中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface __NSDictionaryI : NSDictionary</span><br><span class="line">&#123;</span><br><span class="line">    NSUIngeter _used:58;</span><br><span class="line">    NSUIngeter _szidx:6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="The-Storage"><a href="#The-Storage" class="headerlink" title="The Storage"></a>The Storage</h2><h3 id="Instance-Creation"><a href="#Instance-Creation" class="headerlink" title="Instance Creation"></a>Instance Creation</h3><p>想要理解 <strong>NSDictionaryI 在哪里保存内容，我们来看看对象创建的过程，只有一个类方法负责创建实例：`</strong>NSDictionaryI`。根据 class-dump 的输出，方法有如下的签名：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (id)__new:(const id *)arg1:(const id *)arg2:(unsigned long long)arg3:(_Bool)arg4:(_Bool)arg5;</span><br></pre></td></tr></table></figure>
<p> 他需要5各参数，只有第一个是指名字，如果我们使用@selector 的方式来写的话，应该是这样 <code>@selector(__new:::::)</code>。前三个参数通过设置断点，然后看一下寄存器 x2、x3、x4的内容，看到他们是分别是：array 的 key、array 的 object、key（object） 的个数。注意和对外公布的 api 相比，参数的位置是互换的。</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (instancetype)dictionaryWithObjects:(const id [])objects forKeys:(const id &lt;NSCopying&gt; [])keys count:(NSUInteger)cnt;</span><br></pre></td></tr></table></figure>
<p> 其实参数定义为<code>const id *</code>或者<code>const id []</code>没有太大的关系。剩下的就是两个BOOL 类型的参数。第四个参数是指 key 是否需要被拷贝。第五个参数决定了参数是否不需要被 retain。我们可以重写该函数：</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (id)__new:(const id *)keys :(const id *)objects :(unsigned long long)count :(_Bool)copyKeys :(_Bool)dontRetain;</span><br></pre></td></tr></table></figure>
<h3 id="Indexed-ivars"><a href="#Indexed-ivars" class="headerlink" title="Indexed ivars"></a>Indexed ivars</h3><p> 除了函数<code>+ __new:::::</code>以外，<code>malloc</code> 和 <code>calloc</code> 并没有地方被调用。实际上，函数调用了 <code>__CFAllocateObject2</code> 方法，并且传递了 <code>__NSDictionaryI</code> 作为第一个参数，然后用需要的大小作为第二个参数。<code>__CFAllocateObject2</code> 实际上调用了 <code>class_createInstance</code> ，然后把同样的参数传给他。</p>
<p>class_createInstance(Class cls, size_t extraBytes) 调用了 _class_createInstanceFromZone 并且传个 nil 作为 zone 的参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    size_t size = cls-&gt;alignedInstanceSize() + extraBytes;</span><br><span class="line">    ...</span><br><span class="line">    id obj = (id)calloc(1, size);</span><br><span class="line">    ...</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>extreBytes 参数，calloc 函数调用确保了所有的 ivar 都是 0.</p>
<p>indexed ivars就是在普通的 ivar 后面<img src="/images/14919793823550/14919859011959.jpg" alt=""></p>
<p>剩下的就是分配内存了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void *object_getIndexedIvars(id obj)</span><br></pre></td></tr></table></figure>
<p><img src="/images/14919793823550/14919866880631.jpg" alt=""></p>
<p>关于 indexed ivar 有一些比较好玩的事情。</p>
<ul>
<li>每一个实例都可以有不同数量的 extraBytes指向他</li>
<li>存取速度很快。</li>
<li>可以对 class-dump 这样的工具隐藏实现细节。</li>
</ul>
<p>但是：在 arc 环境下是不能直接编译 class_createInstance，需要增加 -fno-objc-arc 标志位。。运行时没有保存 indexed ivars 信息。</p>
<h2 id="key-amp-访问一个对象"><a href="#key-amp-访问一个对象" class="headerlink" title="key &amp; 访问一个对象"></a>key &amp; 访问一个对象</h2><h3 id="C-Code"><a href="#C-Code" class="headerlink" title="C Code"></a>C Code</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (id)objectForKey:(id)aKey</span><br><span class="line">&#123;</span><br><span class="line">    NSUInteger sizeIndex = _szidx;</span><br><span class="line">    NSUInteger size = __NSDictionarySizes[sizeIndex];</span><br><span class="line"></span><br><span class="line">    id *storage = (id *)object_getIndexedIvars(dict);</span><br><span class="line"></span><br><span class="line">    NSUInteger fetchIndex = [aKey hash] % size;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; size; i++) &#123;</span><br><span class="line">        id fetchedKey = storage[2 * fetchIndex];</span><br><span class="line"></span><br><span class="line">        if (fetchedKey == nil) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (fetchedKey == aKey || [fetchedKey isEqual:aKey]) &#123;</span><br><span class="line">            return storage[2 * fetchIndex + 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fetchIndex++;</span><br><span class="line"></span><br><span class="line">        if (fetchIndex == size) &#123;</span><br><span class="line">            fetchIndex = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是从汇编反推出来的。</p>
<p><img src="/images/14919793823550/14919872407257.jpg" alt=""></p>
]]></content>
      <categories>
        <category>瞎逼逼</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>NSDictionary</tag>
      </tags>
  </entry>
  <entry>
    <title>DynamicProgramming</title>
    <url>/2020/06/04/DynamicProgramming/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="动态规划套路"><a href="#动态规划套路" class="headerlink" title="动态规划套路"></a>动态规划套路</h2><h4 id="有一个-m-n-大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法"><a href="#有一个-m-n-大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法" class="headerlink" title="有一个 m*n 大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法"></a>有一个 m*n 大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法</h4><h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><ul>
<li>从<code>(1,1)-&gt;(m,n)</code>的不同路径中有大量的重复，比如<code>(1,1)-&gt;(i,j)</code>有 <code>k</code> 条不同的路径，那么对于任何一条固定的路线<code>(i,j)-&gt;(m,n)</code>的路径，都需要走 <code>k</code> 遍来模拟。</li>
<li>不关心具体的走法，只关心状态，也就是走法的数量</li>
<li>同理，如果知道<code>(i,j)-&gt;(m,n)</code>有 <code>k</code> 条不同的路径，那么<code>(1,1)-&gt;(i,j)-&gt;(m,n)</code>的不同路径总数是<code>k*s</code><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5></li>
<li>令<code>(i,j)</code>表示从<code>(1,1)-&gt;(i,j)</code>的不同路径数量，<code>f(i,j) = f(i-1,j) + f(i,j-1)</code></li>
<li>如果要求出 <code>f(i,j)</code> 只需要上一个结果即可， 也就是求解<code>f(i,j)</code> 需要求出子问题<code>f(i&#39;,j&#39;)</code><h5 id="动态规划适用前提"><a href="#动态规划适用前提" class="headerlink" title="动态规划适用前提"></a>动态规划适用前提</h5><h6 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h6></li>
<li>一旦确定<code>f(i,j)</code>，就不用关心如何计算出<code>f(i,j)</code></li>
<li>想要确定<code>f(i,j)</code>，只要知道<code>f(i-1,j)</code>和<code>f(i,j-1)</code><h6 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h6></li>
<li><code>f(i,j)</code>的定义已经蕴含最优</li>
<li>大问题的最优解可以由若干小问题的最优解推出<code>(min, max, sum)</code><blockquote>
<p>DP 适用的问题：可以将大问题拆成几个小问题，且无后效性，具有最优子结构的性质</p>
<h6 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h6></blockquote>
</li>
<li>可以使用递归求解</li>
<li>有重复子问题，overlaping subproblem</li>
</ul>
<span id="more"></span>
<h2 id="套路一：基本类型（时间序列）"><a href="#套路一：基本类型（时间序列）" class="headerlink" title="套路一：基本类型（时间序列）"></a>套路一：基本类型（时间序列）</h2><h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><ul>
<li>给一排房子，相邻的房子不能抢，问最多能抢的价值</li>
<li>房子只有抢和不抢两个状态</li>
<li>和时间相关的为第 <code>i</code> 轮</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0 --&gt; max profit of not rob the i-th house</span></span><br><span class="line">        <span class="comment">// 1 --&gt; max profit of robbing the i-th house</span></span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// if not rob 0 max profit is 0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// if rob 0, max profit is nums[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// if not rob the i-th roby, so the max profit will be the max value of rob/non-rob on last house</span></span><br><span class="line">            <span class="comment">// because if rob on a low price house will not be a good choice</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// if decide to rob i-th , i-1-th must not be robbed</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>], dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="House-Robber-II"><a href="#House-Robber-II" class="headerlink" title="House Robber II"></a>House Robber II</h3><ul>
<li>给一圈“首尾相连”的房子，相邻的房子不能抢，问最多能抢的价值</li>
<li>假定有 n 个房子，因为 0 和 n-1 为相邻的房子。因此可抢的范围为 <code>0 -&gt; n-2</code> 或者 <code>1 -&gt; n-1</code></li>
<li>因此结果就是两个中最大值。<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; houses)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">2</span>) <span class="keyword">return</span> m ? nums[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; robHelper = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r)&#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">            dp[l][<span class="number">1</span>] = nums[l];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(dp[r][<span class="number">0</span>], dp[r][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">robHelper</span>(<span class="number">1</span>, m<span class="number">-1</span>), <span class="built_in">robHelper</span>(<span class="number">0</span>, m<span class="number">-2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a>Best Time to Buy and Sell Stock III</h3><ul>
<li>给定一系列每日股票的价格，每日只能买入、卖出、不操作。最多交易两次，问最大的收益<br><img src="/images/best_time_to_buy_sell_stock.png" alt="BestTimeToBuySellStock.PNG"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 表示这一轮我已经持有第一股的最大收益</span></span><br><span class="line"><span class="comment">    1 表示这一轮我已经售出第一股的最大收益</span></span><br><span class="line"><span class="comment">    2 表示这一轮我已经持有第二股的最大收益</span></span><br><span class="line"><span class="comment">    3 表示这一轮我已经售出第二股的最大收益</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], -val[i]);</span><br><span class="line">      dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + val[i]);</span><br><span class="line">      dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] - val[i]);</span><br><span class="line">      dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>] + val[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  ans = max&#123;dp[n][i]&#125; (i = <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Best-Time-to-buy-and-Sell-Stock-with-cooldown"><a href="#Best-Time-to-buy-and-Sell-Stock-with-cooldown" class="headerlink" title="Best Time to buy and Sell Stock with cooldown"></a>Best Time to buy and Sell Stock with cooldown</h3><ul>
<li>给定一系列股票的加个，每日只能买入、卖出、不操作。买入后要隔卖出，无总交易限制，问最大收益<br><img src="/images/best_time_to_buy_sell_stock_cool_down.png" alt="BestTimeToBuySellStockCoolDown.PNG"><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 表示本轮刚持有股票的最大收益</span></span><br><span class="line"><span class="comment">    1 表示本轮持有一天以上的最大收益</span></span><br><span class="line"><span class="comment">    2 表示我已清空股票的最大收益</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">2</span>] - val[i];</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">    dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + val[i]);</span><br><span class="line">&#125;</span><br><span class="line">ans = max&#123;dp[i][n]&#125; (n = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Wiggle-Subsequence"><a href="#Wiggle-Subsequence" class="headerlink" title="Wiggle Subsequence"></a>Wiggle Subsequence</h3><ul>
<li>给定一个序列 <code>s</code>， 求其最长的<code>wiggle pattern subsequence (.... &gt;s[i] &lt; s[j] &gt; s[j+1]...)</code><br><img src="/images/wiggle_subsequence.png" alt="wiggleSubsequence.PNG"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 以当前元素结尾且上升</span></span><br><span class="line"><span class="comment">    1 一当前元素结尾且下降</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(dp[N][i]) (i = <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Paint-Fence"><a href="#Paint-Fence" class="headerlink" title="Paint Fence"></a>Paint Fence</h3><ul>
<li>给出 <code>cost[i]</code> 表示第 <code>i</code> 个房子喷涂第 <code>j</code> 中 漆的价格，相邻的房子不能涂同一种颜色，求喷涂所有房子的最小价格</li>
</ul>
<p><img src="/images/paint_fence.png" alt="paintFence.PNG"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    dp[i][j] 表示第 i 间房子喷涂第 j 中颜色的代价</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], cost[j]) <span class="comment">// j = 1,2,...,k</span></span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">min</span>(dp[N][j]) (j = <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,...,k)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>To Do or Not To Do</code><br>很多不那么套路的 DP 题目，状态比较难以设计，某些题目会给你“行使某种策略的权利”，想买卖股票的题目，两个状态就分别为“行驶了某种权利”，“没有行使某种权利” 分别对应的价值</p>
</blockquote>
<h3 id="Max-Consecutive-One-II"><a href="#Max-Consecutive-One-II" class="headerlink" title="Max Consecutive One II"></a>Max Consecutive One II</h3><ul>
<li>给定一个数组<code>(0/1)</code>，有最多一次从 <code>0</code> 翻转到 <code>1</code> 的权利，问最多可以有多少连续的 <code>1</code><br><img src="/images/mac_consecutive_ones_ii.png" alt="maxConsecutive.PNG"></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 表示以当前元素结尾且没有行使翻转权利的最长连续 1</span></span><br><span class="line"><span class="comment">    1 表示以当前元素结尾且已经行驶翻转权利的最长连续 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[i], nums[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(dp[i][j]) (<span class="keyword">for</span> all possible i,j = <span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="套路二：基本类型-II（时间序列加强版）"><a href="#套路二：基本类型-II（时间序列加强版）" class="headerlink" title="套路二：基本类型 II（时间序列加强版）"></a>套路二：基本类型 II（时间序列加强版）</h2><ul>
<li>给定一个序列（数组/字符串），其中每个元素可以认为一天，但今天的状态和之前的某一天有关，需要挑选。</li>
<li>套路</li>
</ul>
<blockquote>
<p>定义 dp[i] 表示第 i 轮的状态，一般这个状态要求和元素 i 直接有关系。<br>千方百计将 dp[i] 与之前的状态 dp[i’] 产生关系比如 sum,max,min,<br>dp[i] 一定不能与大于 i 的轮次有关系，否则违反了 DP 的无后效性。</p>
<ul>
<li>最终的结果是 dp[i] 中的某一个<br><img src="/images/pattern_ii.png" alt="patternII"></li>
</ul>
</blockquote>
<h3 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a>Longest Increasing Subsequence</h3><ul>
<li>给定一个数组 s，求最长的递增子序列的长度</li>
</ul>
<blockquote>
<p>状态定义： 照抄问题，dp[i]—&gt; s[1:i]里面以 s[i]为结尾的、最长的递增子序列的长度。<br>状态转移：寻找最优解的前驱状态 j，将 dp[i] 与 dp[j] 产生联系</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="comment">//i 表示 LIS 的最大元素，搜索该 LIS 的第二大元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[j])</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i], dp[j]<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(dp[i]), <span class="keyword">for</span> i in <span class="number">1</span>,...N</span><br></pre></td></tr></table></figure>
<h3 id="Largest-Divisible-Subset"><a href="#Largest-Divisible-Subset" class="headerlink" title="Largest Divisible Subset"></a>Largest Divisible Subset</h3><ul>
<li>给定一个数组 <code>s</code>，求最大子集，使得里面的所有元素之间都可以相互整除。</li>
</ul>
<blockquote>
<p>状态定义：照抄问题，dp[i]—&gt; s[1:i] 以 s[i]为结尾，满足题目要求的最大子集的数目。<br>状态转移：寻找最优的前驱状态 j，将 dp[i] 与 dp[j] 产生联系</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="comment">// i 表示该集合的最大元素，搜索该子集的第二大元素 j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span>)</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i], dp[j]<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(dp[i]) <span class="keyword">for</span> i in <span class="number">1</span>,...,N</span><br></pre></td></tr></table></figure>
<h3 id="Filling-Bookcase-Shelves"><a href="#Filling-Bookcase-Shelves" class="headerlink" title="Filling Bookcase Shelves"></a>Filling Bookcase Shelves</h3><ul>
<li>给定 <code>N</code> 本书（宽高各异）的序列要求按照所给的顺序摆放，相邻的若干本书可以放一层，但同一层的高度不能超过 <code>w</code>。问这个书架最矮可以有多高<br><img src="/images/book_shelf.png" alt="bookShelf"></li>
<li>将数组 S 分成若干个子数组，最小化“每个数组的最大值之和”，输出该值</li>
</ul>
<blockquote>
<p>状态定义：照抄问题 dp[i]—&gt;将数组S[1,…N] 分成若干个子数组，最小化“每个子数组的最大值之和”，保存该值<br>状态转移：寻找最优的前驱状态 j，将 dp[i] 与 dp[j] 产生联系<br>第 i 本书所在的这一层可能有多高？取决于上一层的最后一本书放在那里</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="comment">// i 表示本层最后一本书，搜索上一层最后一本的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (totalWidth[j<span class="number">+1</span>:i] &lt;= W)</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + maxHeight[j<span class="number">+1</span>:i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = dp[N];</span><br></pre></td></tr></table></figure>
<h2 id="套路三：双序列类型"><a href="#套路三：双序列类型" class="headerlink" title="套路三：双序列类型"></a>套路三：双序列类型</h2><ul>
<li>给出两个序列 <code>s</code> 和 <code>t</code>（数组/字符串），对他们搞事情</li>
<li>套路</li>
</ul>
<blockquote>
<p>定义 dp[i][j]: 表示针对 s[1:i] 和 t[1:j] 的子问题求解答<br>千方百计将 dp[i][j] 与之前的状态之间转移 dp[i-1][j], dp[i][j-1] , dp[i-1][j-1]<br>最终的结果是 dp[m][n]</p>
</blockquote>
<h3 id="Longest-Common-subsequences"><a href="#Longest-Common-subsequences" class="headerlink" title="Longest Common subsequences"></a>Longest Common subsequences</h3><ul>
<li>求字符串 s 和 t 的 length of LCS</li>
</ul>
<blockquote>
<p>状态定义：照抄问题 dp[i][j]—&gt; s[1:i] t[1:j]的 length of LCS<br>状态转移：外面两大层循环编译 i 和 j，核心从 s[i] 与 t[j] 的关系作为突破口，往 dp[i-1][j], dp[i][j-1], dpp[i-1][j] 转移</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    s:XXXXXi</span></span><br><span class="line"><span class="comment">    t:YYYj</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Shortest-Common-Supersequence"><a href="#Shortest-Common-Supersequence" class="headerlink" title="Shortest Common Supersequence"></a>Shortest Common Supersequence</h3><ul>
<li>求字符串 <code>s</code> 和 <code>t</code> 的 <code>length of SCS</code></li>
</ul>
<blockquote>
<p>状态定义：照抄问题 dp[i][j]—&gt; s[1:i] 和 t[1:j] 的 length of SCS<br>状态转移：外面两层大循环遍历 i 和 j ：核心从 s[i] 与 t[j] 的关系作为突破口，拼命往 dp[i-1][j], dp[i][j-1], dp[i-1][j-1] 转移<br><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j] + <span class="number">1</span>, dp[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a>Edit Distance</h3><ul>
<li>求字符串 <code>s</code> 和 <code>t</code> 的 <code>min edit distance</code></li>
</ul>
<blockquote>
<p>状态定义：照抄问题 dp[i][j]—&gt; s[1:i] 和 t[1:j] 的 min edit distance<br>状态转移：外面两层大循环遍历 i 和 j ：核心从 s[i] 与 t[j] 的关系作为突破口，拼命往 dp[i-1][j], dp[i][j-1], dp[i-1][j-1] 转移</p>
</blockquote>
<h2 id="套路四：第一类区间类型"><a href="#套路四：第一类区间类型" class="headerlink" title="套路四：第一类区间类型"></a>套路四：第一类区间类型</h2><h2 id="套路五：第二类取件类型"><a href="#套路五：第二类取件类型" class="headerlink" title="套路五：第二类取件类型"></a>套路五：第二类取件类型</h2><h2 id="套路六：背包入门"><a href="#套路六：背包入门" class="headerlink" title="套路六：背包入门"></a>套路六：背包入门</h2><h2 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h2>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Find K-th Smallest Pair Distance</title>
    <url>/2020/07/04/FindKtheSmallestPairDistance/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/">Find K-th Smallest Pair Distance</a><br>Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">nums = [1,3,1]</span><br><span class="line">k = 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">Here are all the pairs:</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">Then the 1st smallest distance pair is (1,1), and its distance is 0.</span><br><span class="line">Note:</span><br><span class="line">2 &lt;= len(nums) &lt;= 10000.</span><br><span class="line">0 &lt;= nums[i] &lt; 1000000.</span><br><span class="line">1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li>给定数组，让在所有的距离对中求第 k 个最小的距离，然后给出距离对的定义是 (a,b) —&gt; a 和 b 的差值</li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><ul>
<li><code>&#123;1,3,1&#125;</code> 数组，可能有的距离对的个数为 n * (n - 1) / 2</li>
<li>所有的距离对为：(1, 3) (1, 1) (3, 1) 他们的距离值为: 2, 0 ,2</li>
<li>因此排在第 1 位的最小的距离对为 (1,1) 结果为 0</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>首先想到的就是暴力解法，我们得知道所有可能的距离对，然后计算每个对的差值，求第 k 个。</li>
<li>转念一想，其实没必要把距离对求出来，只要求出所有可能的差值就行。</li>
<li>但差值可能有好几个，模式点像桶排序，O(n)时间就可完成排序，那么就得知道需要多少个桶。</li>
<li>所以对输入数据进行排序后，最大的值，就知道了，也就知道桶的个数了。</li>
<li>每个桶里放差值的个数即可，就能知道排在第几位的桶有多少个，也就能回答问题</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestDistancePair</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">back</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">freq</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; m; j++)</span><br><span class="line">                <span class="built_in">freq</span>(nums[j]-nums[i])++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            k -= freq[i];</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p> \(\mathcal{O(n^2)}\)</p>
<h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>因此空间复杂度也为 \(\mathcal{O(max(n))}\)</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul>
<li>提交后通过了，但是所有的性能指标是在最后的最后，还是优化一下符合要求</li>
<li>桶排序的内存要求比较高，另外，在求所有元素对的地方耗费太多时间，那个地方也是优化点。</li>
<li>这道题目的步骤大概可以分为两个，首先的知道距离对的内容，然后就是找 k 个满足条件的距离对</li>
<li>距离对的内容，可以使用 dp 来解决，那么 dp 的状态转换方程应该怎么写呢？</li>
</ul>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul>
<li>由于题目让求排在第 k 位的最小的距离对。之前的 lower_bound 是查找≥某个数的第一个位置， upper_bound 是求＞某个数的第一个位置。因此这道题应该是让查：差值，这个差值还得满足至少有 k 个差值是小于等于它的。</li>
<li>因此如果要使用折半查找的数据内容是表示 以上内容的，就可以方便的使用折半查找了。</li>
<li>假定内容是升序排列，假定 <code>d_ij</code> 表示 对于<code>(i,j)</code> 距离对且 <code>i &lt; j</code>，那么 <code>d_id = nums[j] - nums[i]</code></li>
<li>如果 i 位置不变的话，<code>d_ij &lt;= num</code> 就等价于 <code>nums[j] &lt;= nums[i] + num</code></li>
<li>那么也就是说要去找最小的 <code>j</code> 保证 <code>nums[j] &gt; nums[i] + num</code></li>
<li>计数也可以使用双指针，在线性时间下完成<blockquote>
<ul>
<li>假定两个起点 l1 &lt; l2，满足 nums[j1] &gt; nums[i1] + num 和 nums[j2] &gt; nums[i2] + num —-&gt; j2 &gt; j1</li>
</ul>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>Find the Duplicated Number</title>
    <url>/2020/06/27/FindTheDuplicatedNumber/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://bookshadow.com/weblog/2015/09/28/leetcode-find-duplicate-number/">Find the Duplicated Number</a><br>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>Example 2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><br>Note:</p>
<p>You must not modify the array (assume the array is read only).<br>You must use only constant, O(1) extra space.<br>Your runtime complexity should be less than O(n2).<br>There is only one duplicate number in the array, but it could be repeated more than once.</p>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li>给定一个大小为 <code>n+1</code> 的数组，其中每一个数字都是在 <code>1--N</code> 的区间内, 证明至少有一个重复数字是存在的，假定只有唯一的一个重复数字，找到他</li>
<li>不能修改数组, 排序也就不能用了。</li>
<li>常量空间</li>
<li>运行时间要比 N^2要小，那就只剩下 O(n) O(nlogn) O(logn) 的算法可用。</li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><ul>
<li><code>2 -&gt; 4 -&gt; 3</code> = <code>342</code></li>
<li><code>5 -&gt; 6 -&gt; 4</code> = <code>465</code></li>
<li><code>342 + 465 = 807</code></li>
<li>答案 : <code>7 -&gt; 0 -&gt; 8</code></li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>证明至少存在一个重复数字，如果元素是<code>[1,n]</code> 那么就存在 <code>n</code> 个不同的数字，分别将每一个位置都占据了，当数字个数为 <code>n+1</code> 时，那么最少有一个数字是重复的</li>
<li>由于数组的 <code>n+1</code> 个元素的取值范围为 <code>1..n</code>，假定映射关系为 <code>f</code>，那么就存在一个函数 <code>f(i) --&gt;</code> 可以取到 <code>nums[i]</code>，重复的情况就是说存在另一个数字 <code>j</code>，在<code>i != j</code>的前提下，存在 <code>f(i) == f(j)</code>， 那么剩下的问题就是如何将 <code>f</code> 表示出来</li>
<li>就是说使用函数 f。遍历整个数组，总会存在一个位置导致没有办法结束，走入无限循环，也就是类似链表存在环。</li>
<li>证明过程：<a href="http://bookshadow.com/weblog/2015/09/28/leetcode-find-duplicate-number/">证明过程</a></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDubplicated</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> find = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            find = nums[find];</span><br><span class="line">            <span class="keyword">if</span> (slow == find)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Groking The coding Interview</title>
    <url>/2020/11/16/GrokingTheCodeInterview/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode.com/problems/add-two-numbers/">AddTwoNumbers</a><br>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li><code>2</code> 个 <code>非空</code>链表，长度可能不相等</li>
<li>每个链表为<code>逆序</code></li>
<li>返回两个链表的和</li>
<li>每个元素应该为正数</li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><ul>
<li><code>2 -&gt; 4 -&gt; 3</code> = <code>342</code></li>
<li><code>5 -&gt; 6 -&gt; 4</code> = <code>465</code></li>
<li><code>342 + 465 = 807</code></li>
<li>答案 : <code>7 -&gt; 0 -&gt; 8</code></li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>将每一个链表变成整形，然后相加，结果分解成链表不大合适，还得处理越界的情况</li>
<li>比较合理的办法：是一边遍历一边生成链表</li>
<li>每一个生成的节点为两个数的和，有可能产生进位: 如 <code>7+8=15</code></li>
<li>一个节点的结果为：<code>sum = 前一个节点的进位+两个节点的和</code>，<code>res = sum % 10</code>;</li>
<li>一个节点的结果几种情况<ul>
<li><code>last_carry + left + right &lt; 10</code></li>
<li><code>last_carry + left + right &gt;= 10</code></li>
<li><code>只要有进位，就一定会有一个新的节点出现</code></li>
</ul>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *head = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="type">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span> (sum % <span class="number">10</span>);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">var</span> val: <span class="type">Int</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">var</span> next: <span class="type">ListNode</span>?</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">val</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">     <span class="keyword">self</span>.val <span class="operator">=</span> val</span><br><span class="line">     <span class="keyword">self</span>.next <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">addTwoNumbers</span>(<span class="keyword">_</span> <span class="params">l1</span>: <span class="type">ListNode</span>?, <span class="keyword">_</span> <span class="params">l2</span>: <span class="type">ListNode</span>?) -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">    	<span class="keyword">var</span> l1 <span class="operator">=</span> l1</span><br><span class="line">        <span class="keyword">var</span> l2 <span class="operator">=</span> l2</span><br><span class="line">        <span class="keyword">var</span> prev <span class="operator">=</span> <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> carry <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> head <span class="operator">=</span> prev</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">||</span> l2 <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">||</span> carry <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> cur <span class="operator">=</span> <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">let</span> sum <span class="operator">=</span> (l2 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> <span class="number">0</span> : l2<span class="operator">!</span>.val) <span class="operator">+</span> (l1 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> <span class="number">0</span> : l1<span class="operator">!</span>.val) <span class="operator">+</span> carry</span><br><span class="line">            cur.val <span class="operator">=</span> sum <span class="operator">%</span> <span class="number">10</span></span><br><span class="line">            carry <span class="operator">=</span> sum <span class="operator">/</span> <span class="number">10</span></span><br><span class="line">            prev.next <span class="operator">=</span> cur</span><br><span class="line">            prev <span class="operator">=</span> cur</span><br><span class="line">            l1 <span class="operator">=</span> l1 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> l1: l1<span class="operator">?</span>.next</span><br><span class="line">            l2 <span class="operator">=</span> l2 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> l2: l2<span class="operator">?</span>.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>这道题比较简单，递归模式也比较好想到<br>加法需要三个值，两个操作符（来自两个链表）以及一个进位标记。<br>因此递归模式为：</p>
<ul>
<li>递归出口：两个链表都已经到达末尾，并且没有进位</li>
<li>递归实现：<ul>
<li>当前节点的结果为：和/10</li>
<li>当前节点的next节点为：对于两个链表next节点的计算的结果</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2 &amp;&amp; !carry) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> sum = (l1?l1-&gt;val:<span class="number">0</span>) + (l2?l2-&gt;val:<span class="number">0</span>) + carry;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        ans-&gt;next = <span class="built_in">addTwoNumbers</span>(l1?l1-&gt;next:<span class="literal">nullptr</span>, l2?l2-&gt;next:<span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">addTwoNumbers</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>遍历次数：<code>max(len(l1), len(l2)) + 1</code>，因此是线性时间 \(\mathcal{O(max(len(l1), len(l2)))}\)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>额外申请了和一个链表，因此空间复杂度也为 \(\mathcal{O(max(len(l1), len(l2)))}\)</p>
]]></content>
      <categories>
        <category>Groking The Coding Interview</category>
      </categories>
      <tags>
        <tag>educative.io</tag>
      </tags>
  </entry>
  <entry>
    <title>Gray Code Conversion</title>
    <url>/2020/05/22/GrayCode-Conversion/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="来自维基百科"><a href="#来自维基百科" class="headerlink" title="来自维基百科"></a>来自维基百科</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        The purpose of this function is to convert an unsigned</span></span><br><span class="line"><span class="comment">        binary number to reflected binary Gray code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        The operator &gt;&gt; is shift right. The operator ^ is exclusive or.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">binaryToGray</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num &gt;&gt; <span class="number">1</span>) ^ num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        The purpose of this function is to convert a reflected binary</span></span><br><span class="line"><span class="comment">        Gray code number to a binary number.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">grayToBinary</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mask;</span><br><span class="line">    <span class="keyword">for</span> (mask = num &gt;&gt; <span class="number">1</span>; mask != <span class="number">0</span>; mask = mask &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num = num ^ mask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>FishHook 学习笔记</title>
    <url>/2019/12/26/Dynamic-Library/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>0x0 什么是dyld<br>dyld 是加载Mach-O的库，入口是<code>_dyld_start</code>,</p>
<span id="more"></span>]]></content>
      <categories>
        <category>瞎逼逼</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>FishHook</tag>
      </tags>
  </entry>
  <entry>
    <title>LongestSubstringWithoutRepeatingCharacters</title>
    <url>/2019/11/22/LongestSubstringWithoutRepeatingCharacters/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a><br>Given a string, find the length of the longest substring without repeating characters.</p>
<p>Example 1:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is <span class="string">&quot;abc&quot;</span>, with the length of 3.</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is <span class="string">&quot;b&quot;</span>, with the length of 1.</span><br></pre></td></tr></table></figure><br>Example 3:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is <span class="string">&quot;wke&quot;</span>, with the length of 3.</span><br><span class="line">             Note that the answer must be a substring, <span class="string">&quot;pwke&quot;</span> is a subsequence and not a substring.</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li>给定一个字符串，求<code>最长</code>的<code>无重复字符</code>的<code>子串</code></li>
<li>子串：没有重复的字符</li>
<li>子串长度：<code>右边-左边</code></li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h4><ul>
<li>输入：<code>abcabcbb</code></li>
<li>输出：<code>3</code></li>
<li>最长的子串：abc/bca/cab 长度为 3</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>题目要求计算最长子串长度，并且是无重复的子串。</li>
<li>字符串的长度的计算：<code>当前位置-开始位置</code></li>
<li>那么随后的问题就是如何计算开始位置。</li>
<li>如果没有重复子串出现过，那么开始位置就是0，如果重复子串出现过，那么开始位置就是这个位置的下一个位置。</li>
<li>需要一个数据结构来记录每一个字符上一次出现的位置</li>
</ul>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>遍历整个字符串</li>
<li>针对每一个字符，在合适的时候更新<code>left</code>，那么剩下的问题就是何时更新<code>left</code></li>
<li>针对每一个字符，计算并保存最大的长度</li>
<li>遍历完成后返回最大的长度</li>
<li>时间复杂度：线性时间 \(\mathcal{O(n)}\)</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (s.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos_map</span><span class="params">(<span class="number">256</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            start = <span class="built_in">max</span>(pos_map[s[i]]<span class="number">+1</span>, start);</span><br><span class="line">            pos_map[s[i]] = i;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, i - start<span class="number">+1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>如一开始分析：时间复杂度：线性时间 \(\mathcal{O(n)}\)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>额外申请了和一个链表，因此空间复杂度也为 \(\mathcal{O(max(len(l1), len(l2)))}\)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Longest Valid Parentheses</title>
    <url>/2020/04/20/LongestValidParentheses/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/longest-valid-parentheses/">Longest Valid Parentheses</a><br>Given a string containing just the characters ‘(‘ and ‘)’, find the length of the longest valid (well-formed) parentheses substring.</p>
<p>Example 1:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;(()&quot;</span></span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest valid parentheses substring is <span class="string">&quot;</span></span><br><span class="line"><span class="string">()&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>Example 2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;)()())&quot;</span></span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is <span class="string">&quot;()()&quot;</span></span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li>给定字符串，只包含：<code>(</code> , <code>)</code></li>
<li>要求找出最长的合法的括号对长度</li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><ul>
<li><code>(()</code> = <code>2</code></li>
<li>第一个 <code>(</code> 不能与后面的组成合法括号对，所以最长为 2</li>
<li><code>)()())</code> = <code>4</code></li>
<li>因为只有中间的两对为合法括号对，因此为 4</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>括号配对一般都用栈 : <code>stack</code></li>
<li>既然是计数，就得知道从哪个地方开始，匹配的括号肯定是以 <code>(</code> 作为初始值，但要求最长就肯定得知道什么时候连续匹配被截断</li>
<li>如果有匹配的 <code>()</code> 那么就会以<code>(</code>为计数的起点计数。</li>
<li>如果没有匹配的 <code>()</code> 像 <code>)</code> 计数就得从头开始</li>
<li>需要保存到目前为止的最大值</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string&amp; s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk_;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stk_.<span class="built_in">push</span>(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stk_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    start = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> curLen = stk_.<span class="built_in">empy</span>() ? i - start + <span class="number">1</span> : i - stk.<span class="built_in">top</span>();</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, curLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>遍历次数：<code>O(n)</code>，因此是线性时间，每个元素只遍历一次</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><code>O(n)</code> 表示栈的大小</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList</title>
    <url>/2020/06/30/LinkedList/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="链表总结"><a href="#链表总结" class="headerlink" title="链表总结"></a>链表总结</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h3><h4 id="给定链表，删除所有重复元素，使得每一个元素只出现一次"><a href="#给定链表，删除所有重复元素，使得每一个元素只出现一次" class="headerlink" title="给定链表，删除所有重复元素，使得每一个元素只出现一次"></a>给定链表，删除所有重复元素，使得每一个元素只出现一次</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *pre = &amp;dummy, pre-&gt;next = root;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root &amp;&amp; root-&gt;value == pre-&gt;next-&gt;value)</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            pre-&gt;next-&gt;next = root;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;value == cur-&gt;next-&gt;value)</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="给定链表，删除所有的重复元素"><a href="#给定链表，删除所有的重复元素" class="headerlink" title="给定链表，删除所有的重复元素"></a>给定链表，删除所有的重复元素</h4><ul>
<li>树是递归定义的，因此可以用递归求解</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next &amp;&amp; head-&gt;value == head-&gt;next-&gt;value) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head &amp;&amp; head-&gt;next &amp;&amp; head-&gt;value == head-&gt;next-&gt;value) &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deleteDuplicates</span>(head-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="built_in">deleteDuplicates</span>(head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h4><ul>
<li><p>非递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *next = head-&gt;next;</span><br><span class="line">            head-&gt;next = cur;</span><br><span class="line">            cur = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>递归</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *node = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Merge-Two-Lists"><a href="#Merge-Two-Lists" class="headerlink" title="Merge Two Lists"></a>Merge Two Lists</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoList</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            cur = l1;</span><br><span class="line">            cur-&gt;next = <span class="built_in">mergeTwoLists</span>(cur-&gt;next, l2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = l2;</span><br><span class="line">            cur-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, cur-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LowerBound</title>
    <url>/2020/04/25/LowerBound/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="LowerBound"><a href="#LowerBound" class="headerlink" title="LowerBound"></a>LowerBound</h2><p>Lower Bound 是使用二分查找的办法求 大于等于 i 的第一个位置<br><span id="more"></span></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowerBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= i) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(logn)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(1)</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac_NSTextView_中英混输情况下_inline_上下抖动</title>
    <url>/2020/10/05/Mac-NSTextView-%E4%B8%AD%E8%8B%B1%E6%B7%B7%E8%BE%93%E6%83%85%E5%86%B5%E4%B8%8B-inline-%E4%B8%8A%E4%B8%8B%E6%8A%96%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h1><p>今天在做项目的时候，发现自定义的 <code>NSTextView</code> 出现了几种情况比较蛋疼</p>
<ul>
<li><p>对齐问题，英文对齐，中文偏移</p>
</li>
<li><p>在中英文混输的情况下，会出现之前的文字上下抖动的情况，可以拿出来钉钉试试</p>
</li>
</ul>
<blockquote>
<p>先在输入框中输入中文（<code>啊</code>），空格上屏后，再输入一个英文字符 <code>a</code></p>
<p>不断地尝试删除 <code>a</code>，再输入 <code>a</code></p>
<p>你会看到 <code>啊</code> 会随着你的输入和删除上下做轻微的抖动，感觉在拍抖音，给个背景音乐很应景</p>
</blockquote>
<h1 id="自己的项目"><a href="#自己的项目" class="headerlink" title="自己的项目"></a>自己的项目</h1><p>出现了同样的问题，而且更严重的是，同样的输入框，在作为用户签名的时候，中文会有明显的偏移</p>
<blockquote>
<p>英文对齐，中文上偏</p>
</blockquote>
<h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>尝试了很多办法，其实比较简单，让自定义的 <code>layoutManager</code> 和 <code>textContainer</code> 去适配一下。<br>关键代码如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">textStorage.addLayoutManager(layoutManager)</span><br><span class="line">layoutManager.addTextContainer(textContainer)</span><br><span class="line">layoutManager.typesetterBehavior <span class="operator">=</span> .behavior_10_2_WithCompatibility</span><br></pre></td></tr></table></figure>
<p>前后比较一下，所有问题都消失了</p>
]]></content>
      <categories>
        <category>Mac Develop</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Mac Develop</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>单例如何释放</title>
    <url>/2019/12/04/How-To-Release-Singleton-iOS/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="iOS-weak关键字"><a href="#iOS-weak关键字" class="headerlink" title="iOS weak关键字"></a>iOS weak关键字</h1><p>weak 关键字的运用在 iOS 当中属于基础知识，在面试的时候问 weak 的用处，就像两个 iOS 程序员见面寒暄问候一样普通了。</p>
<p>weak 的常见场景是在 delegate，block，NSTimer 中使用，以避免循环引用所带来的内存泄漏，这是教科书式的用法。</p>
<p>编程语言是工具，语言特性只是工具的特性，工具怎么用在于使用者。weak 关键字的方便之处绝不局限于避免循环引用，适当脑洞，可以在其他场景下带来一些有趣的应用。</p>
<p>weak 的用处用一句话可归纳为：弱引用，在对象释放后置为 nil，避免错误的内存访问。用更通俗的话来表述是：weak 可以在不增加对象的引用计数的同时，又使得指针的访问是安全的。</p>
<span id="more"></span>
<h2 id="weak-singleton"><a href="#weak-singleton" class="headerlink" title="weak singleton"></a>weak singleton</h2><p>之前见过一篇文章介绍了一个新 pattern 叫 「weak singleton」。这种特殊的单例有一个有意思的特性：在所有使用该单例的对象都释放后，单例对象本身也会自己释放。我所见过的大部分单例使用场景，被创建都单例最后都会一直存活着，比如注册登录模块所需要共享状态所创建的 XXLoginManager，即使在用户注册成功进入主界面之后也不会被显式的释放，这在一定程度上会带来内存使用的浪费。所谓的「weak singleton」代码很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (id)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    static __weak ASingletonClass *instance;</span><br><span class="line">    ASingletonClass *strongInstance = instance;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        if (strongInstance == nil) &#123;</span><br><span class="line">            strongInstance = [[[self class] alloc] init];</span><br><span class="line">            instance = strongInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return strongInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>「weak singleton」这个漂亮名字背后其实只是简单而巧妙的利用了 weak 特性，sharedInstance 中的 weak 就像是一个智能管家，在无人使用 instance 之后就置为 nil 销毁，当 sharedInstance 再次被调用时，instance 又会重新被创建。</p>
<h2 id="PS-还有另一个方式可以释放单例"><a href="#PS-还有另一个方式可以释放单例" class="headerlink" title="PS: 还有另一个方式可以释放单例"></a>PS: 还有另一个方式可以释放单例</h2><p>主要思路是单例是靠 <code>dispatch_once_t</code> 类型的 <code>token</code> 来确保初始化，只执行一次，来实现单例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static dispatch_once_t * once_token_factory;</span><br><span class="line">+ (ZDocUIFactory *)sharedInstance&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    once_token_factory = &amp;onceToken;</span><br><span class="line">    static id factory = nil;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        factory = [[ZDocUIFactory alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)destoryFactory&#123;</span><br><span class="line">    *once_token_factory = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title>Majority Element</title>
    <url>/2020/06/04/MajorityElement/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/majority-element/">Majority Element</a><br>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example 1:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul>
<li>对每一个元素计数，找到大于 n/2 的元素返回即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map_;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++map_[num] &gt; numbers.<span class="built_in">size</span>() / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>因为满足需求的个数是至少 n / 2， 因此只需要找到排序后处于一半位置的元素就是答案。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">nth_element</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">begin</span>() + numbers.<span class="built_in">size</span>() / <span class="number">2</span>, numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> numbers[numbers.<span class="built_in">size</span>()/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><ul>
<li>递归的找两部分的 majority，最后合并结果，递归出口就是单个元素</li>
<li><code>algorithm</code> 中有个 count 函数，类似于 find，主要是使用一对迭代器和一个值作为参数，返回值出现的次数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        function&lt;<span class="type">int</span>(vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span> ,<span class="type">int</span> )&gt; majorityElementHelper = [&amp;](vector&lt;<span class="type">int</span>&gt; element, <span class="type">int</span> l, <span class="type">int</span> r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> element[l];</span><br><span class="line">            <span class="type">int</span> m = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> lm = <span class="built_in">majorityElementHelper</span>(elements, l, m);</span><br><span class="line">            <span class="type">int</span> rm = <span class="built_in">majorityElementHelper</span>(elements, m<span class="number">+1</span>, r);</span><br><span class="line">            <span class="keyword">if</span> (lm == rm) <span class="keyword">return</span> lm;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">count</span>(nums.<span class="built_in">begin</span>() + l, nums.<span class="built_in">begin</span>() + r + <span class="number">1</span>, lm) &gt; <span class="built_in">count</span>(nums.<span class="built_in">begin</span>() + l, nums.<span class="built_in">begin</span>() + r + <span class="number">1</span>, rm) ? lm : rm;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">majorityElementHelper</span>(numbers,<span class="number">0</span>, numbers.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Moore-Voting-Algorithm"><a href="#Moore-Voting-Algorithm" class="headerlink" title="Moore Voting Algorithm"></a>Moore Voting Algorithm</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, majority;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num:numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!count) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (num == majority) <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> majority = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>, mask = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++, mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> bits = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &amp; mask) &#123;</span><br><span class="line">                    bits++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bits &gt; numbers.<span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">                majority |= mask;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>MedianOfTwoSortedArrays</title>
    <url>/2019/11/23/MedianOfTwoSortedArrays/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">Median of Two Sorted Arrays</a><br>There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure>
<p>Example 2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li>两个数组：m &amp; n （已排好序）</li>
<li>找到两个数组的中间节点</li>
<li>时间复杂度要求：\(\mathcal{O(log(m+n))}\)</li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h4><ul>
<li>nums1：<code>[1, 3]</code></li>
<li>nums2：<code>[2]</code></li>
<li>中间的元素为 2， 因为总共3个元素：1，2，3；</li>
</ul>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h4><ul>
<li>nums1：<code>[1, 2]</code></li>
<li>nums2：<code>[3，4]</code></li>
<li>中间的元素为 2.5， 因为总共4个元素：<code>[1，2，3，4]</code>；（2+3）/2 = 2.5</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>从例子来看，把两个数组的元素分别插入到一个新的数组，然后再遍历找到居中的元素，时间复杂度为\(\mathcal{O(m+n)}\)。</li>
<li>要求时间复杂度为 \(\mathcal{O(log(m+n))}\)，这个算是比较强烈的提示（对n个元素折半查找-<code>BinarySearch</code>就是 \(\mathcal{O(log(n))}\)）</li>
<li>那么剩下的问题就是如何折半，哪里到哪里折半，怎么调整lr.</li>
<li>其实最终的找到的点：左半部分小于右半部分。第一个数组的左半部分小于第二个数组的右半部分，第二个数组的左半部分小于第二个数组的右半部分。并且是合并后数组中间的部分。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> result)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>, r = vec.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">     <span class="type">int</span> mid = (r + l)/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (vec[mid] == result) <span class="keyword">return</span> mid; <span class="comment">// found the result</span></span><br><span class="line">     <span class="keyword">if</span> (vec[mid] &gt; result) &#123; <span class="comment">// the index is on the left side of mid</span></span><br><span class="line">         r = mid;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         l = mid<span class="number">+1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> result)</span></span>&#123;</span><br><span class="line">     <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (vec[mid] == result) <span class="keyword">return</span> mid;</span><br><span class="line">     <span class="keyword">if</span> (vec[mid] &gt; result) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">binarySearch</span>(vec, l, mid, result);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">binarySearch</span>(vec, mid<span class="number">+1</span>, r, result);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>假定合并后的数组为C</li>
<li>从第一个数组取m1个元素，第二个元素取m2个元素，来构成前k个元素，来满足第k/k+1个元素就是中位数的候选数。其中k = m1 + m2 = (m + n + 1)/2。加 1 是为了不用考虑奇偶。</li>
<li>找到的元素为 \(\mathcal{Avg(max(A[m-1], B[n-1]), min(A[m],B[n]))}\),根据总数奇数和偶数。<br>*</li>
</ul>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>如果某一个为空，则返回另一个数组的中间元素即可<br>*</li>
<li>遍历完成后返回最大的长度</li>
<li>时间复杂度：线性时间 \(\mathcal{O(n)}\)</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMediaSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="built_in">findMediaSortedArrays</span>(nums2, nums1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>如一开始分析：时间复杂度：线性时间 \(\mathcal{O(n)}\)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>额外申请了和一个链表，因此空间复杂度也为 \(\mathcal{O(max(len(l1), len(l2)))}\)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</title>
    <url>/2019/12/11/MinimumNumberofFlipsToConvertBinaryMatrixToZero/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/">Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</a><br>Given a m x n binary matrix mat. In one step, you can choose one cell and flip it and all the four neighbours of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighboors if they share one edge.</p>
<p>Return the minimum number of steps required to convert mat to a zero matrix or -1 if you cannot.</p>
<p>Binary matrix is a matrix with all cells equal to 0 or 1 only.</p>
<p>Zero matrix is a matrix with all cells equal to 0.</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: mat = [[0,0],[0,1]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: One possible solution is to flip (1, 0) <span class="keyword">then</span> (0, 1) and finally (1, 1) as shown.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: mat = [[0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Given matrix is a zero matrix. We don<span class="string">&#x27;t need to change it.</span></span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: mat = [[1,1,1],[1,0,1],[0,0,0]]</span><br><span class="line">Output: 6</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: mat = [[1,0,0],[1,0,0]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: Given matrix can<span class="string">&#x27;t be a zero matrix</span></span><br></pre></td></tr></table></figure>
<p>Constraints:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">m == mat.length</span><br><span class="line">n == mat[0].length</span><br><span class="line">1 &lt;= m &lt;= 3</span><br><span class="line">1 &lt;= n &lt;= 3</span><br><span class="line">mat[i][j] is 0 or 1.</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li>给定一个数组 m * n</li>
<li>数字只有 <code>0</code> 或者 <code>1</code></li>
<li>flip 时必须：五个相邻数字（自己、上、下、左、右）。</li>
<li>目标状态为全部为 0</li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h4><ul>
<li>S：<code>[[0, 0], [0, 1]]</code></li>
<li>结果：3</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>看到题目应该就会反映到会使用<code>BFS</code>来解决问题：（每次拓展上下左右和自己）</li>
<li>每次拓展的时候回尝试将周边的数字进行翻转</li>
<li>终止状态：找到全0、全部遍历完毕，并且记录步数。</li>
<li>因为只有0/1两个数字。因此可以考虑使用状态压缩来将二维数组进行降维。</li>
<li>考虑将例子中的二维数组：<code>[[0,0],[0,1]]</code> —-&gt; <code>[0001]</code>,这样时间复杂度就会缩短。</li>
</ul>
<h4 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h4><ul>
<li>可以把划分想象成两个部分，左边和右边。</li>
<li>左边：是从 0…j 进行 k-1 次的划分。右边： 一次划分（）。</li>
<li><code>dp_[i][k] = min&#123;dp_[i][k], dp_[j][k-1] + dp_change[j][i]&#125;</code></li>
<li><code>dp_change[j][i]</code> 表示从j到i 的最小更换次数。</li>
</ul>
<h4 id="更改字符"><a href="#更改字符" class="headerlink" title="更改字符"></a>更改字符</h4><ul>
<li>如果划分确定后，如何更改字符就比较好确定了</li>
<li>回文字符串应该从中间开始构建，并且向两边拓展</li>
<li>如果前后两个字符相等<code>(str[i] == str[j]): dp_change[i][j] = dp_change[i+1][j-1]</code></li>
<li>如果前后两个字符不等<code>(str[i] != str[j]): dp_change[i][j] = 1 + dp_change[i+1][j-1]</code></li>
<li><code>dp_change[i][j] = (str[i] != str[j]) + dp_change[i+1][j-1]</code></li>
</ul>
<p>解决了以上两个问题，那完整的问题，就解决了</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>异常判断</li>
<li>针对所有的位置，尝试所有的分割，</li>
</ul>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">palindromePartition</span><span class="params">(string &amp;str, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMediaSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="built_in">findMediaSortedArrays</span>(nums2, nums1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>如一开始分析：时间复杂度：线性时间 \(\mathcal{O(n)}\)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>额外申请了和一个链表，因此空间复杂度也为 \(\mathcal{O(max(len(l1), len(l2)))}\)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>Single Number II</title>
    <url>/2020/05/30/SingleNumberII/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/single-number-ii/">Single Number II</a><br>Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.</p>
<p>Note:</p>
<p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>
<p>Example 2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li>给定一个数组，里面的元素均出现了 <code>K(K &gt; 1)</code> 次,出了一个元素出现 P(P&gt;=1 , P % K != 0) 次，让找到这个元素。<br>gi</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>首先构建一个计数器，可以实现对 01 数组进行计数，每次遇见1 counter 自增，如果自增至 K，则 counter 重至为 0<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counter</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">if</span> i:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> counter == k:</span><br><span class="line">            count = <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li>那么什么位操作遇到 0 不变，遇到 1 自增，也就是资深取反（因为自增碰到 1 会变成 0）</li>
<li>对于某一位数字 0 或者 1 来讲：</li>
<li>碰到 0 不变的操作有两个： <code>x = x | 0</code> 另一个是 <code>x = x ^ 0</code></li>
<li>但异或(<code>XOR</code>)操作明显更加合适: <code>1 ^ 1 = 0</code> , <code>0 ^ 1 = 1</code>, <code>0 ^ 0 = 0</code></li>
<li>因此对于 <code>counter</code> 来讲， <code>counter = counter ^ 1</code><br>*</li>
<li>但题目需要覆盖 K 位，那就是  <code>2 ^ m &gt;= K</code>，因此需要 最少 <code>logk</code> 个</li>
<li>因此 m 位从高到低为<code>C[m], C[m-1],... C[1]</code></li>
<li>对于最低位 : <code>C[1] = C[1] ^ i</code>;</li>
<li>对于<code>C[2]</code>，只有前一位为 1 的时候才进位，<code>C[2] = C[2] ^ (C[1] &amp; i)</code></li>
<li>对于<code>C[k]</code>, 进位条件 <code>i == 1 &amp;&amp; C[j] == 1 for all j &lt; k</code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">        C[m] ^= (c[m-<span class="number">1</span>] &amp; c[m-<span class="number">2</span>] &amp; .... C[<span class="number">1</span>] &amp; i)</span><br><span class="line">        ...</span><br><span class="line">        C[<span class="number">2</span>] ^= C[<span class="number">1</span>] &amp; i</span><br><span class="line">        C[<span class="number">1</span>] ^= i</span><br><span class="line">        // 要从最高位开始更新</span><br></pre></td></tr></table></figure></li>
<li>但更新策略还不完整，需要达到阈值的时候变成 0</li>
<li>因此需要一个 <code>mask = 0 if counter == k else 1</code></li>
<li>于是每次更新的时候 <code>C[i] &amp; mask</code></li>
<li>假设 k 的二进制形式为 k[m], k[m-1]…k[1]</li>
<li>那么 <code>mask =  ~(y1 &amp; y2 ... &amp; ym) where yj = cj if kj = 1 else yj = ~ cj</code></li>
<li>这样子的话当c == k时，yj全部等于1，mask值为0，而 c != k时，yj必不全为1，则mask值必为1.<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i in array:</span><br><span class="line"> 	c[m] ^= (c[m<span class="number">-1</span>] &amp; c[m<span class="number">-2</span>] &amp; ... &amp; c[<span class="number">1</span>] &amp; i)</span><br><span class="line">   ...</span><br><span class="line">   c[<span class="number">2</span>] ^= (c[<span class="number">1</span>] &amp; i)</span><br><span class="line">   c[<span class="number">1</span>] ^= i  # 注意要先从高位开始更新</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> j in <span class="built_in">range</span>(m):</span><br><span class="line">     	y[j] = c[j] <span class="keyword">if</span> k[j] <span class="keyword">else</span> ~c[j]</span><br><span class="line">   mask = ~(y[<span class="number">1</span>] &amp; y[<span class="number">2</span>] ... &amp; y[m])</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> j in <span class="built_in">range</span>(m):</span><br><span class="line">     	c[m] &amp;= mask</span><br><span class="line">       ...</span><br><span class="line">       c[<span class="number">1</span>] &amp;= mask</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c1 = <span class="number">0</span></span><br><span class="line">c2 = <span class="number">0</span></span><br><span class="line">m = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i in nums:</span><br><span class="line">  	c2 ^= c1 &amp; i</span><br><span class="line">    c1 ^= i</span><br><span class="line">    mask = ~(c1 &amp; c2) <span class="meta"># k = 3, 二进制形式为11，则c1和c2都不用取反</span></span><br><span class="line">    c1 &amp;= mask</span><br><span class="line">    c2 &amp;= mask</span><br><span class="line"><span class="keyword">return</span> c1 <span class="meta"># p = 1, 则最后c1 = single</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Palindrome Paritioning III</title>
    <url>/2019/12/04/ParlindromPartition-III/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/contest/weekly-contest-165/problems/palindrome-partitioning-iii/">Palindrome Partitioning III</a><br>You are given a string s containing lowercase letters and an integer k. You need to :</p>
<p>First, change some characters of s to other lowercase English letters.<br>Then divide s into k non-empty disjoint substrings such that each substring is palindrome.<br>Return the minimal number of characters that you need to change to divide the string.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: s = <span class="string">&quot;abc&quot;</span>, k = 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You can <span class="built_in">split</span> the string into <span class="string">&quot;ab&quot;</span> and <span class="string">&quot;c&quot;</span>, and change 1 character <span class="keyword">in</span> <span class="string">&quot;ab&quot;</span> to make it palindrome.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: s = <span class="string">&quot;aabbc&quot;</span>, k = 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: You can <span class="built_in">split</span> the string into <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span> and <span class="string">&quot;c&quot;</span>, all of them are palindrome.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: s = <span class="string">&quot;leetcode&quot;</span>, k = 8</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>Constraints:</p>
<p>1 &lt;= k &lt;= s.length &lt;= 100.<br>s only contains lowercase English letters.</p>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li>给定字符串s，和整数k</li>
<li>改变s中的一些字符</li>
<li>将s划分问k个非空回文子串</li>
<li>求最小的更改字符的次数</li>
<li>强烈提示：字符串长度最长100 —&gt; 时间复杂度最多10^6 （也就是n^3）</li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h4><ul>
<li>S：<code>abc</code></li>
<li>K：<code>2</code></li>
<li>结果：1</li>
<li>将S划分为两个部分：<code>ab</code>、<code>c</code>，修改ab中的一个字符即可变成回文</li>
</ul>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h4><ul>
<li>S：<code>aabbc</code></li>
<li>K：<code>3</code></li>
<li>结果：0</li>
<li>将S划分为：aa、bb、c，所有的都是回文，不需要更改。</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>强烈提示：数据规模 — 10^2，也就是说期望的时间复杂度为 n^3 or n^2 * k</li>
<li>计数问题，一般可以用动态规划解决。</li>
<li>题目要求k次划分，如何划分需要解决，使用动态规划一般和 <code>k-1</code> 有关系。</li>
<li>划分后，针对子串如何更换，也需要解决，并且求最小值。</li>
<li>所以就两个子问题：1. 如何划分。2.如何更换。</li>
<li><code>dp_[i][k]</code>,表示0…i的字符，进行k次划分的最小交换次数</li>
</ul>
<h4 id="划分"><a href="#划分" class="headerlink" title="划分"></a>划分</h4><ul>
<li>可以把划分想象成两个部分，左边和右边。</li>
<li>左边：是从 0…j 进行 k-1 次的划分。右边： 一次划分（）。</li>
<li><code>dp_[i][k] = min&#123;dp_[i][k], dp_[j][k-1] + dp_change[j][i]&#125;</code></li>
<li><code>dp_change[j][i]</code> 表示从j到i 的最小更换次数。</li>
</ul>
<h4 id="更改字符"><a href="#更改字符" class="headerlink" title="更改字符"></a>更改字符</h4><ul>
<li>如果划分确定后，如何更改字符就比较好确定了</li>
<li>回文字符串应该从中间开始构建，并且向两边拓展</li>
<li>如果前后两个字符相等<code>(str[i] == str[j]): dp_change[i][j] = dp_change[i+1][j-1]</code></li>
<li>如果前后两个字符不等<code>(str[i] != str[j]): dp_change[i][j] = 1 + dp_change[i+1][j-1]</code></li>
<li><code>dp_change[i][j] = (str[i] != str[j]) + dp_change[i+1][j-1]</code></li>
</ul>
<p>解决了以上两个问题，那完整的问题，就解决了</p>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>异常判断</li>
<li>针对所有的位置，尝试所有的分割，</li>
</ul>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">palindromePartition</span><span class="params">(string &amp;str, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMediaSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="built_in">findMediaSortedArrays</span>(nums2, nums1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>如一开始分析：时间复杂度：线性时间 \(\mathcal{O(n)}\)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>额外申请了和一个链表，因此空间复杂度也为 \(\mathcal{O(max(len(l1), len(l2)))}\)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>莫里斯遍历二叉树</title>
    <url>/2019/12/03/Moris-Traversal-Binary-Tree/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol>
<li>遍历二叉树</li>
<li>O(1)的时间复杂度</li>
<li>二叉树的形状不能破坏</li>
</ol>
<span id="more"></span>
<h2 id="常规遍历"><a href="#常规遍历" class="headerlink" title="常规遍历"></a>常规遍历</h2><p>常规遍历使用递归，一般需要O(n)的空间复杂度和O(n)的时间复杂度。</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure>
<p>Example 2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li>两个数组：m &amp; n （已排好序）</li>
<li>找到两个数组的中间节点</li>
<li>时间复杂度要求：\(\mathcal{O(log(m+n))}\)</li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子 1"></a>例子 1</h4><ul>
<li>nums1：<code>[1, 3]</code></li>
<li>nums2：<code>[2]</code></li>
<li>中间的元素为 2， 因为总共3个元素：1，2，3；</li>
</ul>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子 2"></a>例子 2</h4><ul>
<li>nums1：<code>[1, 2]</code></li>
<li>nums2：<code>[3，4]</code></li>
<li>中间的元素为 2.5， 因为总共4个元素：<code>[1，2，3，4]</code>；（2+3）/2 = 2.5</li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>从例子来看，把两个数组的元素分别插入到一个新的数组，然后再遍历找到居中的元素，时间复杂度为\(\mathcal{O(m+n)}\)。</li>
<li>要求时间复杂度为 \(\mathcal{O(log(m+n))}\)，这个算是比较强烈的提示（对n个元素折半查找-<code>BinarySearch</code>就是 \(\mathcal{O(log(n))}\)）</li>
<li>顺着思路想：折半查找的问题就是如何使用折半查找找到需要的数，</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> result)</span></span>&#123;</span><br><span class="line">  <span class="type">int</span> l = <span class="number">0</span>, r = vec.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">     <span class="type">int</span> mid = (r + l)/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (vec[mid] == result) <span class="keyword">return</span> mid; <span class="comment">// found the result</span></span><br><span class="line">     <span class="keyword">if</span> (vec[mid] &gt; result) &#123; <span class="comment">// the index is on the left side of mid</span></span><br><span class="line">         r = mid;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         l = mid<span class="number">+1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> result)</span></span>&#123;</span><br><span class="line">     <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (vec[mid] == result) <span class="keyword">return</span> mid;</span><br><span class="line">     <span class="keyword">if</span> (vec[mid] &gt; result) &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">binarySearch</span>(vec, l, mid, result);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="built_in">binarySearch</span>(vec, mid<span class="number">+1</span>, r, result);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>假定合并后的数组为C</li>
<li>从第一个数组取m1个元素，第二个元素取m2个元素，来构成前k个元素，来满足第k/k+1个元素就是中位数的候选数。其中k = m1 + m2 = (m + n + 1)/2。</li>
<li>找到的元素为 \(\mathcal{Avg(max(A[m-1], B[n-1]), min(A[m],B[n]))}\),根据总数奇数和偶数。</li>
<li>对左边的数组，在左边数组的区间内进行二分搜索， ，</li>
</ul>
<h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><ul>
<li>如果某一个为空，则返回另一个数组的中间元素即可<br>*</li>
<li>遍历完成后返回最大的长度</li>
<li>时间复杂度：线性时间 \(\mathcal{O(n)}\)</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMediaSortedArrays</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = nums<span class="number">1.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums<span class="number">2.</span><span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> <span class="built_in">findMediaSortedArrays</span>(nums2, nums1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>如一开始分析：时间复杂度：线性时间 \(\mathcal{O(n)}\)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>额外申请了和一个链表，因此空间复杂度也为 \(\mathcal{O(max(len(l1), len(l2)))}\)</p>
]]></content>
      <categories>
        <category>Binary Tree</category>
      </categories>
  </entry>
  <entry>
    <title>Swift-Algorithm-Stack</title>
    <url>/2019/11/22/SwiftAlgorithm-Stack/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/two-sum/">TwoSum</a><br>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line"><span class="built_in">return</span> [0, 1].</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li><code>整形</code>数组 <code>nums</code></li>
<li>是否有序未知</li>
<li>\(\mathcal{target}=\mathcal{num[idx1]}-\mathcal{num[idx2]} | idx1 \ne idx2\)</li>
<li>一定有解</li>
<li>同样元素不能用两次</li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><ul>
<li><code>nums = [2, 7, 11, 15]</code></li>
<li><code>target = 9</code></li>
<li>对于 <code>idx = 0</code>. <code>nums[idx] = 2</code></li>
<li>需要找到 <code>nums[idx2] = target - nums[idx]</code> —&gt; <code>7</code></li>
<li><code>nums[idx2] = 7</code> <code>idx2 = 1</code></li>
<li><code>[0, 1]</code></li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>例子中，找到 <code>target-nums[idx]</code> 并不够，还要找到 <code>target-nums[idx]</code> 对应的<code>index</code></li>
<li>因此需要建立 <code>index</code> 和 <code>value</code> 的关系</li>
<li>关系建立好之后</li>
<li>对于每一个元素 <code>idx</code> ，查找 <code>target-nums[idx]</code> 以及对应的<code>index</code></li>
<li>找到就返回结果，未找到返回空</li>
<li>出入参合法性判断</li>
<li>需要的数据结构：</li>
<li><code>unordered_map&lt;int,int&gt;</code> 哈希表，分别存放 <code>value,index</code></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map_;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map_.<span class="built_in">count</span>(nums[i])) &#123;</span><br><span class="line">                map_[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> num_to_find = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map_.<span class="built_in">count</span>(num_to_find) &amp;&amp; map_[num_to_find] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, map_[num_to_find]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>每个元素只遍历一次，因此是线性时间 \(\mathcal{O(n)}\)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>额外申请了和数组长度一样的哈希表，因此空间复杂度也为 \(\mathcal{O(n)}\)</p>
]]></content>
      <categories>
        <category>Algorithm</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>SweepLine</title>
    <url>/2020/09/22/SweepLine/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天做了一道题，<a href="https://leetcode.com/problems/subarray-sum-equals-k/">LeetCode 560. Subarray Sum Equals K</a>，有点蒙蔽，看了答案发现比较简单，记录一下</p>
<p>给定一个整数数组和一个整数 <code>k</code>，你需要找到该数组中和为 <code>k</code> 的连续的子数组的个数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">示例 1 :</span><br><span class="line"></span><br><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br><span class="line">说明 :</span><br><span class="line"></span><br><span class="line">数组的长度为 [1, 20,000]。</span><br><span class="line">数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目的意思比较明确，要求找到 <code>n</code> 个连续的子数组，并且这些连续子数组的和为 <code>k</code></p>
<ul>
<li>子数组求和</li>
<li>子数组求和可以使用前缀和，那么如何知道它能够满足需求? 前缀和可以知道具体区间的和，那么区间终点的值 -k，就是这段区间的起点。</li>
<li>需要一个哈希表，来记录上次出现该值得地方，找到 <code>cur-k</code> 就是找到了和位 <code>k</code> 的区间起点。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">subArraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; memo_;</span><br><span class="line">    memo_[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">      pre += num;</span><br><span class="line">      <span class="keyword">if</span> (memo_.<span class="built_in">find</span>(pre - k) != memo_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        ans += memo_[pre - k];</span><br><span class="line">      &#125;</span><br><span class="line">      memo_[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>SuperSign</title>
    <url>/2020/04/17/SuperSign/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="超级签名"><a href="#超级签名" class="headerlink" title="超级签名"></a>超级签名</h1><h2 id="证书类型"><a href="#证书类型" class="headerlink" title="证书类型"></a>证书类型</h2><div class="table-container">
<table>
<thead>
<tr>
<th>整数类型</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发(Development)证书和描述文件</td>
<td>用于开发测试，在Xcode中打包后，可在真机环境调试、安装</td>
</tr>
<tr>
<td>发布(Distribution)证书和描述文件</td>
<td>* 发布(Distribution)证书和描述文件:用于提交Appstore，在Xcode中打包后，可使用Xcode、Application Loader提交到Appstore审核发布</td>
</tr>
</tbody>
</table>
</div>
<span id="more"></span>
<h2 id="证书作用"><a href="#证书作用" class="headerlink" title="证书作用"></a>证书作用</h2><div class="table-container">
<table>
<thead>
<tr>
<th>证书</th>
<th>文件后缀</th>
<th>文件类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>Provisioning Profile</td>
<td>.mobileprovision</td>
<td>描述文件</td>
<td>绑定设备UDID，所以在申请开发描述文件之前，先添加调试的设备。</td>
</tr>
<tr>
<td>Signing Certificate</td>
<td>.cer/.p12</td>
<td>证书文件</td>
<td>有开发和发布的证书，可以在钥匙串查看安装的可用的证书，过期时间等。p12是一个加密的文件，只要知道其密码，就可以供给所有的 Mac 设备使用，是这个应用的唯一标识证书和开发者，用于对应 bundleID 的应用开发和打包测试</td>
</tr>
</tbody>
</table>
</div>
<p>如果是团队开发，一般会生成 p12 给组员使用，方便管理证书</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>证书名字</th>
<th>类型</th>
<th>证书用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>adhocXXX.mobileprovision</td>
<td>描述文件</td>
<td>用于生成 adhoc 包时，描述可以安装ipa包的设备UDID和证书关系。（包含推送、apple pay等权限声明内容）</td>
</tr>
<tr>
<td>devXXX.mobileprovision</td>
<td>描述文件</td>
<td>用于生成 dev 包时，描述可以安装ipa包的设备UDID和证书关系。（包含推送、apple pay等权限声明内容）</td>
</tr>
<tr>
<td>devXXXPushXXX.p12</td>
<td>推送证书</td>
<td>用于 dev 包推送时，认证和关联 应用bundleID 的证书关系</td>
</tr>
<tr>
<td>devXXX.p12</td>
<td>开发证书</td>
<td>用于打包App时，生成 dev 的 ipa 包需要的开发者信息。</td>
</tr>
<tr>
<td>disXXX.mobileprovision</td>
<td>描述文件</td>
<td>用于生成 dis 包时，描述应用bundleID与证书的关系。（包含推送、apple pay等权限声明内容）。</td>
</tr>
<tr>
<td>disXXXPushXXX.p12</td>
<td>推送证书</td>
<td>用于 dis（或adhoc） 包推送时，认证和关联 应用bundleID 的证书关系。</td>
</tr>
<tr>
<td>disXXX.p12</td>
<td>发布证书</td>
<td>用于打包App时，生成 dis (或adhoc) 的 ipa 包需要的开发者信息。</td>
</tr>
</tbody>
</table>
</div>
<h2 id="证书类型的说明"><a href="#证书类型的说明" class="headerlink" title="证书类型的说明"></a>证书类型的说明</h2><div class="table-container">
<table>
<thead>
<tr>
<th>用途</th>
<th>dev</th>
<th>adhoc</th>
<th>dis</th>
<th>企业证书</th>
</tr>
</thead>
<tbody>
<tr>
<td>用于送审</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>F</td>
</tr>
<tr>
<td>未越狱，未在证书中的设备能否安装</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>T</td>
</tr>
<tr>
<td>未越狱，在证书中的设备能否安装</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>T</td>
</tr>
<tr>
<td>越狱能否安装</td>
<td>T</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
<tr>
<td>能否用于送审 TestFlight</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
</tr>
<tr>
<td>不越狱能否打开应用的 Document 等</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>如果需要添加新设备的 UDID，只要更新 .mobileprovision 描述文件既可以</li>
<li><p>如果证书过期，.p12 和 .mobileprovision 文件需要重新生成，如果 revoke后生成新的证书，旧的证书和证书对应的 ipa 不能再安装在设备上</p>
</li>
<li><p>描述文件保存在 macOS 路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/Library/MobileDevice/Provisioning\ Profiles/</span><br></pre></td></tr></table></figure></li>
<li>查看安装的证书使用命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">security find-identity -p codesigning -v</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="获取-UDID"><a href="#获取-UDID" class="headerlink" title="获取 UDID"></a>获取 UDID</h2><h2 id="使用配置文件获取"><a href="#使用配置文件获取" class="headerlink" title="使用配置文件获取"></a>使用配置文件获取</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">plist</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plist</span> <span class="attr">version</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PayloadContent<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dict</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>URL<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">string</span>&gt;</span>https://your.hostname/receive.php<span class="tag">&lt;/<span class="name">string</span>&gt;</span> <span class="comment">&lt;!--接收数据的接口地址--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>DeviceAttributes<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>UDID<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>IMEI<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>ICCID<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>VERSION<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">string</span>&gt;</span>PRODUCT<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PayloadOrganization<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>your orignation name<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  <span class="comment">&lt;!--组织名称--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PayloadDisplayName<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>Obtain UDID<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  <span class="comment">&lt;!--安装时显示的标题--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PayloadVersion<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">integer</span>&gt;</span>1<span class="tag">&lt;/<span class="name">integer</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PayloadUUID<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>3C4DC7D2-E475-3375-489C-0BB8D737A653<span class="tag">&lt;/<span class="name">string</span>&gt;</span>  <span class="comment">&lt;!--自己随机填写的唯一字符串，生成的就可以--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PayloadIdentifier<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>your identifier<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PayloadDescription<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>Obtaining UDID<span class="tag">&lt;/<span class="name">string</span>&gt;</span>   <span class="comment">&lt;!--描述--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">key</span>&gt;</span>PayloadType<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">string</span>&gt;</span>Profile Service<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dict</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plist</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>需要填写回调数据的 <code>URL</code> 和 <code>PayloadUUID</code>。该<code>PayloadUUID</code>仅仅是随机生成的唯一字符串,类似<code>bundleid</code>，一般是域名倒置，用来标识唯一。</p>
</li>
<li><p><code>mobileconfig</code>中的URL要用<code>https</code>地址。否则  <code>https://your.hostname/receive.php</code> 会报ATS错误。</p>
</li>
</ul>
<h2 id="mobileconfig-文件签名"><a href="#mobileconfig-文件签名" class="headerlink" title="mobileconfig 文件签名"></a>mobileconfig 文件签名</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">security cms -S -N <span class="string">&quot;Apple Development: XXX&quot;</span> -i udid.mobileconfig -o udid.signed.mobileconfig</span><br></pre></td></tr></table></figure>
<p>这个地方使用自己的开发者账号就行，具体的内容打开<code>keychain</code>，我的账号是绑定在公司的 <code>team</code> 里面，就用它签名就行</p>
<h2 id="receive-php"><a href="#receive-php" class="headerlink" title="receive.php"></a>receive.php</h2><p>安装成功后，系统会自动回调 <code>mobileconfig</code> 中的地址</p>
<h2 id="服务器端支持-ssl"><a href="#服务器端支持-ssl" class="headerlink" title="服务器端支持 ssl"></a>服务器端支持 ssl</h2><p>这块在本地我用的 <code>mamp pro</code> 来搞的，比较傻瓜化</p>
<h2 id="index-php"><a href="#index-php" class="headerlink" title="index.php"></a>index.php</h2><ul>
<li>为了测试方便，就放了个按钮，指向旁边的 <code>mobileconfig</code> 文件<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;title-box&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;buttons&quot;</span> <span class="attr">href</span>=<span class="string">&quot;udid.signed.mobileconfig&quot;</span><span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span>获取UDID</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="receive-php-1"><a href="#receive-php-1" class="headerlink" title="receive.php"></a>receive.php</h2><ul>
<li>主要做的事情是解析上传的内容，并且跳转到新的页面</li>
<li>跳转是必须的</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$data</span> = <span class="title function_ invoke__">file_get_contents</span>(<span class="string">&#x27;php://input&#x27;</span>);</span><br><span class="line"><span class="variable">$plistBegin</span>   = <span class="string">&#x27;&lt;?xml version=&quot;1.0&quot;&#x27;</span>;</span><br><span class="line"><span class="variable">$plistEnd</span>   = <span class="string">&#x27;&lt;/plist&gt;&#x27;</span>;</span><br><span class="line"><span class="variable">$pos1</span> = <span class="title function_ invoke__">strpos</span>(<span class="variable">$data</span>, <span class="variable">$plistBegin</span>);</span><br><span class="line"><span class="variable">$pos2</span> = <span class="title function_ invoke__">strpos</span>(<span class="variable">$data</span>, <span class="variable">$plistEnd</span>);</span><br><span class="line"><span class="variable">$data2</span> = <span class="title function_ invoke__">substr</span> (<span class="variable">$data</span>,<span class="variable">$pos1</span>,<span class="variable">$pos2</span>-<span class="variable">$pos1</span>);</span><br><span class="line"><span class="variable">$xml</span> = <span class="title function_ invoke__">xml_parser_create</span>();</span><br><span class="line"><span class="title function_ invoke__">xml_parse_into_struct</span>(<span class="variable">$xml</span>, <span class="variable">$data2</span>, <span class="variable">$vs</span>);</span><br><span class="line"><span class="title function_ invoke__">xml_parser_free</span>(<span class="variable">$xml</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$UDID</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$CHALLENGE</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$DEVICE_NAME</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$DEVICE_PRODUCT</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$DEVICE_VERSION</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$iterator</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$arrayCleaned</span> = <span class="keyword">array</span>();</span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$vs</span> <span class="keyword">as</span> <span class="variable">$v</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$v</span>[<span class="string">&#x27;level&#x27;</span>] == <span class="number">3</span> &amp;&amp; <span class="variable">$v</span>[<span class="string">&#x27;type&#x27;</span>] == <span class="string">&#x27;complete&#x27;</span>)&#123;</span><br><span class="line">        <span class="variable">$arrayCleaned</span>[]= <span class="variable">$v</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable">$iterator</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$data</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="variable">$iterator</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arrayCleaned</span> <span class="keyword">as</span> <span class="variable">$elem</span>)&#123;</span><br><span class="line">    <span class="variable">$data</span> .= <span class="string">&quot;\n==&quot;</span>.<span class="variable">$elem</span>[<span class="string">&#x27;tag&#x27;</span>].<span class="string">&quot; -&gt; &quot;</span>.<span class="variable">$elem</span>[<span class="string">&#x27;value&#x27;</span>].<span class="string">&quot;&lt;br/&gt;&quot;</span>;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="variable">$elem</span>[<span class="string">&#x27;value&#x27;</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;CHALLENGE&quot;</span>:</span><br><span class="line">            <span class="variable">$CHALLENGE</span> = <span class="variable">$arrayCleaned</span>[<span class="variable">$iterator</span>+<span class="number">1</span>][<span class="string">&#x27;value&#x27;</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;DEVICE_NAME&quot;</span>:</span><br><span class="line">            <span class="variable">$DEVICE_NAME</span> = <span class="variable">$arrayCleaned</span>[<span class="variable">$iterator</span>+<span class="number">1</span>][<span class="string">&#x27;value&#x27;</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;PRODUCT&quot;</span>:</span><br><span class="line">            <span class="variable">$DEVICE_PRODUCT</span> = <span class="variable">$arrayCleaned</span>[<span class="variable">$iterator</span>+<span class="number">1</span>][<span class="string">&#x27;value&#x27;</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;UDID&quot;</span>:</span><br><span class="line">            <span class="variable">$UDID</span> = <span class="variable">$arrayCleaned</span>[<span class="variable">$iterator</span>+<span class="number">1</span>][<span class="string">&#x27;value&#x27;</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&quot;VERSION&quot;</span>:</span><br><span class="line">            <span class="variable">$DEVICE_VERSION</span> = <span class="variable">$arrayCleaned</span>[<span class="variable">$iterator</span>+<span class="number">1</span>][<span class="string">&#x27;value&#x27;</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$iterator</span>++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$params</span> = <span class="string">&quot;UDID=&quot;</span>.<span class="variable">$UDID</span>.<span class="string">&quot;&amp;CHALLENGE=&quot;</span>.<span class="variable">$CHALLENGE</span>.<span class="string">&quot;&amp;DEVICE_NAME=&quot;</span>.<span class="variable">$DEVICE_NAME</span>.<span class="string">&quot;&amp;DEVICE_PR ODUCT=&quot;</span>.<span class="variable">$DEVICE_PRODUCT</span>.<span class="string">&quot;&amp;DEVICE_VERSION=&quot;</span>.<span class="variable">$DEVICE_VERSION</span>;</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&#x27;HTTP/1.1 301 Moved Permanently&#x27;</span>);</span><br><span class="line"><span class="title function_ invoke__">header</span>(<span class="string">&quot;Location: https://your.hostname/receive.php?&quot;</span>.<span class="variable">$params</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="前期工作准备好之后"><a href="#前期工作准备好之后" class="headerlink" title="前期工作准备好之后"></a>前期工作准备好之后</h3><p>如下是在手机端的截图，能看到 <code>mobileconfig</code> 是签名过的，并且还有回调地址。</p>
<ul>
<li>mobileconfig 文件下载显示已签名</li>
</ul>
<p><img src="/images/IMG_8860.PNG" alt="INSTALL_PROFILE.PNG"></p>
<ul>
<li>查看签名信息</li>
</ul>
<p><img src="/images/IMG_8858.PNG" alt="OBTAIN_UDID.PNG"></p>
<ul>
<li>安装成功后，系统会自动的访问 mobileconfig 中的地址，返回数据</li>
</ul>
<p><img src="/images/IMG_8862.PNG" alt="RESIGN.PNG"></p>
<h2 id="使用-fastlane-对-ipa-进行重签名"><a href="#使用-fastlane-对-ipa-进行重签名" class="headerlink" title="使用 fastlane 对 ipa 进行重签名"></a>使用 <code>fastlane</code> 对 <code>ipa</code> 进行重签名</h2><h3 id="安装-fastlane"><a href="#安装-fastlane" class="headerlink" title="安装 fastlane"></a>安装 <code>fastlane</code></h3><ul>
<li>安装 <code>ruby</code><br>由于系统自带 <code>ruby</code>，因此安装任何包需要 <code>root</code> 权限，为了防止更新系统导致兼容性等问题，故全新安装 <code>ruby</code>，将 <code>local</code> 和 <code>system</code> 的 <code>ruby</code> 隔离</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install ruby</span><br></pre></td></tr></table></figure>
<p>并且根据提示将 ruby 加入到 path 中<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;/usr/local/opt/ruby/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>安装 <code>fastlane</code> 以及依赖</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gem install pry</span><br><span class="line">gem install fastlane</span><br></pre></td></tr></table></figure>
<h4 id="测试安装是否正确"><a href="#测试安装是否正确" class="headerlink" title="测试安装是否正确"></a>测试安装是否正确</h4><p> 尝试拉取一下</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&quot;spaceship&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Spaceship</span>.login(<span class="string">&#x27;your_developerapple_id&#x27;</span>,<span class="string">&#x27;your_pass_word&#x27;</span>)</span><br><span class="line"><span class="title class_">Spaceship</span>.certificate.all.each <span class="keyword">do</span> |<span class="params">cert</span>|</span><br><span class="line">  cert_type = <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span><span class="symbol">:</span><span class="symbol">:Certificate</span><span class="symbol">:</span><span class="symbol">:CERTIFICATE_TYPE_IDS</span>[cert.type_display_id].to_s.split(<span class="string">&quot;::&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">  puts <span class="string">&quot;Cert id: <span class="subst">#&#123;cert.id&#125;</span>, name: <span class="subst">#&#123;cert.name&#125;</span>, expires: <span class="subst">#&#123;cert.expires.strftime(<span class="string">&quot;%Y-%m-%d&quot;</span>)&#125;</span>, type: <span class="subst">#&#123;cert_type&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">all_devices = <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.device.all.each <span class="keyword">do</span> |<span class="params">device</span>|</span><br><span class="line">	puts <span class="string">&quot;device id: <span class="subst">#&#123;device.id&#125;</span>, name: <span class="subst">#&#123;device.name&#125;</span>, udid: <span class="subst">#&#123;device.udid&#125;</span>&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>结果如下，只截取关键部分<br><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">Cert id: XXXXXX, name: Development, expires: 2021-01-15, type: AppleDevelopment</span><br><span class="line">.....</span><br><span class="line"></span><br><span class="line">// 另外还有 device 列表</span><br><span class="line">device id: XXXX, name: bbbb, udid: XXXXXXXX</span><br></pre></td></tr></table></figure></p>
<h4 id="将获取到的-UDID-加入到设备列表中"><a href="#将获取到的-UDID-加入到设备列表中" class="headerlink" title="将获取到的 UDID 加入到设备列表中"></a>将获取到的 UDID 加入到设备列表中</h4><p>需要将获取到的 <code>UDID</code> 加入到 <code>team</code> 的设备列表里面，才能够将重签名的 <code>ipa</code> 下发给需要的设备安装使用。</p>
<p>如下的代码从文件中读取上传来的 <code>UDID</code> 和设备名称，加入到所有的 <code>ad_hoc</code> 的描述文件中</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">file = <span class="title class_">File</span>.open(<span class="string">&quot;devices-udid-name-ios.txt&quot;</span>) <span class="comment">#文本文件里录入的udid和设备名用tab分隔</span></span><br><span class="line">    file.each <span class="keyword">do</span> |<span class="params">line</span>|</span><br><span class="line">        arr = line.strip.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        device = <span class="title class_">Spaceship</span>.device.create!(<span class="symbol">name:</span> arr[<span class="number">1</span>], <span class="symbol">udid:</span> arr[<span class="number">0</span>])</span><br><span class="line">        puts <span class="string">&quot;add device: <span class="subst">#&#123;device.name&#125;</span> <span class="subst">#&#123;device.udid&#125;</span> <span class="subst">#&#123;device.model&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    devices = <span class="title class_">Spaceship</span>.device.all</span><br><span class="line"></span><br><span class="line">    profiles = <span class="title class_">Array</span>.new</span><br><span class="line">    profiles += <span class="title class_">Spaceship</span>.provisioning_profile.development.all</span><br><span class="line">    profiles += <span class="title class_">Spaceship</span>.provisioning_profile.ad_hoc.all</span><br><span class="line"></span><br><span class="line">    profiles.each <span class="keyword">do</span> |<span class="params">p</span>|</span><br><span class="line">        puts <span class="string">&quot;Updating <span class="subst">#&#123;p.name&#125;</span>&quot;</span></span><br><span class="line">        p.devices = devices</span><br><span class="line">        p.update!</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>运行结果能看到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Updating Test01</span><br><span class="line">Updating adHocResign</span><br></pre></td></tr></table></figure>
<p>已经将获取到的 <code>UDID</code> 加到 <code>ad_hoc</code> 中</p>
<ul>
<li>provision 位置<br>如果需要查看系统中已经保存的描述文件：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">~/Library/MobileDevice/Provisioning\ Profiles/</span><br></pre></td></tr></table></figure>
<h4 id="签名"><a href="#签名" class="headerlink" title="签名"></a>签名</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fastlane sigh resign your.ipa --signing_identity <span class="string">&#x27;iPhone Distribution: XXXX&#x27;</span> -p your.mobileprovision</span><br></pre></td></tr></table></figure>
<h2 id="使用-Linux-对-ipa-进行签名"><a href="#使用-Linux-对-ipa-进行签名" class="headerlink" title="使用 Linux 对 ipa 进行签名"></a>使用 Linux 对 ipa 进行签名</h2><h3 id="zsign"><a href="#zsign" class="headerlink" title="zsign"></a>zsign</h3><p><a href="https://github.com/zhlynn/zsign">GitHub - zhlynn/zsign: Maybe is the most quickly codesign alternative for iOS12+ in the world, cross-platform ( Linux &amp; macOS ), more features. sign!</a></p>
<p><em>从介绍看只需要提供 p12 文件和 provisioning profile 即可完成签名</em></p>
<h4 id="生成-p12"><a href="#生成-p12" class="headerlink" title="生成 p12"></a>生成 p12</h4><ul>
<li>安装 openssl</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install openssl</span><br></pre></td></tr></table></figure>
<ul>
<li>生成 csr 文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl genrsa -out ios_distribution.key 2048</span><br><span class="line">openssl req -new -key ios_distribution.key -out ios_distribution.csr -subj <span class="string">&#x27;/emailAddress=me@example.com, CN=Example, C=US&#x27;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>将生成的文件上传到开发者网站创建 <code>Provisioning Profile</code></p>
</li>
<li><p>下载生成好的文件（证书）生成 <code>PEM</code> 文件</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -inform der -<span class="keyword">in</span> ios_distribution.cer -outform PEM -out ios_distribution.pem</span><br></pre></td></tr></table></figure>
<ul>
<li>下载根证书并且转为 PEM 文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://developer.apple.com/certificationauthority/AppleWWDRCA.cer</span><br><span class="line">openssl x509 -<span class="keyword">in</span> AppleWWDRCA.cer -inform DER -out AppleWWDRCA.pem -outform PEM</span><br></pre></td></tr></table></figure>
<ul>
<li>导出P12</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl pkcs12 -<span class="built_in">export</span> -out ios_distribution.p12 -inkey ios_distribution.key -<span class="keyword">in</span> ios_distribution.pem -certfile AppleWWDRCA.pem</span><br></pre></td></tr></table></figure>
<h4 id="安装-zsign"><a href="#安装-zsign" class="headerlink" title="安装 zsign"></a>安装 zsign</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ *.cpp common/*.cpp -lcrypto -I/usr/local/Cellar/openssl@1.1/1.1.1f/include -L/usr/local/Cellar/openssl@1.1/1.1.1f/lib -O3 -o zsign</span><br></pre></td></tr></table></figure>
<p><em>注意指定头文件和库文件</em></p>
<h4 id="使用-zsign-签名"><a href="#使用-zsign-签名" class="headerlink" title="使用 zsign 签名"></a>使用 zsign 签名</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: zsign [-options] [-k privkey.pem] [-m dev.prov] [-o output.ipa] file|folder</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">-k, --pkey          Path to private key or p12 file. (PEM or DER format)</span><br><span class="line">-m, --prov          Path to mobile provisioning profile.</span><br><span class="line">-c, --cert          Path to certificate file. (PEM or DER format)</span><br><span class="line">-d, --debug         Generate debug output files. (.zsign_debug folder)</span><br><span class="line">-f, --force         Force sign without cache when signing folder.</span><br><span class="line">-o, --output        Path to output ipa file.</span><br><span class="line">-p, --password      Password <span class="keyword">for</span> private key or p12 file.</span><br><span class="line">-b, --bundleid      New bundle <span class="built_in">id</span> to change.</span><br><span class="line">-n, --bundlename    New bundle name to change.</span><br><span class="line">-e, --entitlements  New entitlements to change.</span><br><span class="line">-z, --ziplevel      Compressed level when output the ipa file. (0-9)</span><br><span class="line">-l, --dylib         Path to inject dylib file.</span><br><span class="line">-w, --weak          Inject dylib as LC_LOAD_WEAK_DYLIB.</span><br><span class="line">-i, --install       Install ipa file using ideviceinstaller <span class="built_in">command</span> <span class="keyword">for</span> <span class="built_in">test</span>.</span><br><span class="line">-q, --quiet         Quiet operation.</span><br><span class="line">-v, --version       Show version.</span><br><span class="line">-h, --<span class="built_in">help</span>          Show <span class="built_in">help</span>.</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/local/bin/zsign -f -k ios_distribution.p12 -p 123456  -m adHocResign.mobileprovision -b <span class="string">&#x27;com.your.package.BundleId&#x27;</span> -n <span class="string">&#x27;your.app.name&#x27;</span> -o your.ipa -z 9 your.signed.ipa</span><br><span class="line">&gt;&gt;&gt; Unzip:	your..ipa (21.26 MB) -&gt; /tmp/zsign_folder_1586264064122616 ...</span><br><span class="line">&gt;&gt;&gt; Unzip OK! (0.318s, 317925us)</span><br><span class="line">&gt;&gt;&gt; BundleId: 	your.bundle.id -&gt; your.new.bundle.id</span><br><span class="line">&gt;&gt;&gt; BundleName:  -&gt; ToTok</span><br><span class="line">&gt;&gt;&gt; Signing: 	/tmp/zsign_folder_1586264064122616/Payload/your.app ...</span><br><span class="line">&gt;&gt;&gt; AppName: 	your.app.name</span><br><span class="line">&gt;&gt;&gt; BundleId: 	com.your.package.BundleId</span><br><span class="line">&gt;&gt;&gt; TeamId: 	XXXXXXX</span><br><span class="line">&gt;&gt;&gt; SubjectCN: 	Apple Distribution: XXXXXXX</span><br><span class="line">&gt;&gt;&gt; ReadCache: 	NO</span><br><span class="line">&gt;&gt;&gt; SignFile: 	libswiftRemoteMirror.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftCoreImage.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftObjectiveC.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftCore.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftCoreGraphics.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftUIKit.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftMetal.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftDispatch.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftos.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftCoreFoundation.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftDarwin.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftQuartzCore.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftFoundation.dylib</span><br><span class="line">&gt;&gt;&gt; SignFile: 	Frameworks/libswiftSwiftOnoneSupport.dylib</span><br><span class="line">&gt;&gt;&gt; SignFolder: your.singed.app, (your.app.name)</span><br><span class="line">&gt;&gt;&gt; Signed OK! (0.746s, 745663us)</span><br><span class="line">&gt;&gt;&gt; Archiving: 	your.singed.appipa ...</span><br><span class="line">&gt;&gt;&gt; Archive OK! (21.23 MB) (2.342s, 2341848us)</span><br><span class="line">&gt;&gt;&gt; Done. (3.422s, 3421883us)</span><br></pre></td></tr></table></figure>
<p>安装成功，并且可以正常打开</p>
<h2 id="超级签名脚本"><a href="#超级签名脚本" class="headerlink" title="超级签名脚本"></a>超级签名脚本</h2><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">&#x27;docopt&#x27;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;spaceship&#x27;</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;pathname&#x27;</span></span><br><span class="line"></span><br><span class="line">doc = <span class="string">&lt;&lt;DOCOPT</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Usage:</span></span><br><span class="line"><span class="string">  <span class="subst">#&#123;<span class="variable constant_">__FILE__</span>&#125;</span> --apple_id=&lt;apple_id&gt; --password=&lt;password&gt; --bundle_id=&lt;bundle_id&gt; --input_ipa=&lt;input_ipa&gt;</span></span><br><span class="line"><span class="string">  <span class="subst">#&#123;<span class="variable constant_">__FILE__</span>&#125;</span> --help | -h</span></span><br><span class="line"><span class="string">  <span class="subst">#&#123;<span class="variable constant_">__FILE__</span>&#125;</span> --input_file=&lt;file_name&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">DOCOPT</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  args = <span class="title class_">Docopt</span><span class="symbol">:</span><span class="symbol">:docopt</span>(doc)</span><br><span class="line"><span class="keyword">rescue</span> <span class="title class_">Docopt</span><span class="symbol">:</span><span class="symbol">:Exit</span> =&gt; e</span><br><span class="line">  puts e.message</span><br><span class="line">  exit</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># args.each do |key, value|</span></span><br><span class="line"><span class="comment">#   case key</span></span><br><span class="line"><span class="comment">#   when &quot;--apple_id&quot; then</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   end</span></span><br><span class="line"><span class="comment">#   # puts key</span></span><br><span class="line"><span class="comment">#   # puts value</span></span><br><span class="line"><span class="comment"># end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DevelopPortalHandle</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">initialize</span>(<span class="params">userName, passwd, bundleID</span>)</span><br><span class="line">    puts(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    puts (<span class="string">&quot;====== initialize ======&quot;</span>)</span><br><span class="line">    <span class="variable">@userName</span> = userName</span><br><span class="line">    <span class="variable">@bundleID</span> = bundleID</span><br><span class="line">    <span class="variable">@passwd</span> = passwd</span><br><span class="line">    list = bundleID.split(<span class="string">&quot;.&quot;</span>)</span><br><span class="line">    appidLastName = list.last</span><br><span class="line"></span><br><span class="line">    <span class="variable">@appName</span> = appidLastName</span><br><span class="line">    <span class="variable">@provisionName</span> = appidLastName</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">login</span>()</span><br><span class="line">    puts(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    puts (<span class="string">&quot;====== login ======&quot;</span>)</span><br><span class="line">    <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.login(<span class="variable">@userName</span>,<span class="variable">@passwd</span>)</span><br><span class="line">    <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.select_team <span class="comment"># 让用户可以选择 team</span></span><br><span class="line">    <span class="comment"># Spaceship.client.team_id = &quot;这里输入TeamId&quot;</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">allApp</span>()</span><br><span class="line">    puts(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    puts (<span class="string">&quot;====== allApp ======&quot;</span>)</span><br><span class="line">    <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.app.all.collect <span class="keyword">do</span> |<span class="params">app</span>|</span><br><span class="line">      puts <span class="string">&quot;app.name: <span class="subst">#&#123;app.name&#125;</span>, app id <span class="subst">#&#123;app.app_id&#125;</span>, bundle id :<span class="subst">#&#123;app.bundle_id&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">createApp</span>()</span><br><span class="line">    puts(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    puts (<span class="string">&quot;====== createApp ======&quot;</span>)</span><br><span class="line">    puts <span class="string">&quot;createApp find: bundle id = <span class="subst">#&#123;<span class="variable">@bundleID</span>&#125;</span> appName = <span class="subst">#&#123;<span class="variable">@appName</span>&#125;</span>&quot;</span></span><br><span class="line">    app = <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.app.find(<span class="variable">@bundleID</span>)</span><br><span class="line">    <span class="keyword">if</span> !app <span class="keyword">then</span></span><br><span class="line">      puts(<span class="string">&quot;can&#x27;t find <span class="subst">#&#123;<span class="variable">@bundleID</span>&#125;</span> create a new one&quot;</span>)</span><br><span class="line">      app = <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.app.create!(<span class="symbol">bundle_id:</span> <span class="variable">@bundleID</span>, <span class="symbol">name:</span> <span class="variable">@appName</span>)</span><br><span class="line">      puts <span class="string">&quot;createApp <span class="subst">#&#123;app&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">createDistributionProvision</span>(<span class="params">provisioningClass</span>)</span><br><span class="line">    puts(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    puts (<span class="string">&quot;====== createDistributionProvision ======&quot;</span>)</span><br><span class="line">    cert = <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.certificate.production.all.last</span><br><span class="line">    provisionNameDis = <span class="variable">@provisionName</span> + <span class="string">&#x27;_dis&#x27;</span></span><br><span class="line">    profile = provisioningClass.create!(<span class="symbol">bundle_id:</span> <span class="variable">@bundleID</span>,<span class="symbol">certificate:</span>cert,<span class="symbol">name:</span><span class="variable">@provisionName</span>)</span><br><span class="line">    <span class="keyword">return</span> profile</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">downloadDistributionProvision</span>(<span class="params">provisioningClass</span>)</span><br><span class="line">    puts(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    puts (<span class="string">&quot;====== downloadDistributionProvision ======&quot;</span>)</span><br><span class="line">    filtered_profiles = provisioningClass.find_by_bundle_id(<span class="symbol">bundle_id:</span> <span class="variable">@bundleID</span>)</span><br><span class="line">    profile = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span>  <span class="number">0</span> &lt; filtered_profiles.length <span class="keyword">then</span></span><br><span class="line">      profile = filtered_profiles[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elsif</span> <span class="number">0</span> == filtered_profiles.length <span class="keyword">then</span></span><br><span class="line">      profile = createProvision(provisioningClass)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    provisionNameDis = <span class="variable">@provisionName</span> + <span class="string">&#x27;_dis&#x27;</span></span><br><span class="line">    provisionFileName = provisionNameDis + <span class="string">&#x27;.mobileprovision&#x27;</span></span><br><span class="line">    <span class="title class_">File</span>.write(provisionFileName, profile.download)</span><br><span class="line">    <span class="keyword">return</span> provisionFileName</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">downloadAdHocProvision</span>()</span><br><span class="line">    puts(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    puts (<span class="string">&quot;====== downloadAdHocProvision ======&quot;</span>)</span><br><span class="line">    filtered_profiles = <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.provisioning_profile.ad_hoc.find_by_bundle_id(<span class="symbol">bundle_id:</span> <span class="variable">@bundleID</span>)</span><br><span class="line">    profile = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span>  <span class="number">0</span> &lt; filtered_profiles.length <span class="keyword">then</span></span><br><span class="line">        puts (<span class="string">&quot;<span class="subst">#&#123;<span class="variable">@bundleID</span>&#125;</span>&#x27;s provisioning profile exist&quot;</span>)</span><br><span class="line">        profile = filtered_profiles[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elsif</span> <span class="number">0</span> == filtered_profiles.length <span class="keyword">then</span></span><br><span class="line">      puts (<span class="string">&quot;createProvision&quot;</span>)</span><br><span class="line">      profile = createProvision(provisioningClass)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    provisionNameAdHoc = <span class="variable">@provisionName</span> + <span class="string">&#x27;_adhoc&#x27;</span></span><br><span class="line">    provisionFileName = provisionNameAdHoc + <span class="string">&#x27;.mobileprovision&#x27;</span></span><br><span class="line">    absolutePath = <span class="title class_">Pathname</span>.new(<span class="title class_">File</span>.dirname(<span class="variable constant_">__FILE__</span>)).realpath.to_s &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; provisionFileName</span><br><span class="line">    puts(<span class="string">&quot;absolutePath = <span class="subst">#&#123;absolutePath&#125;</span>;&quot;</span>)</span><br><span class="line">    <span class="title class_">File</span>.write(absolutePath, profile.download)</span><br><span class="line">    <span class="keyword">return</span> absolutePath</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">createDevelopProvision</span>()</span><br><span class="line">    puts(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    puts (<span class="string">&quot;====== createDevelopProvision ======&quot;</span>)</span><br><span class="line">    dev_certs = <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.certificate.development.all</span><br><span class="line">    all_devices = <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.device.all</span><br><span class="line">    provisionNameDev = <span class="variable">@provisionName</span> + <span class="string">&#x27;_dev&#x27;</span></span><br><span class="line">    profile = <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.provisioning_profile.development.create!(<span class="symbol">bundle_id:</span> <span class="variable">@bundleID</span>,<span class="symbol">certificate:</span> dev_certs,<span class="symbol">name:</span> provisionNameDev,<span class="symbol">devices:</span>all_devices)</span><br><span class="line">    <span class="keyword">return</span> profile</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">downloadDevelopProvision</span>()</span><br><span class="line">    puts(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    puts (<span class="string">&quot;====== downloadDevelopProvision ======&quot;</span>)</span><br><span class="line">    filtered_profiles = <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.provisioning_profile.development.find_by_bundle_id(<span class="symbol">bundle_id:</span> <span class="variable">@bundleID</span>)</span><br><span class="line">    profile = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">if</span>  <span class="number">0</span> &lt; filtered_profiles.length <span class="keyword">then</span></span><br><span class="line">      profile = filtered_profiles[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">elsif</span> <span class="number">0</span> == filtered_profiles.length <span class="keyword">then</span></span><br><span class="line">      profile = createDevelopProvision()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    provisionNameDev = <span class="variable">@provisionName</span> + <span class="string">&#x27;_dev&#x27;</span></span><br><span class="line">    provisionFileName = provisionNameDev + <span class="string">&#x27;.mobileprovision&#x27;</span></span><br><span class="line">    <span class="title class_">File</span>.write(provisionFileName, profile.download)</span><br><span class="line">    <span class="keyword">return</span> provisionFileName</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">addServices</span>(<span class="params">appServiceObj</span>)</span><br><span class="line">    puts(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    puts (<span class="string">&quot;====== addServices ======&quot;</span>)</span><br><span class="line">    puts(<span class="string">&quot; add <span class="subst">#&#123;appServiceObj&#125;</span>&quot;</span>)</span><br><span class="line">    app = <span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.app.find(<span class="variable">@bundleID</span>)</span><br><span class="line">    app.update_service(appServiceObj)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">addDevices</span>(<span class="params">fileName</span>)</span><br><span class="line">    puts(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    puts (<span class="string">&quot;====== addDevices ======&quot;</span>)</span><br><span class="line">    file = <span class="title class_">File</span>.open(fileName)</span><br><span class="line">    file.each <span class="keyword">do</span> |<span class="params">line</span>|</span><br><span class="line">        arr = line.strip.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">        device = <span class="title class_">Spaceship</span>.device.create!(<span class="symbol">name:</span> arr[<span class="number">1</span>], <span class="symbol">udid:</span> arr[<span class="number">0</span>])</span><br><span class="line">        puts <span class="string">&quot;add device: name = <span class="subst">#&#123;device.name&#125;</span>; udid = <span class="subst">#&#123;device.udid&#125;</span>; model = <span class="subst">#&#123;device.model&#125;</span>&quot;</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    puts (<span class="string">&quot;====== addDevices-updateAdHoc ======&quot;</span>)</span><br><span class="line"></span><br><span class="line">    profiles = <span class="title class_">Array</span>.new</span><br><span class="line">    profiles += <span class="title class_">Spaceship</span>.provisioning_profile.ad_hoc.all</span><br><span class="line">    devices = <span class="title class_">Spaceship</span>.device.all</span><br><span class="line"></span><br><span class="line">    profiles.each <span class="keyword">do</span> |<span class="params">p</span>|</span><br><span class="line">        puts <span class="string">&quot;Updating <span class="subst">#&#123;p.name&#125;</span>&quot;</span></span><br><span class="line">        p.devices = devices</span><br><span class="line">        p.update!</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">resign</span>(<span class="params">provisionFile,inputIpa</span>)</span><br><span class="line">    puts(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    puts (<span class="string">&quot;====== resign ======&quot;</span>)</span><br><span class="line">    resignCmd = <span class="string">&quot;/usr/local/bin/zsign -f -k adHoc_resign.p12 -p 123456&quot;</span></span><br><span class="line">    resignCmd &lt;&lt; <span class="string">&quot; -m &quot;</span> &lt;&lt; provisionFile</span><br><span class="line">    resignCmd &lt;&lt; <span class="string">&quot; -b &quot;</span> &lt;&lt; <span class="string">&quot;&#x27;<span class="subst">#&#123;<span class="variable">@bundleID</span>&#125;</span>&#x27;&quot;</span></span><br><span class="line">    resignCmd &lt;&lt; <span class="string">&quot; -n &#x27;ToTok&#x27;&quot;</span></span><br><span class="line">    resignCmd &lt;&lt; <span class="string">&quot; -o ToTok_AD_HOC_signed.ipa&quot;</span></span><br><span class="line">    resignCmd &lt;&lt; <span class="string">&quot; -z 9&quot;</span></span><br><span class="line">    resignCmd &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; inputIpa</span><br><span class="line">    puts (<span class="string">&quot;resign cmd = <span class="subst">#&#123;resignCmd&#125;</span>;&quot;</span>)</span><br><span class="line">    exec(resignCmd)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">handle = <span class="title class_">DevelopPortalHandle</span>.new(args[<span class="string">&#x27;--apple_id&#x27;</span>], args[<span class="string">&#x27;--password&#x27;</span>], args[<span class="string">&#x27;--bundle_id&#x27;</span>])</span><br><span class="line">handle.login()</span><br><span class="line">handle.createApp()</span><br><span class="line">handle.addDevices(<span class="string">&quot;udid.txt&quot;</span>)</span><br><span class="line">handle.addServices(<span class="title class_">Spaceship</span><span class="symbol">:</span><span class="symbol">:Portal</span>.app_service.push_notification.on)</span><br><span class="line">provisionPath = handle.downloadAdHocProvision()</span><br><span class="line">handle.resign(provisionPath, args[<span class="string">&#x27;--input_ipa&#x27;</span>])</span><br></pre></td></tr></table></figure>
<h2 id="脚本运行"><a href="#脚本运行" class="headerlink" title="脚本运行"></a>脚本运行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ruby resignIPAWithUDID.rb --apple_id=your.apple.id --password=your.password --bundle_id=your.bundle.id --input_ipa=your.signed.ipa</span><br></pre></td></tr></table></figure>
<h2 id="Trouble-shooting"><a href="#Trouble-shooting" class="headerlink" title="Trouble shooting"></a>Trouble shooting</h2><h3 id="ruby-脚本不能执行"><a href="#ruby-脚本不能执行" class="headerlink" title="ruby 脚本不能执行"></a>ruby 脚本不能执行</h3><p>因为在服务器端执行的 <code>ruby</code> 脚本的用户和我测试用的用户不是同一个用户，因此 <code>ruby</code> 的环境不一样，尤其是 <code>gem</code></p>
<p>解决办法：<br>将 <code>ruby</code> 脚本封装成 <code>shell</code> 脚本，并且在执行 <code>shell</code> 脚本的时候重新制定 <code>ruby</code> 环境<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> GEM_HOME=<span class="string">&#x27;/home/www/.rvm/gems/ruby-2.3.0&#x27;</span>;</span><br><span class="line"><span class="built_in">export</span> GEM_PATH=<span class="string">&#x27;/home/www/.rvm/gems/ruby-2.3.0:/home/www/.rvm/gems/ruby-2.3.0@global&#x27;</span>;</span><br><span class="line"><span class="built_in">export</span> MY_RUBY_HOME=<span class="string">&#x27;/home/www/.rvm/rubies/ruby-2.3.0&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="换了用户会弹出两步验证"><a href="#换了用户会弹出两步验证" class="headerlink" title="换了用户会弹出两步验证"></a>换了用户会弹出两步验证</h3><p>参考文档：</p>
<p><a href="https://docs.fastlane.tools/best-practices/continuous-integration/#application-specific-passwords">Continuous Integration - fastlane docs</a></p>
<ul>
<li><p>生成 fastlane session</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fastlane spaceauth -u user@email.com</span><br></pre></td></tr></table></figure>
</li>
<li><p>将生成的内容放到脚本里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> FASTLANE_SESSION=<span class="string">&#x27;XXXXXX\n&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>访问重签名页面调用脚本即可</p>
]]></content>
      <categories>
        <category>Super Sign</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>SuperSign</tag>
        <tag>超级签名</tag>
      </tags>
  </entry>
  <entry>
    <title>Range Sum Query</title>
    <url>/2020/07/11/RangeSumQuery/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Range-Sum-Query-Immutable"><a href="#Range-Sum-Query-Immutable" class="headerlink" title="Range Sum Query Immutable"></a>Range Sum Query Immutable</h2><p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p>Example:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Given nums = [-2, 0, 3, -5, 2, -1]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br><span class="line">Note:</span><br><span class="line">You may assume that the array does not change.</span><br><span class="line">There are many calls to sumRange <span class="keyword">function</span>.</span><br></pre></td></tr></table></figure><br><span id="more"></span></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>比较简单的 Range Sum Query，只要知道前缀和就可以计算出不变数组的任意区间的和。</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        v_.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums) &#123;</span><br><span class="line">            v_.<span class="built_in">push_back</span>(v_.<span class="built_in">back</span>() + num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v_[j<span class="number">+1</span>] - v_[i]; <span class="comment">// O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Range-Sum-Query-2D-Immutable"><a href="#Range-Sum-Query-2D-Immutable" class="headerlink" title="Range Sum Query 2D - Immutable"></a>Range Sum Query 2D - Immutable</h2><p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p>
<p>Range Sum Query 2D<br>The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Given matrix = [</span><br><span class="line">  [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">sumRegion</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>) -&gt; <span class="number">8</span></span><br><span class="line"><span class="built_in">sumRegion</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>) -&gt; <span class="number">11</span></span><br><span class="line"><span class="built_in">sumRegion</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>) -&gt; <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>Note:<br>You may assume that the matrix does not change.<br>There are many calls to sumRegion function.<br>You may assume that row1 ≤ row2 and col1 ≤ col2.</p>
<h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul>
<li>参考之前Range Sum Query 的思想，肯定是要提前计算出需要的数据，最后计算和相当于查表。</li>
<li>那么 2D 数组如何计算使用类似的思想呢</li>
<li>矩形区域的和相当于多个矩形区域进行叠加后减去重复计算的区域，如下图所示，小矩形区域可以看做三个以左上角（0，0）为顶点的矩形区域与大的矩形区域的操作后的结果<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a <span class="number">2</span>D array sum[row<span class="number">+1</span>][col<span class="number">+1</span>]</span><br><span class="line">sums[i<span class="number">+1</span>][j<span class="number">+1</span>] represents the sum of area from matrix[<span class="number">0</span>][<span class="number">0</span>] to matrix[i][j]</span><br><span class="line">(notice: we add additional blank row sums[<span class="number">0</span>][col<span class="number">+1</span>]=&#123;<span class="number">0</span>&#125; <span class="keyword">and</span> blank column sums[row<span class="number">+1</span>][<span class="number">0</span>]=&#123;<span class="number">0</span>&#125; to remove the edge <span class="keyword">case</span> checking), so, we can have the following definition</span><br><span class="line">+-----+-+-------+     +--------+-----+     +-----+---------+     +-----+--------+</span><br><span class="line">|     | |       |     |        |     |     |     |         |     |     |        |</span><br><span class="line">|     | |       |     |        |     |     |     |         |     |     |        |</span><br><span class="line">+-----+-+       |     +--------+     |     |     |         |     +-----+        |</span><br><span class="line">|     | |       |  =  |              |  +  |     |         |  -  |              |</span><br><span class="line">+-----+-+       |     |              |     +-----+         |     |              |</span><br><span class="line">|               |     |              |     |               |     |              |</span><br><span class="line">|               |     |              |     |               |     |              |</span><br><span class="line">+---------------+     +--------------+     +---------------+     +--------------+</span><br><span class="line"></span><br><span class="line">   sums[i][j]      =    sums[i<span class="number">-1</span>][j]    +     sums[i][j<span class="number">-1</span>]    -   sums[i<span class="number">-1</span>][j<span class="number">-1</span>]   +</span><br><span class="line"></span><br><span class="line">                        matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li>
<li>因此使用同样的思路计算区域如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br><span class="line">|               |   |         |    |   |   |           |   |         |    |   |   |          |</span><br><span class="line">|   (r1,c1)     |   |         |    |   |   |           |   |         |    |   |   |          |</span><br><span class="line">|   +------+    |   |         |    |   |   |           |   +---------+    |   +---+          |</span><br><span class="line">|   |      |    | = |         |    | - |   |           | - |      (r1,c2) | + |   (r1,c1)    |</span><br><span class="line">|   |      |    |   |         |    |   |   |           |   |              |   |              |</span><br><span class="line">|   +------+    |   +---------+    |   +---+           |   |              |   |              |</span><br><span class="line">|        (r2,c2)|   |       (r2,c2)|   |   (r2,c1)     |   |              |   |              |</span><br><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br></pre></td></tr></table></figure>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = m &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].<span class="built_in">size</span>() : <span class="number">0</span>;</span><br><span class="line">        sum = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                sum[i][j] = sum[i<span class="number">-1</span>][j<span class="number">-1</span>] + sum[i][j<span class="number">-1</span>] - sum[i<span class="number">-1</span>][j<span class="number">-1</span>] + matrix[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[row2<span class="number">+1</span>][col2<span class="number">+1</span>] - sums[row2<span class="number">+1</span>][col1] - sums[row1][col2<span class="number">+1</span>] + sums[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="Range-Sum-Query-Mutable"><a href="#Range-Sum-Query-Mutable" class="headerlink" title="Range Sum Query Mutable"></a>Range Sum Query Mutable</h2><p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p>The update(i, val) function modifies nums by updating the element at index i to val.</p>
<p>Example:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Given nums = [1, 3, 5]</span><br><span class="line">-</span><br><span class="line">sumRange(0, 2) -&gt; 9</span><br><span class="line">update(1, 2)</span><br><span class="line">sumRange(0, 2) -&gt; 8</span><br></pre></td></tr></table></figure><br>Note:</p>
<p>The array is only modifiable by the update function.<br>You may assume the number of calls to update and sumRange function is distributed evenly.</p>
<h3 id="Fenwick-Tree-Binary-Index-Tree"><a href="#Fenwick-Tree-Binary-Index-Tree" class="headerlink" title="Fenwick Tree (Binary Index Tree)"></a>Fenwick Tree (Binary Index Tree)</h3><p>树状数组，我们需要两个数组来存储，原始数组和 bit 数组</p>
<ul>
<li>假定 i 为左子节点，那么其父节点的坐标为 (i + lowbit(i))</li>
<li>假定 i 为右子节点，那么其父节点的坐标为 (i - lowbit(i))</li>
<li>update(int i, int delta) —&gt; 更新前缀和数组中每一个受影响前缀和，从 i 到 最后一个位置 O (n)</li>
<li>query(int) —&gt; 直接返回 idx + 1 的前缀和 O(1)</li>
<li>求 i 到 j 的前缀和 就可用 query(j+1) - query(i) 来计算</li>
<li>求和的基本思想，给定要求和的位置 i，可以用二级制表示法来分段求和，以 13 为例  13 = 2^3 + 2 ^2 + 2 ^ 0;</li>
<li>因此 prefixSum(13) = Range(1, 8) + Range(9, 12) + Range(13) // Range(i, j) 表示 i 到 j 的数字求和</li>
<li>arr = [1, 7, 3, 0, 5, 8, 3, 2, 6, 2, 1, 1, 4, 5]<br>prefixSum(13) = RANGE(1, 8) + RANGE(9, 12) + RANGE(13, 13)<br>= 29 + 10 + 4 = 43</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FenwickTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sum_;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FenwickTree</span>(<span class="type">int</span> n) : <span class="built_in">sum</span>(n<span class="number">+1</span>, <span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// 更新一个值，坐标 为 i，需要修改 bit 数组中涵盖了 原始数组 arr[i] 的值 --&gt;  下标 i 以及所有的父节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; sum.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sum_[i] += delta;</span><br><span class="line">            i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间求和，假定求 i --&gt; j 的数值之和，可以求 0 --&gt; i-1 , 0 --&gt; j，再相减</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += sum_[i];</span><br><span class="line">            i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间求和 和 更新数组 都是 O(logn)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums_;</span><br><span class="line">    FenwickTree tree_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt; nums): <span class="built_in">nums_</span>(<span class="built_in">move</span>(nums)), <span class="built_in">tree_</span>(nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            tree_.<span class="built_in">update</span>(i<span class="number">+1</span>, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        tree_.<span class="built_in">update</span>(i, val - nums[i]);</span><br><span class="line">        nums_[i] -= val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumQuery</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree_.<span class="built_in">query</span>(j<span class="number">+1</span>) - tree_.<span class="built_in">query</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Segment-Tree"><a href="#Segment-Tree" class="headerlink" title="Segment Tree"></a>Segment Tree</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentNode</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    SegmentNode *left;</span><br><span class="line">    SegmentNode *right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SegmentNode</span>(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> sum, SegmentNode *left = <span class="literal">nullptr</span>, SegmentNode *right = <span class="literal">nullptr</span>):</span><br><span class="line">     <span class="built_in">start</span>(start), <span class="built_in">end</span>(end), <span class="built_in">sum</span>(sum), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right);</span><br><span class="line">    <span class="built_in">SegmentNode</span>(<span class="type">const</span> SegmentNode&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SegmentNode&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SegmentNode&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SegmentNode</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> left;</span><br><span class="line">        <span class="keyword">delete</span> right;</span><br><span class="line">        left = right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>TwoSum</title>
    <url>/2019/11/22/TwoSum/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/two-sum/">TwoSum</a><br>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</p>
<p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p>
<p>Example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Given nums = [2, 7, 11, 15], target = 9,</span><br><span class="line"></span><br><span class="line">Because nums[0] + nums[1] = 2 + 7 = 9,</span><br><span class="line"><span class="built_in">return</span> [0, 1].</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li><code>整形</code>数组 <code>nums</code></li>
<li>是否有序未知</li>
<li>\(\mathcal{target}=\mathcal{num[idx1]}-\mathcal{num[idx2]} | idx1 \ne idx2\)</li>
<li>一定有解</li>
<li>同样元素不能用两次</li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><ul>
<li><code>nums = [2, 7, 11, 15]</code></li>
<li><code>target = 9</code></li>
<li>对于 <code>idx = 0</code>. <code>nums[idx] = 2</code></li>
<li>需要找到 <code>nums[idx2] = target - nums[idx]</code> —&gt; <code>7</code></li>
<li><code>nums[idx2] = 7</code> <code>idx2 = 1</code></li>
<li><code>[0, 1]</code></li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>例子中，找到 <code>target-nums[idx]</code> 并不够，还要找到 <code>target-nums[idx]</code> 对应的<code>index</code></li>
<li>因此需要建立 <code>index</code> 和 <code>value</code> 的关系</li>
<li>关系建立好之后</li>
<li>对于每一个元素 <code>idx</code> ，查找 <code>target-nums[idx]</code> 以及对应的<code>index</code></li>
<li>找到就返回结果，未找到返回空</li>
<li>出入参合法性判断</li>
<li>需要的数据结构：</li>
<li><code>unordered_map&lt;int,int&gt;</code> 哈希表，分别存放 <code>value,index</code></li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map_;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map_.<span class="built_in">count</span>(nums[i])) &#123;</span><br><span class="line">                map_[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> num_to_find = target-nums[i];</span><br><span class="line">            <span class="keyword">if</span> (map_.<span class="built_in">count</span>(num_to_find) &amp;&amp; map_[num_to_find] != i) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i, map_[num_to_find]&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">twoSum</span>(<span class="keyword">_</span> <span class="params">nums</span>: [<span class="type">Int</span>], <span class="keyword">_</span> <span class="params">target</span>: <span class="type">Int</span>) -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> dict <span class="operator">=</span> [<span class="type">Int</span>:<span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">for</span> (i, num) <span class="keyword">in</span> nums.enumerated() &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> lastIdx <span class="operator">=</span> dict[target <span class="operator">-</span> num] &#123;</span><br><span class="line">                <span class="keyword">return</span> [lastIdx, i]</span><br><span class="line">            &#125;</span><br><span class="line">            dict[num] <span class="operator">=</span> i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>每个元素只遍历一次，因此是线性时间 \(\mathcal{O(n)}\)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>额外申请了和数组长度一样的哈希表，因此空间复杂度也为 \(\mathcal{O(n)}\)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Easy</tag>
      </tags>
  </entry>
  <entry>
    <title>UpperBound</title>
    <url>/2020/04/25/UpperBound/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="UpperBound"><a href="#UpperBound" class="headerlink" title="UpperBound"></a>UpperBound</h2><p>Upper Bound 是使用二分查找的办法求 大于 i 的第一个位置<br><span id="more"></span></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">upperBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; i) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O (logn)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(1)</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>VIPER架构落地IM</title>
    <url>/2025/01/15/VIPER%E6%9E%B6%E6%9E%84%E8%90%BD%E5%9C%B0%E5%88%B0IM/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>来新公司也大半年了，发现之前的工程实现的非常不合理，维护成本极高，内部吐槽严重，<code>BUG</code> 叠 <code>BUG</code>，修老 <code>BUG</code> 引入的新 <code>BUG</code> 层出不穷，质量堪忧。</p>
<h2 id="Pros-amp-Cons"><a href="#Pros-amp-Cons" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h2><p>拿到代码后简单的看了一下:</p>
<ul>
<li>使用 <code>MVC</code> 模式，并且由于<code>各种原因</code>，说白了就是写的挫。将 <code>MCV(Model-View-Controller)</code> 写成了 <code>MVC(Massive View Controller)</code></li>
<li><code>View Controller</code> 写的极为笨重，几乎流程都写在几个比较大的 <code>View Controller</code> 中。牵一发而动全身，能不出错么。</li>
<li>目前的时机比较不错，新项目要开始了，及得想办法复用之前的逻辑，又得写的没什么问题。</li>
<li>很久不写这种流程了，还是需要仔细的回归练习一下，而且还能练练 swift，何乐而不为呢</li>
</ul>
<h2 id="VIPER-结构简介"><a href="#VIPER-结构简介" class="headerlink" title="VIPER 结构简介"></a>VIPER 结构简介</h2><p><code>VIPER</code> 是视图 (<code>View</code>)，交互器 (<code>Interactor</code>)，展示器 (<code>Presenter</code>)，实体 (<code>Entity</code>) 以及路由 (<code>Routing</code>) 的首字母缩写。这样根据逻辑结构的不同可以划分为不同的责任层。使得依赖更容易隔离，比如说数据库，也更容易单独测试，边界清晰。<br>他们的关系大概是这样的 如下图所示：</p>
<p><img src="/images/viper_arch.png" alt="VIPER"></p>
<h2 id="为什么要用-VIPER"><a href="#为什么要用-VIPER" class="headerlink" title="为什么要用 VIPER"></a>为什么要用 VIPER</h2><p>互联网企业都要求快速迭代，要求周期短，质量高。如何快速的在满足需求的前提下下交付质量好的产品，是大家都想解决的问题。对于一个处于一线的程序员来讲，从根上推动整个流程的变化是不切实际的。比较稳妥且的办法是采用技术手段来提高自己的效率，降低出错的概率。<br>对于源源不断的需求，以及不断的需求变化。除了默默的问候这些 PM，不还是得一个字一个字的敲出来。做的不好，大家会怀疑你的能力。面子上挂不住。活那么多，身体抗不住，身为一个快乐的程序员，在减少秃头的情况下得想办法让自己轻松点嘛。</p>
<h3 id="步入正题"><a href="#步入正题" class="headerlink" title="步入正题"></a>步入正题</h3><ul>
<li>VIPER 的好处就是模块之前关系比较松散，模块划分清晰，几乎做到了彻底解耦。每个（VIPER）子模块都可以单独的测试，</li>
<li>避免掉了 MVC -&gt; M(assive)VC 的情况，VC 里面几乎就是个接口调用，几乎就是完成业务流程的胶水代码，而且都是 Protocol 的接口，业务比较清晰。</li>
<li>数据模型的处理，单独的放到了 Interactor 内部，这一块对于其他模块几乎是透明。</li>
<li>VC 彻底细化为View 和 Presenter，三者的交互可以参考 MVP 模式，不多说。</li>
<li>Router 作为业务的入口和跳转的枢纽，将跳转逻辑也吃掉了。</li>
<li>最终 VIPER 化之后，代码量会变多、文件会变多，逻辑变得清晰可维护。</li>
<li>不同的 VIPER 模块 通信只有两个途径，一个是通过 ROUTER，另一个是通过 INTERACTOR</li>
</ul>
<h3 id="开始落地"><a href="#开始落地" class="headerlink" title="开始落地"></a>开始落地</h3><h4 id="设计图"><a href="#设计图" class="headerlink" title="设计图"></a>设计图</h4><ul>
<li><p><a href="https://github.com/bapuqln/XCode-Template-Viper-Mac">VIPER 模板</a><br>每次手工新建五个文件着实比较蛋疼，那么使用 XCode 模板每次自动新建不是很爽。链接就是新建好的模板。方便省事，目前只有 Mac 版本，改吧改吧 iOS 版本也不是啥难事</p>
</li>
<li><p>以聊天页为例 VIPER 落地<br><img src="/images/chat-view.svg" alt="设计图"></p>
</li>
</ul>
<ol>
<li>从图中可以看到该页面比较简单，聊天页面大概分两个部分，左边应该是 thread 列表，右边是 消息流。</li>
<li>窗体的样式几乎都是自定义的。</li>
<li>顶部存在多 TAB，方便切换不同的显示内容。</li>
<li>由于是 IM，那就存在登陆和非登陆，因此需要目前两个 VIPER 模块。</li>
<li>从设计来看，各种 UI 组件都需要自定义，因此需要提供一个 UI 基础组件库，给工程提供子弹。吃掉 UI 的内部细节。只要对外提供行为即可。</li>
</ol>
<h4 id="登陆-VIPER-结构"><a href="#登陆-VIPER-结构" class="headerlink" title="登陆 VIPER 结构"></a>登陆 VIPER 结构</h4><ul>
<li><p>登陆需要简单的输入用户名和密码，然后呢对于登陆成功的状况，会有账户维护和消息同步。</p>
</li>
<li><p>设计有要求在登录页内部玩各种花活。因此目前沟通后，登录页划分为登陆输入页，和登陆行为页，两个页面的逻辑和流程不大一样。</p>
</li>
<li><p>登陆输入页的协议定义如下</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: Wireframe - 这块 Wireframe 就是 ROUTER</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginMainWireframeProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MARK: Presenter -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginMainViewPresenterProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">// 目前只有注册的行为，因此定义好接口供 VC 使用</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">startRegistration</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: Interactor -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginMainInteractorProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">AZLoginMainViewPresenterProtocol</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">//给 PRESENTER 提供的接口，真正的注册行为是在 INTERACTOR 中发生的</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">startRegistration</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: View -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginMainViewProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> presenter: <span class="type">AZLoginMainViewPresenterProtocol</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/login-viper.png" alt="登陆页"></p>
<ul>
<li>登陆行为页</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: Wireframe -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginActionWireframeProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">//根据业务需要，这块有可能需要直接的显示到主界面</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">showMainWindow</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MARK: Presenter -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginActionPresenterProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">// 给 VC 提供的接口可以注册和忘记密码，并且在登陆成功后可以有接口给 INTERACTOR 调用(finish)</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">login</span>(<span class="params">email</span>: <span class="type">String</span>?, <span class="params">password</span>: <span class="type">String</span>?)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">finished</span>(<span class="params">login</span> <span class="params">error</span>: <span class="type">AZError</span>?)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">forgetPassword</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: Interactor -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginActionInteractorProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">AZLoginActionPresenterProtocol</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">// 真正的接口，具体的行为是在 INTERACTOR 中发生的，</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">login</span>(<span class="params">email</span>: <span class="type">String</span>?, <span class="params">password</span>: <span class="type">String</span>?)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">forgetPassword</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: View -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginActionViewProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">AZLoginActionPresenterProtocol</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">// 更新 View 的接口</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">loginError</span>(<span class="keyword">_</span> <span class="params">error</span>: <span class="type">AZError</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">closeWindow</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个简单的功能，写了这么多是不是很蛋疼，明明只需要一个 VC 就可以搞定的事情，非得这么麻烦么？</p>
</blockquote>
<p>其实在真正实现之后，发现除了文件多点以为，登陆的逻辑和流程非常清晰，真正地做到了代码自解释，不同结构之间通过接口来实现交互。将与其他模块无关的功能对外隐藏,而且真正的收益是在整个工程的逻辑和功能变得越来越复杂之后才体现出来。</p>
<h4 id="聊天-VIPER"><a href="#聊天-VIPER" class="headerlink" title="聊天 VIPER"></a>聊天 VIPER</h4><p>登陆成功后，界面会由登陆 VIPER 模块路由到主界面 VIPER，如下图，那么界面就可以正常的切换过来了</p>
<p><img src="/images/router-viper.png" alt="路由切换"></p>
<ul>
<li>搭建几个重要 VIPER 子结构<br>通过分析具体的业务流程和要完成的功能 不断地补充接口，篇幅问题，省略掉大部分细节，以切换 tab 为例。</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// MARK: Wireframe -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZMainWindowWireframeProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MARK: Presenter -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZMainWindowPresenterProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> router: <span class="type">AZMainWindowWireframeProtocol</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">switchMainWindowTabContent</span>(<span class="keyword">_</span> <span class="params">userInfo</span>: [<span class="params">AnyHashable</span>: <span class="keyword">Any</span>])</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: Interactor -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZMainWindowInteractorProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">AZMainWindowPresenterProtocol</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">swithMainWindowTab</span>(<span class="keyword">_</span> <span class="params">tab</span>: <span class="type">AZTitlebarTag</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: View -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZMainWindowViewProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">AZMainWindowPresenterProtocol</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">switchMainWindowTabContent</span>(<span class="keyword">_</span> <span class="params">userInfo</span>: [<span class="params">AnyHashable</span>: <span class="keyword">Any</span>])</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随着功能的逐渐叠加，VIPER 中不同的子结构的代码增加都很平稳，不会出现某一个模块代码量指数级的增加。<br>从前任写完的第一个版本的 bug 叠 bug，到这个版本的内部备受好评，其实基础功能都一致，只不过是界面看上去有着巨大的差别。但是从结果来看维护成本和收益都很不错，但实际上改变的是整个项目的基础结构，开发流程，并且带动了大家往着更合理的方向前进 。<br>从这个过程中，内部总结出了，代码规范，提交规范，开发规范，这么看来，每个人都应该有着不少的收获.</p>
]]></content>
      <categories>
        <category>Mac Develop</category>
      </categories>
      <tags>
        <tag>Mac Develop</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode C++ 配置</title>
    <url>/2020/10/03/VSCode-C/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>经常用 VSCode 来开发 C++，但是调试和配置每次都很头疼，现记录一下配置，备忘</p>
<h2 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang++ build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang++&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;-std=c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;-stdlib=libc++&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="comment">// &quot;$&#123;workspaceFolder&#125;/*.cpp&quot;,</span></span><br><span class="line">          <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$gcc&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h2><p>build and debug<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C++ - Build and debug active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang++ build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="c-cpp-cofiguration-json"><a href="#c-cpp-cofiguration-json" class="headerlink" title="c_cpp_cofiguration.json"></a>c_cpp_cofiguration.json</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mac&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;macFrameworkPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;/System/Library/Frameworks&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;/Library/Frameworks&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang-x64&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>VSCode</category>
      </categories>
      <tags>
        <tag>VSCode</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 端启动速度优化</title>
    <url>/2020/02/19/iOS%E7%AB%AF%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="应用启动流程"><a href="#应用启动流程" class="headerlink" title="应用启动流程"></a>应用启动流程</h2><p> <code>iOS</code> 启动可以分为<code>pre-main</code>阶段和<code>main()</code>阶段</p>
 <span id="more"></span>
<h3 id="pre-main阶段"><a href="#pre-main阶段" class="headerlink" title="pre-main阶段"></a><code>pre-main</code>阶段</h3><ul>
<li>加载可执行文件</li>
<li>加载动态链接库加载器 <code>dyld</code></li>
<li>递归加载动态链接库 <code>dylib</code></li>
</ul>
<h3 id="main-阶段"><a href="#main-阶段" class="headerlink" title="main 阶段"></a><code>main</code> 阶段</h3><ul>
<li><code>dyld</code> 调用 <code>main</code></li>
<li>调用 <code>UIApplicationMain</code></li>
<li>调用 <code>applicationWillFinishLaunching</code></li>
<li>调用 <code>didFinishLaunchingWithOptions</code></li>
</ul>
<h2 id="耗时测量"><a href="#耗时测量" class="headerlink" title="耗时测量"></a>耗时测量</h2><h3 id="pre-main-阶段"><a href="#pre-main-阶段" class="headerlink" title="pre-main 阶段"></a><code>pre-main</code> 阶段</h3><ul>
<li><code>Xcode</code> 的环境变量中 <code>DYLD_PRINT_STATICTICS</code> = 1</li>
<li>日志里面会有详细的内容</li>
</ul>
<h3 id="main-阶段-1"><a href="#main-阶段-1" class="headerlink" title="main 阶段"></a><code>main</code> 阶段</h3><ul>
<li>测量 <code>main</code>  -&gt; <code>didFinishLaunchingWithOptions</code> 的时间</li>
</ul>
<h3 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h3><ul>
<li><code>dyld</code> 加载步骤<ul>
<li><code>Load dylibs</code><blockquote>
<p>分析依赖、<code>Mach-o</code>文件、验证有效性、代码签名注册到内核、对 <code>dylib</code> 的 <code>segment</code> 调用 <code>mmap</code></p>
<ul>
<li>避免使用 <code>embedded dylib</code></li>
<li>合并已有的 <code>dylib</code> , 使用静态库</li>
<li>懒加载 <code>dylib</code></li>
</ul>
</blockquote>
</li>
<li><code>Rebase/Bind</code><blockquote>
<p><code>Rebase</code> 读入镜像、修正 <code>ASLR</code> 导致的内存地址的偏差。消耗在文件 <code>I/O</code>。<br><code>Bind</code> 查询符号表、设置镜像的外部指针。消耗在 <code>CPU</code> 计算</p>
<ul>
<li>减少<code>ObjC</code>的 <code>Class</code> 、<code>Selector</code>、 <code>Category</code> 数量</li>
<li>减少<code>C++</code> 虚函数数量（创建虚函数表有开销）</li>
<li>使用 <code>Swift struct</code>（内部做了优化、符号开销少）</li>
</ul>
</blockquote>
</li>
<li><code>Object setup</code><blockquote>
<p> <code>dyld</code> 会注册声明过的 <code>ObjC</code> 类，将分类方法插入到类的方法列表中、检查 <code>selector</code> 的唯一性</p>
</blockquote>
</li>
<li><code>Initializers</code><blockquote>
<p><code>dyld</code> 开始运行程序的初始化函数、调用每个 <code>ObjC</code> <code>类</code>和<code>分类</code>的 <code>+load</code> 方法，调用 <code>C/C++</code> 中的构造器函数 ( <code>__attibute__(constructor)</code>修饰的函数)， 创建非基本类型的 <code>C++</code> 静态全局变量，随后调用 <code>main</code> 函数</p>
<ul>
<li>减少 <code>+load</code> 函数做的事情，推迟到 <code>+initialize</code> 中</li>
<li>减少构造器函数的个数，在构造器函数里少作些事情</li>
<li>减少 <code>C++</code> 静态全局变量个数</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="main-阶段-2"><a href="#main-阶段-2" class="headerlink" title="main 阶段"></a>main 阶段</h3><blockquote>
<p>减少 <code>didFinishLaunchingWithOptions</code> 方法里的事情</p>
<ul>
<li>梳理依赖库、延迟加载可以延迟加载的库</li>
<li>把可以延迟执行的逻辑，放到后面。</li>
<li>避免复杂/多余计算</li>
<li>避免在 viewDidLoad 和 viewWillAppear中做太多的事情</li>
<li>首页控制器用纯代码方式构建</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>启动速度</tag>
      </tags>
  </entry>
  <entry>
    <title>Weakly Contest 169</title>
    <url>/2019/12/29/Weakly-Contest-169/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/contest/weekly-contest-169">Weakly Contest 169</a></p>
<h3 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h3><p><a href="https://leetcode.com/contest/weekly-contest-169/problems/find-n-unique-integers-sum-up-to-zero/">5295. Find N Unique Integers Sum up to Zero</a></p>
<p>Given an integer n, return any array containing n unique integers such that they add up to 0.</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: n = 5</span><br><span class="line">Output: [-7,-1,1,3,4]</span><br><span class="line">Explanation: These arrays also are accepted [-5,-1,1,2,3] , [-3,-1,2,-2,4].</span><br></pre></td></tr></table></figure>
<p>Example 2:<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: n = 3</span><br><span class="line">Output: [-1,0,1]</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: n = 1</span><br><span class="line">Output: [0]</span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;= n &lt;= 1000</span><br></pre></td></tr></table></figure></p>
<span id="more"></span>
<h3 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h3><h4 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h4><ul>
<li>这是一道简单题</li>
<li>给定一个数，求数组</li>
<li>要求数组的所有元素和位0</li>
</ul>
<h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ul>
<li>给的数有可能为奇数、也有可能为偶数</li>
<li>如果是奇数：从0开始向左右拓展，最后加上0即可</li>
<li>如果为偶数：从0开始向左右拓展</li>
</ul>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sumZero</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span> (n % <span class="number">2</span> != <span class="number">0</span>) ans.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p><a href="https://leetcode.com/contest/weekly-contest-169/problems/all-elements-in-two-binary-search-trees/">5296. All Elements in Two Binary Search Trees My SubmissionsBack to Contest
</a></p>
<p>Given two binary search trees root1 and root2.</p>
<p>Return a list containing all the integers from both trees sorted in ascending order.</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: root1 = [2,1,4], root2 = [1,0,3]</span><br><span class="line">Output: [0,1,1,2,3,4]</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: root1 = [0,-10,10], root2 = [5,1,7,0,2]</span><br><span class="line">Output: [-10,0,0,1,2,5,7,10]</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: root1 = [], root2 = [5,1,7,0,2]</span><br><span class="line">Output: [0,1,2,5,7]</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: root1 = [0,-10,10], root2 = []</span><br><span class="line">Output: [-10,0,10]</span><br><span class="line">Example 5:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Input: root1 = [1,null,8], root2 = [8,1]</span><br><span class="line">Output: [1,1,8,8]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">Each tree has at most 5000 nodes.</span><br><span class="line">Each node<span class="string">&#x27;s value is between [-10^5, 10^5].</span></span><br></pre></td></tr></table></figure>
<h3 id="解题报告-1"><a href="#解题报告-1" class="headerlink" title="解题报告"></a>解题报告</h3><h4 id="理解题意-1"><a href="#理解题意-1" class="headerlink" title="理解题意"></a>理解题意</h4><ul>
<li>这是一道中档难度题</li>
<li>给定两个二叉排序树，要求返回一个包含所有元素并且是递增顺序的列表</li>
</ul>
<h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul>
<li>给定的两个二叉搜索树有可能为空</li>
<li>二叉搜索树中序遍历即为递增排序</li>
<li>遍历两个二叉搜索树，然后对归并排序，时间复杂度为 \(\mathcal{O(max(m,n))}\)</li>
</ul>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">getAllElements</span><span class="params">(TreeNode* root1, TreeNode* root2)</span> </span>&#123;</span><br><span class="line">    function&lt;<span class="type">void</span>(TreeNode*, vector&lt;<span class="type">int</span>&gt;&amp;)&gt; inorder = [&amp;](TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; t) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">      <span class="built_in">inorder</span>(root-&gt;left, t);</span><br><span class="line">      t.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">      <span class="built_in">inorder</span>(root-&gt;right, t);</span><br><span class="line">    &#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t1;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t2;</span><br><span class="line">    <span class="built_in">inorder</span>(root1, t1);</span><br><span class="line">    <span class="built_in">inorder</span>(root2, t2);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; m;</span><br><span class="line">    std::<span class="built_in">merge</span>(<span class="built_in">begin</span>(t1), <span class="built_in">end</span>(t1), <span class="built_in">begin</span>(t2),<span class="built_in">end</span>(t2), std::<span class="built_in">back_inserter</span>(m));</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Weakly Contest</tag>
      </tags>
  </entry>
  <entry>
    <title>Wild Card Matching</title>
    <url>/2020/04/25/WildcardMatching/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/wildcard-matching/">Wild Card Matchin</a></p>
<p>Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for ‘?’ and ‘*’.</p>
<p>‘?’ Matches any single character.<br>‘*’ Matches any sequence of characters (including the empty sequence).<br>The matching should cover the entire input string (not partial).</p>
<p>Note:</p>
<p>s could be empty and contains only lowercase letters a-z.<br>p could be empty and contains only lowercase letters a-z, and characters like ? or *.</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = <span class="string">&quot;aa&quot;</span></span><br><span class="line">p = <span class="string">&quot;a&quot;</span></span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line">Explanation: <span class="string">&quot;a&quot;</span> does not match the entire string <span class="string">&quot;aa&quot;</span>.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = <span class="string">&quot;aa&quot;</span></span><br><span class="line">p = <span class="string">&quot;*&quot;</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: <span class="string">&#x27;*&#x27;</span> matches any sequence.</span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = <span class="string">&quot;cb&quot;</span></span><br><span class="line">p = <span class="string">&quot;?a&quot;</span></span><br><span class="line">Output: <span class="literal">false</span></span><br><span class="line">Explanation: <span class="string">&#x27;?&#x27;</span> matches <span class="string">&#x27;c&#x27;</span>, but the second letter is <span class="string">&#x27;a&#x27;</span>, <span class="built_in">which</span> does not match <span class="string">&#x27;b&#x27;</span>.</span><br></pre></td></tr></table></figure>
<p>Example 4:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = <span class="string">&quot;adceb&quot;</span></span><br><span class="line">p = <span class="string">&quot;*a*b&quot;</span></span><br><span class="line">Output: <span class="literal">true</span></span><br><span class="line">Explanation: The first <span class="string">&#x27;*&#x27;</span> matches the empty sequence, <span class="keyword">while</span> the second <span class="string">&#x27;*&#x27;</span> matches the substring <span class="string">&quot;dce&quot;</span>.</span><br></pre></td></tr></table></figure>
<p>Example 5:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input:</span><br><span class="line">s = <span class="string">&quot;acdcb&quot;</span></span><br><span class="line">p = <span class="string">&quot;a*c?b&quot;</span></span><br><span class="line">Output: <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul>
<li><code>2</code> 个 字符串，长度可能不相等，一个输入字符串，一个是模式字符串</li>
<li><code>?</code> 表示匹配任意单一字符串</li>
<li><code>*</code> 表示匹配任意字符串序列（包含空字符串）</li>
<li>对<code>完整</code>的输入字符串匹配</li>
<li>输入的还有：<code>小写字母</code> 或者<code>空</code>字符</li>
</ul>
<h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><ul>
<li><code>aa</code> 与 <code>a</code> ，单独的 <code>a</code> 不能完整匹配 <code>aa</code></li>
<li><code>aa</code> 与 <code>*</code> ，<code>*</code> 可以匹配任意字符串</li>
<li><code>cb</code> 与 <code>?a</code>, 从后往前看 <code>a</code> 和 <code>b</code> 并不匹配</li>
<li><code>abceb</code> 与 <code>*a*b</code> 如下图<br><img src="/images/wildcard-matching-example4.png" alt="Example 4"></li>
<li><code>acdcb</code> 与 <code>a*c?b</code> 如下图<br><img src="/images/wildcard-matching-example5.png" alt="Example 5"></li>
</ul>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul>
<li>碰到字符且模式串也是字符，直接比较就行</li>
<li>碰到 <code>?</code> 跳过往前匹配即可，<code>?</code> 就表示匹配，</li>
<li>碰到 <code>*</code> 会比较麻烦，因为会匹配 <code>&gt;= 0</code>个字符</li>
<li>但一般这种类型的题目可以使用动态规划来解决</li>
</ul>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h4><ul>
<li>假定<code>dp_[i][j]</code> 表示 匹配串<code>(长为 i)</code> <code>s[0..i-1]</code> 与模式串<code>(长为 j)</code> <code>p[0..j-1]</code> 是否匹配，</li>
<li>首先什么都没有肯定是相互匹配的，那么 <code>dp_[0][0] = true</code></li>
<li><code>dp_[1...i-1][0] = false</code> 表示什么都没有和字符串不匹配</li>
<li><code>dp_[0][j] = dp_[0][j-1]</code> 如果 <code>p[j-1] == *</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatching</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">dp_</span> (m<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n<span class="number">+1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp_[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// for (int i = 1; i &lt;= m; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     dp_[i][0] = false;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp_[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>] &amp;&amp; (p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp_[i][j<span class="number">-1</span>] || dp_[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp_[i][j] = dp_[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;?&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp_[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(m*n)</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(m*n)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
        <tag>Dynamic Programming</tag>
      </tags>
  </entry>
  <entry>
    <title>背包九讲</title>
    <url>/2020/11/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="背包九讲读书笔记"><a href="#背包九讲读书笔记" class="headerlink" title="背包九讲读书笔记"></a>背包九讲读书笔记</h2><h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><h5 id="基本题目套路"><a href="#基本题目套路" class="headerlink" title="基本题目套路"></a>基本题目套路</h5><p>有 <code>N</code> 件物品和一个容量为 <code>V</code> 的背包，放入第 <code>i</code> 件物品消耗的费用是 <code>Ci</code>， 得到的价值是 <code>Wi</code>。 求解将哪些物品装入背包，<code>可使总价值总和最大</code>。</p>
<h5 id="基本题目思路"><a href="#基本题目思路" class="headerlink" title="基本题目思路"></a>基本题目思路</h5><ul>
<li>特点：每件物品只有一个，选择：<code>放</code> or <code>不放</code>。</li>
<li>子问题：<code>F[i, v]</code>： 前 <code>i</code> 件物品恰好放入容量 <code>v</code> 的背包，可以获得的最大价值</li>
<li>状态转移：<code>F[i, v] = max&#123;F[i-1, v], F[i-1, v-Ci] + Wi&#125;</code></li>
<li>当前的价值，只和之前的价值有关，因此两个选择下的价值为：</li>
<li>如果 <code>i</code> 不选，价值：前 <code>i-1</code> 件，放入容量 <code>v</code> 的背包（<code>F[i-1, v]</code>）</li>
<li>如果 <code>i</code> 选择，价值：前 <code>i-1</code> 件，放入容量（<code>v-Ci</code>）的背包（确保 i 能放下去，得减去 i 占用的容量）+ 放入 i 的价值 Wi</li>
</ul>
<h5 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F[<span class="number">0</span>, <span class="number">0.</span>.V] &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to N</span><br><span class="line">    <span class="keyword">for</span> v &lt;- Ci to V</span><br><span class="line">        F[i, v] &lt;- <span class="built_in">max</span>&#123;F[i-<span class="number">1</span>, v], F[i-<span class="number">1</span>, v-Ci] + Wi&#125;</span><br></pre></td></tr></table></figure>
<h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>时间复杂度：<code>O(VN)</code><br>空间复杂度：滚动数组（逆序计算 F[v]，才能保证正确的顺序）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F[<span class="number">0.</span>.V] &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to N</span><br><span class="line">    <span class="keyword">for</span> v &lt;- V to Ci</span><br><span class="line">        F[v] &lt;- <span class="built_in">max</span>&#123;F[v], F[v-Ci] + Wi&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ZeroOnePack</span>(<span class="params">F,C,W</span>)</span><br><span class="line">    <span class="keyword">for</span> v &lt;- V to C</span><br><span class="line">        F[v] &lt;- <span class="built_in">max</span>(F[v], F[C-v] + W)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F[<span class="number">0.</span>.V] &lt;- <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;- <span class="number">1</span> to N</span><br><span class="line">        ZeroOnePack(F,Ci,Wi)</span><br></pre></td></tr></table></figure>
<h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><h4 id="题目基本套路"><a href="#题目基本套路" class="headerlink" title="题目基本套路"></a>题目基本套路</h4><p>N 种物品和容量为 V 的背包，<code>每种物品都有无限件可以用</code>，放入第 <code>i</code> 件物品消耗的费用是 <code>Ci</code>， 得到的价值是 <code>Wi</code>。 求解将哪些物品装入背包，<code>可使物品总消耗费用不超过背包容量</code>，且价值总和最大。</p>
<h4 id="基本套路"><a href="#基本套路" class="headerlink" title="基本套路"></a>基本套路</h4><ul>
<li>每种物品无限件，因此每个物品的策略不是：选和不选。而是<code>选几件</code></li>
<li>状态转移：<code>F[i, v] = max&#123;F[i-1, v-kCi] + kWi | 0 ≤ kCi ≤ v&#125;</code></li>
</ul>
<h4 id="简单有效的优化"><a href="#简单有效的优化" class="headerlink" title="简单有效的优化"></a>简单有效的优化</h4><ul>
<li>若两件物品<code>i</code>, <code>j</code> 满足 <code>Ci ≤ Cj</code> 且 <code>Wi ≥ Wj</code>，则可以将 <code>j</code> 直接去掉，不用考虑 (任何情况下，都可以将价值小费用高的 j 换成物美价廉的 i)</li>
<li>或者 将费用大于 V 的物品去掉</li>
</ul>
<h4 id="转换为-0-1-背包问题"><a href="#转换为-0-1-背包问题" class="headerlink" title="转换为 0-1 背包问题"></a>转换为 0-1 背包问题</h4><ul>
<li>第 i 种物品最多选：V/Ci 种，把第 i 种物品转化为 V/Ci 件费用及价值不变的物品。 （将一种物品转化为多件只能选 0 或者 1 件的 0-1 背包问题）</li>
<li>二进制：第 i 种物品拆成费用为 Ci2^k，价值为 Wi2^k 的若干件物品。 k 满足 Ci2^k ≤ V 的非负整数。</li>
</ul>
]]></content>
      <categories>
        <category>背包问题</category>
      </categories>
      <tags>
        <tag>Medium</tag>
        <tag>背包问题</tag>
      </tags>
  </entry>
</search>
