<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ACE_xW</title>
  
  <subtitle>一个程序员</subtitle>
  <link href="https://bapuqln.github.io/atom.xml" rel="self"/>
  
  <link href="https://bapuqln.github.io/"/>
  <updated>2025-01-15T07:01:21.143Z</updated>
  <id>https://bapuqln.github.io/</id>
  
  <author>
    <name>shouyi.www</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VIPER架构落地IM</title>
    <link href="https://bapuqln.github.io/2025/01/15/VIPER%E6%9E%B6%E6%9E%84%E8%90%BD%E5%9C%B0%E5%88%B0IM/"/>
    <id>https://bapuqln.github.io/2025/01/15/VIPER%E6%9E%B6%E6%9E%84%E8%90%BD%E5%9C%B0%E5%88%B0IM/</id>
    <published>2025-01-15T07:01:21.143Z</published>
    <updated>2025-01-15T07:01:21.143Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h2><p>来新公司也大半年了，发现之前的工程实现的非常不合理，维护成本极高，内部吐槽严重，<code>BUG</code> 叠 <code>BUG</code>，修老 <code>BUG</code> 引入的新 <code>BUG</code> 层出不穷，质量堪忧。</p><h2 id="Pros-amp-Cons"><a href="#Pros-amp-Cons" class="headerlink" title="Pros &amp; Cons"></a>Pros &amp; Cons</h2><p>拿到代码后简单的看了一下:</p><ul><li>使用 <code>MVC</code> 模式，并且由于<code>各种原因</code>，说白了就是写的挫。将 <code>MCV(Model-View-Controller)</code> 写成了 <code>MVC(Massive View Controller)</code></li><li><code>View Controller</code> 写的极为笨重，几乎流程都写在几个比较大的 <code>View Controller</code> 中。牵一发而动全身，能不出错么。</li><li>目前的时机比较不错，新项目要开始了，及得想办法复用之前的逻辑，又得写的没什么问题。</li><li>很久不写这种流程了，还是需要仔细的回归练习一下，而且还能练练 swift，何乐而不为呢</li></ul><h2 id="VIPER-结构简介"><a href="#VIPER-结构简介" class="headerlink" title="VIPER 结构简介"></a>VIPER 结构简介</h2><p><code>VIPER</code> 是视图 (<code>View</code>)，交互器 (<code>Interactor</code>)，展示器 (<code>Presenter</code>)，实体 (<code>Entity</code>) 以及路由 (<code>Routing</code>) 的首字母缩写。这样根据逻辑结构的不同可以划分为不同的责任层。使得依赖更容易隔离，比如说数据库，也更容易单独测试，边界清晰。<br>他们的关系大概是这样的 如下图所示：</p><p><img src="/images/viper_arch.png" alt="VIPER"></p><h2 id="为什么要用-VIPER"><a href="#为什么要用-VIPER" class="headerlink" title="为什么要用 VIPER"></a>为什么要用 VIPER</h2><p>互联网企业都要求快速迭代，要求周期短，质量高。如何快速的在满足需求的前提下下交付质量好的产品，是大家都想解决的问题。对于一个处于一线的程序员来讲，从根上推动整个流程的变化是不切实际的。比较稳妥且的办法是采用技术手段来提高自己的效率，降低出错的概率。<br>对于源源不断的需求，以及不断的需求变化。除了默默的问候这些 PM，不还是得一个字一个字的敲出来。做的不好，大家会怀疑你的能力。面子上挂不住。活那么多，身体抗不住，身为一个快乐的程序员，在减少秃头的情况下得想办法让自己轻松点嘛。</p><h3 id="步入正题"><a href="#步入正题" class="headerlink" title="步入正题"></a>步入正题</h3><ul><li>VIPER 的好处就是模块之前关系比较松散，模块划分清晰，几乎做到了彻底解耦。每个（VIPER）子模块都可以单独的测试，</li><li>避免掉了 MVC -&gt; M(assive)VC 的情况，VC 里面几乎就是个接口调用，几乎就是完成业务流程的胶水代码，而且都是 Protocol 的接口，业务比较清晰。</li><li>数据模型的处理，单独的放到了 Interactor 内部，这一块对于其他模块几乎是透明。</li><li>VC 彻底细化为View 和 Presenter，三者的交互可以参考 MVP 模式，不多说。</li><li>Router 作为业务的入口和跳转的枢纽，将跳转逻辑也吃掉了。</li><li>最终 VIPER 化之后，代码量会变多、文件会变多，逻辑变得清晰可维护。</li><li>不同的 VIPER 模块 通信只有两个途径，一个是通过 ROUTER，另一个是通过 INTERACTOR</li></ul><h3 id="开始落地"><a href="#开始落地" class="headerlink" title="开始落地"></a>开始落地</h3><h4 id="设计图"><a href="#设计图" class="headerlink" title="设计图"></a>设计图</h4><ul><li><p><a href="https://github.com/bapuqln/XCode-Template-Viper-Mac">VIPER 模板</a><br>每次手工新建五个文件着实比较蛋疼，那么使用 XCode 模板每次自动新建不是很爽。链接就是新建好的模板。方便省事，目前只有 Mac 版本，改吧改吧 iOS 版本也不是啥难事</p></li><li><p>以聊天页为例 VIPER 落地<br><img src="/images/chat-view.svg" alt="设计图"></p></li></ul><ol><li>从图中可以看到该页面比较简单，聊天页面大概分两个部分，左边应该是 thread 列表，右边是 消息流。</li><li>窗体的样式几乎都是自定义的。</li><li>顶部存在多 TAB，方便切换不同的显示内容。</li><li>由于是 IM，那就存在登陆和非登陆，因此需要目前两个 VIPER 模块。</li><li>从设计来看，各种 UI 组件都需要自定义，因此需要提供一个 UI 基础组件库，给工程提供子弹。吃掉 UI 的内部细节。只要对外提供行为即可。</li></ol><h4 id="登陆-VIPER-结构"><a href="#登陆-VIPER-结构" class="headerlink" title="登陆 VIPER 结构"></a>登陆 VIPER 结构</h4><ul><li><p>登陆需要简单的输入用户名和密码，然后呢对于登陆成功的状况，会有账户维护和消息同步。</p></li><li><p>设计有要求在登录页内部玩各种花活。因此目前沟通后，登录页划分为登陆输入页，和登陆行为页，两个页面的逻辑和流程不大一样。</p></li><li><p>登陆输入页的协议定义如下</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: Wireframe - 这块 Wireframe 就是 ROUTER</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginMainWireframeProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MARK: Presenter -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginMainViewPresenterProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">// 目前只有注册的行为，因此定义好接口供 VC 使用</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">startRegistration</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: Interactor -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginMainInteractorProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">AZLoginMainViewPresenterProtocol</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">//给 PRESENTER 提供的接口，真正的注册行为是在 INTERACTOR 中发生的</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">startRegistration</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: View -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginMainViewProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> presenter: <span class="type">AZLoginMainViewPresenterProtocol</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/images/login-viper.png" alt="登陆页"></p><ul><li>登陆行为页</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: Wireframe -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginActionWireframeProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">//根据业务需要，这块有可能需要直接的显示到主界面</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">showMainWindow</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MARK: Presenter -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginActionPresenterProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">// 给 VC 提供的接口可以注册和忘记密码，并且在登陆成功后可以有接口给 INTERACTOR 调用(finish)</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">login</span>(<span class="params">email</span>: <span class="type">String</span>?, <span class="params">password</span>: <span class="type">String</span>?)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">finished</span>(<span class="params">login</span> <span class="params">error</span>: <span class="type">AZError</span>?)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">forgetPassword</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: Interactor -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginActionInteractorProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">AZLoginActionPresenterProtocol</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">// 真正的接口，具体的行为是在 INTERACTOR 中发生的，</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">login</span>(<span class="params">email</span>: <span class="type">String</span>?, <span class="params">password</span>: <span class="type">String</span>?)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">forgetPassword</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: View -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZLoginActionViewProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">AZLoginActionPresenterProtocol</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">// 更新 View 的接口</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">loginError</span>(<span class="keyword">_</span> <span class="params">error</span>: <span class="type">AZError</span>)</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">closeWindow</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>一个简单的功能，写了这么多是不是很蛋疼，明明只需要一个 VC 就可以搞定的事情，非得这么麻烦么？</p></blockquote><p>其实在真正实现之后，发现除了文件多点以为，登陆的逻辑和流程非常清晰，真正地做到了代码自解释，不同结构之间通过接口来实现交互。将与其他模块无关的功能对外隐藏,而且真正的收益是在整个工程的逻辑和功能变得越来越复杂之后才体现出来。</p><h4 id="聊天-VIPER"><a href="#聊天-VIPER" class="headerlink" title="聊天 VIPER"></a>聊天 VIPER</h4><p>登陆成功后，界面会由登陆 VIPER 模块路由到主界面 VIPER，如下图，那么界面就可以正常的切换过来了</p><p><img src="/images/router-viper.png" alt="路由切换"></p><ul><li>搭建几个重要 VIPER 子结构<br>通过分析具体的业务流程和要完成的功能 不断地补充接口，篇幅问题，省略掉大部分细节，以切换 tab 为例。</li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MARK: Wireframe -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZMainWindowWireframeProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MARK: Presenter -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZMainWindowPresenterProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> router: <span class="type">AZMainWindowWireframeProtocol</span> &#123; <span class="keyword">get</span> &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">switchMainWindowTabContent</span>(<span class="keyword">_</span> <span class="params">userInfo</span>: [<span class="params">AnyHashable</span>: <span class="keyword">Any</span>])</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: Interactor -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZMainWindowInteractorProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">AZMainWindowPresenterProtocol</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">swithMainWindowTab</span>(<span class="keyword">_</span> <span class="params">tab</span>: <span class="type">AZTitlebarTag</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MARK: View -</span></span><br><span class="line"><span class="keyword">protocol</span> <span class="title class_">AZMainWindowViewProtocol</span>: <span class="keyword">class</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> presenter: <span class="type">AZMainWindowPresenterProtocol</span>? &#123; <span class="keyword">get</span> <span class="keyword">set</span> &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">switchMainWindowTabContent</span>(<span class="keyword">_</span> <span class="params">userInfo</span>: [<span class="params">AnyHashable</span>: <span class="keyword">Any</span>])</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随着功能的逐渐叠加，VIPER 中不同的子结构的代码增加都很平稳，不会出现某一个模块代码量指数级的增加。<br>从前任写完的第一个版本的 bug 叠 bug，到这个版本的内部备受好评，其实基础功能都一致，只不过是界面看上去有着巨大的差别。但是从结果来看维护成本和收益都很不错，但实际上改变的是整个项目的基础结构，开发流程，并且带动了大家往着更合理的方向前进 。<br>从这个过程中，内部总结出了，代码规范，提交规范，开发规范，这么看来，每个人都应该有着不少的收获.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;问题由来&quot;&gt;&lt;a href=&quot;#问题由来&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Mac Develop" scheme="https://bapuqln.github.io/categories/Mac-Develop/"/>
    
    
    <category term="Mac Develop" scheme="https://bapuqln.github.io/tags/Mac-Develop/"/>
    
  </entry>
  
  <entry>
    <title>Groking The coding Interview</title>
    <link href="https://bapuqln.github.io/2020/11/16/GrokingTheCodeInterview/"/>
    <id>https://bapuqln.github.io/2020/11/16/GrokingTheCodeInterview/</id>
    <published>2020-11-16T02:33:32.000Z</published>
    <updated>2025-01-15T07:01:21.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p><a href="https://leetcode.com/problems/add-two-numbers/">AddTwoNumbers</a><br>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p><p>Example:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul><li><code>2</code> 个 <code>非空</code>链表，长度可能不相等</li><li>每个链表为<code>逆序</code></li><li>返回两个链表的和</li><li>每个元素应该为正数</li></ul><h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><ul><li><code>2 -&gt; 4 -&gt; 3</code> = <code>342</code></li><li><code>5 -&gt; 6 -&gt; 4</code> = <code>465</code></li><li><code>342 + 465 = 807</code></li><li>答案 : <code>7 -&gt; 0 -&gt; 8</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>将每一个链表变成整形，然后相加，结果分解成链表不大合适，还得处理越界的情况</li><li>比较合理的办法：是一边遍历一边生成链表</li><li>每一个生成的节点为两个数的和，有可能产生进位: 如 <code>7+8=15</code></li><li>一个节点的结果为：<code>sum = 前一个节点的进位+两个节点的和</code>，<code>res = sum % 10</code>;</li><li>一个节点的结果几种情况<ul><li><code>last_carry + left + right &lt; 10</code></li><li><code>last_carry + left + right &gt;= 10</code></li><li><code>只要有进位，就一定会有一个新的节点出现</code></li></ul></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *head = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="type">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span> (sum % <span class="number">10</span>);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">var</span> val: <span class="type">Int</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">var</span> next: <span class="type">ListNode</span>?</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">init</span>(<span class="keyword">_</span> <span class="params">val</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">     <span class="keyword">self</span>.val <span class="operator">=</span> val</span><br><span class="line">     <span class="keyword">self</span>.next <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">addTwoNumbers</span>(<span class="keyword">_</span> <span class="params">l1</span>: <span class="type">ListNode</span>?, <span class="keyword">_</span> <span class="params">l2</span>: <span class="type">ListNode</span>?) -&gt; <span class="type">ListNode</span>? &#123;</span><br><span class="line">    <span class="keyword">var</span> l1 <span class="operator">=</span> l1</span><br><span class="line">        <span class="keyword">var</span> l2 <span class="operator">=</span> l2</span><br><span class="line">        <span class="keyword">var</span> prev <span class="operator">=</span> <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> carry <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> head <span class="operator">=</span> prev</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1 <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">||</span> l2 <span class="operator">!=</span> <span class="literal">nil</span> <span class="operator">||</span> carry <span class="operator">!=</span> <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> cur <span class="operator">=</span> <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">let</span> sum <span class="operator">=</span> (l2 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> <span class="number">0</span> : l2<span class="operator">!</span>.val) <span class="operator">+</span> (l1 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> <span class="number">0</span> : l1<span class="operator">!</span>.val) <span class="operator">+</span> carry</span><br><span class="line">            cur.val <span class="operator">=</span> sum <span class="operator">%</span> <span class="number">10</span></span><br><span class="line">            carry <span class="operator">=</span> sum <span class="operator">/</span> <span class="number">10</span></span><br><span class="line">            prev.next <span class="operator">=</span> cur</span><br><span class="line">            prev <span class="operator">=</span> cur</span><br><span class="line">            l1 <span class="operator">=</span> l1 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> l1: l1<span class="operator">?</span>.next</span><br><span class="line">            l2 <span class="operator">=</span> l2 <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">?</span> l2: l2<span class="operator">?</span>.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>这道题比较简单，递归模式也比较好想到<br>加法需要三个值，两个操作符（来自两个链表）以及一个进位标记。<br>因此递归模式为：</p><ul><li>递归出口：两个链表都已经到达末尾，并且没有进位</li><li>递归实现：<ul><li>当前节点的结果为：和/10</li><li>当前节点的next节点为：对于两个链表next节点的计算的结果</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2, <span class="type">int</span> carry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2 &amp;&amp; !carry) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="type">int</span> sum = (l1?l1-&gt;val:<span class="number">0</span>) + (l2?l2-&gt;val:<span class="number">0</span>) + carry;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> <span class="built_in">ListNode</span>(sum % <span class="number">10</span>);</span><br><span class="line">        ans-&gt;next = <span class="built_in">addTwoNumbers</span>(l1?l1-&gt;next:<span class="literal">nullptr</span>, l2?l2-&gt;next:<span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">addTwoNumbers</span>(l1, l2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>遍历次数：<code>max(len(l1), len(l2)) + 1</code>，因此是线性时间 \(\mathcal{O(max(len(l1), len(l2)))}\)</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>额外申请了和一个链表，因此空间复杂度也为 \(\mathcal{O(max(len(l1), len(l2)))}\)</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;滑动窗口&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/add-two-numbers/&quot;&gt;AddTwoNumbers&lt;/a&gt;&lt;br&gt;You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.&lt;/p&gt;
&lt;p&gt;You may assume the two numbers do not contain any leading zero, except the number 0 itself.&lt;/p&gt;
&lt;p&gt;Example:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: (2 -&amp;gt; 4 -&amp;gt; 3) + (5 -&amp;gt; 6 -&amp;gt; 4)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 7 -&amp;gt; 0 -&amp;gt; 8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: 342 + 465 = 807.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Groking The Coding Interview" scheme="https://bapuqln.github.io/categories/Groking-The-Coding-Interview/"/>
    
    
    <category term="educative.io" scheme="https://bapuqln.github.io/tags/educative-io/"/>
    
  </entry>
  
  <entry>
    <title>背包九讲</title>
    <link href="https://bapuqln.github.io/2020/11/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>https://bapuqln.github.io/2020/11/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-08T02:40:18.000Z</published>
    <updated>2025-01-15T07:01:21.143Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="背包九讲读书笔记"><a href="#背包九讲读书笔记" class="headerlink" title="背包九讲读书笔记"></a>背包九讲读书笔记</h2><h3 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h3><h5 id="基本题目套路"><a href="#基本题目套路" class="headerlink" title="基本题目套路"></a>基本题目套路</h5><p>有 <code>N</code> 件物品和一个容量为 <code>V</code> 的背包，放入第 <code>i</code> 件物品消耗的费用是 <code>Ci</code>， 得到的价值是 <code>Wi</code>。 求解将哪些物品装入背包，<code>可使总价值总和最大</code>。</p><h5 id="基本题目思路"><a href="#基本题目思路" class="headerlink" title="基本题目思路"></a>基本题目思路</h5><ul><li>特点：每件物品只有一个，选择：<code>放</code> or <code>不放</code>。</li><li>子问题：<code>F[i, v]</code>： 前 <code>i</code> 件物品恰好放入容量 <code>v</code> 的背包，可以获得的最大价值</li><li>状态转移：<code>F[i, v] = max&#123;F[i-1, v], F[i-1, v-Ci] + Wi&#125;</code></li><li>当前的价值，只和之前的价值有关，因此两个选择下的价值为：</li><li>如果 <code>i</code> 不选，价值：前 <code>i-1</code> 件，放入容量 <code>v</code> 的背包（<code>F[i-1, v]</code>）</li><li>如果 <code>i</code> 选择，价值：前 <code>i-1</code> 件，放入容量（<code>v-Ci</code>）的背包（确保 i 能放下去，得减去 i 占用的容量）+ 放入 i 的价值 Wi</li></ul><h5 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F[<span class="number">0</span>, <span class="number">0.</span>.V] &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to N</span><br><span class="line">    <span class="keyword">for</span> v &lt;- Ci to V</span><br><span class="line">        F[i, v] &lt;- <span class="built_in">max</span>&#123;F[i-<span class="number">1</span>, v], F[i-<span class="number">1</span>, v-Ci] + Wi&#125;</span><br></pre></td></tr></table></figure><h5 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h5><p>时间复杂度：<code>O(VN)</code><br>空间复杂度：滚动数组（逆序计算 F[v]，才能保证正确的顺序）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">F[<span class="number">0.</span>.V] &lt;- <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i &lt;- <span class="number">1</span> to N</span><br><span class="line">    <span class="keyword">for</span> v &lt;- V to Ci</span><br><span class="line">        F[v] &lt;- <span class="built_in">max</span>&#123;F[v], F[v-Ci] + Wi&#125;</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ZeroOnePack</span>(<span class="params">F,C,W</span>)</span><br><span class="line">    <span class="keyword">for</span> v &lt;- V to C</span><br><span class="line">        F[v] &lt;- <span class="built_in">max</span>(F[v], F[C-v] + W)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">F[<span class="number">0.</span>.V] &lt;- <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt;- <span class="number">1</span> to N</span><br><span class="line">        ZeroOnePack(F,Ci,Wi)</span><br></pre></td></tr></table></figure><h3 id="完全背包问题"><a href="#完全背包问题" class="headerlink" title="完全背包问题"></a>完全背包问题</h3><h4 id="题目基本套路"><a href="#题目基本套路" class="headerlink" title="题目基本套路"></a>题目基本套路</h4><p>N 种物品和容量为 V 的背包，<code>每种物品都有无限件可以用</code>，放入第 <code>i</code> 件物品消耗的费用是 <code>Ci</code>， 得到的价值是 <code>Wi</code>。 求解将哪些物品装入背包，<code>可使物品总消耗费用不超过背包容量</code>，且价值总和最大。</p><h4 id="基本套路"><a href="#基本套路" class="headerlink" title="基本套路"></a>基本套路</h4><ul><li>每种物品无限件，因此每个物品的策略不是：选和不选。而是<code>选几件</code></li><li>状态转移：<code>F[i, v] = max&#123;F[i-1, v-kCi] + kWi | 0 ≤ kCi ≤ v&#125;</code></li></ul><h4 id="简单有效的优化"><a href="#简单有效的优化" class="headerlink" title="简单有效的优化"></a>简单有效的优化</h4><ul><li>若两件物品<code>i</code>, <code>j</code> 满足 <code>Ci ≤ Cj</code> 且 <code>Wi ≥ Wj</code>，则可以将 <code>j</code> 直接去掉，不用考虑 (任何情况下，都可以将价值小费用高的 j 换成物美价廉的 i)</li><li>或者 将费用大于 V 的物品去掉</li></ul><h4 id="转换为-0-1-背包问题"><a href="#转换为-0-1-背包问题" class="headerlink" title="转换为 0-1 背包问题"></a>转换为 0-1 背包问题</h4><ul><li>第 i 种物品最多选：V/Ci 种，把第 i 种物品转化为 V/Ci 件费用及价值不变的物品。 （将一种物品转化为多件只能选 0 或者 1 件的 0-1 背包问题）</li><li>二进制：第 i 种物品拆成费用为 Ci2^k，价值为 Wi2^k 的若干件物品。 k 满足 Ci2^k ≤ V 的非负整数。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;背包九讲读书笔记&quot;&gt;&lt;a href=&quot;#背包九讲读书笔记&quot; cla</summary>
      
    
    
    
    <category term="背包问题" scheme="https://bapuqln.github.io/categories/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
    
    <category term="Medium" scheme="https://bapuqln.github.io/tags/Medium/"/>
    
    <category term="背包问题" scheme="https://bapuqln.github.io/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Mac_NSTextView_中英混输情况下_inline_上下抖动</title>
    <link href="https://bapuqln.github.io/2020/10/05/Mac-NSTextView-%E4%B8%AD%E8%8B%B1%E6%B7%B7%E8%BE%93%E6%83%85%E5%86%B5%E4%B8%8B-inline-%E4%B8%8A%E4%B8%8B%E6%8A%96%E5%8A%A8/"/>
    <id>https://bapuqln.github.io/2020/10/05/Mac-NSTextView-%E4%B8%AD%E8%8B%B1%E6%B7%B7%E8%BE%93%E6%83%85%E5%86%B5%E4%B8%8B-inline-%E4%B8%8A%E4%B8%8B%E6%8A%96%E5%8A%A8/</id>
    <published>2020-10-05T02:57:04.000Z</published>
    <updated>2025-01-15T07:01:21.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="问题由来"><a href="#问题由来" class="headerlink" title="问题由来"></a>问题由来</h1><p>今天在做项目的时候，发现自定义的 <code>NSTextView</code> 出现了几种情况比较蛋疼</p><ul><li><p>对齐问题，英文对齐，中文偏移</p></li><li><p>在中英文混输的情况下，会出现之前的文字上下抖动的情况，可以拿出来钉钉试试</p></li></ul><blockquote><p>先在输入框中输入中文（<code>啊</code>），空格上屏后，再输入一个英文字符 <code>a</code></p><p>不断地尝试删除 <code>a</code>，再输入 <code>a</code></p><p>你会看到 <code>啊</code> 会随着你的输入和删除上下做轻微的抖动，感觉在拍抖音，给个背景音乐很应景</p></blockquote><h1 id="自己的项目"><a href="#自己的项目" class="headerlink" title="自己的项目"></a>自己的项目</h1><p>出现了同样的问题，而且更严重的是，同样的输入框，在作为用户签名的时候，中文会有明显的偏移</p><blockquote><p>英文对齐，中文上偏</p></blockquote><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>尝试了很多办法，其实比较简单，让自定义的 <code>layoutManager</code> 和 <code>textContainer</code> 去适配一下。<br>关键代码如下</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">textStorage.addLayoutManager(layoutManager)</span><br><span class="line">layoutManager.addTextContainer(textContainer)</span><br><span class="line">layoutManager.typesetterBehavior <span class="operator">=</span> .behavior_10_2_WithCompatibility</span><br></pre></td></tr></table></figure><p>前后比较一下，所有问题都消失了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;问题由来&quot;&gt;&lt;a href=&quot;#问题由来&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Mac Develop" scheme="https://bapuqln.github.io/categories/Mac-Develop/"/>
    
    <category term="Swift" scheme="https://bapuqln.github.io/categories/Mac-Develop/Swift/"/>
    
    
    <category term="Mac Develop" scheme="https://bapuqln.github.io/tags/Mac-Develop/"/>
    
    <category term="Swift" scheme="https://bapuqln.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>VSCode C++ 配置</title>
    <link href="https://bapuqln.github.io/2020/10/03/VSCode-C/"/>
    <id>https://bapuqln.github.io/2020/10/03/VSCode-C/</id>
    <published>2020-10-03T05:04:54.000Z</published>
    <updated>2025-01-15T07:01:21.143Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>经常用 VSCode 来开发 C++，但是调试和配置每次都很头疼，现记录一下配置，备忘</p><h2 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line">    <span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;shell&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;label&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang++ build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang++&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;-std=c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;-stdlib=libc++&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;-g&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="comment">// &quot;$&#123;workspaceFolder&#125;/*.cpp&quot;,</span></span><br><span class="line">          <span class="string">&quot;$&#123;file&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;-o&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;options&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$gcc&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h2><p>build and debug<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;C++ - Build and debug active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cppdbg&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;program&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;fileDirname&#125;/$&#123;fileBasenameNoExtension&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;stopAtEntry&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;cwd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;environment&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;externalConsole&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;MIMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lldb&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang++ build active file&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;setupCommands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="punctuation">&#123;</span></span><br><span class="line">                    <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Enable pretty-printing for gdb&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;text&quot;</span><span class="punctuation">:</span> <span class="string">&quot;-enable-pretty-printing&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    <span class="attr">&quot;ignoreFailures&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">                <span class="punctuation">&#125;</span></span><br><span class="line">            <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></p><h2 id="c-cpp-cofiguration-json"><a href="#c-cpp-cofiguration-json" class="headerlink" title="c_cpp_cofiguration.json"></a>c_cpp_cofiguration.json</h2><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Mac&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;includePath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$&#123;workspaceFolder&#125;/**&quot;</span><span class="punctuation">,</span> <span class="string">&quot;/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;defines&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;macFrameworkPath&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="string">&quot;/System/Library/Frameworks&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="string">&quot;/Library/Frameworks&quot;</span></span><br><span class="line">        <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;compilerPath&quot;</span><span class="punctuation">:</span> <span class="string">&quot;/usr/bin/clang&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c11&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;cppStandard&quot;</span><span class="punctuation">:</span> <span class="string">&quot;c++17&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;intelliSenseMode&quot;</span><span class="punctuation">:</span> <span class="string">&quot;clang-x64&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="number">4</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h1 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="VSCode" scheme="https://bapuqln.github.io/categories/VSCode/"/>
    
    
    <category term="VSCode" scheme="https://bapuqln.github.io/tags/VSCode/"/>
    
  </entry>
  
  <entry>
    <title>SweepLine</title>
    <link href="https://bapuqln.github.io/2020/09/22/SweepLine/"/>
    <id>https://bapuqln.github.io/2020/09/22/SweepLine/</id>
    <published>2020-09-21T16:00:00.000Z</published>
    <updated>2025-01-15T07:01:21.142Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>今天做了一道题，<a href="https://leetcode.com/problems/subarray-sum-equals-k/">LeetCode 560. Subarray Sum Equals K</a>，有点蒙蔽，看了答案发现比较简单，记录一下</p><p>给定一个整数数组和一个整数 <code>k</code>，你需要找到该数组中和为 <code>k</code> 的连续的子数组的个数。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1 :</span><br><span class="line"></span><br><span class="line">输入:nums = [1,1,1], k = 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br><span class="line">说明 :</span><br><span class="line"></span><br><span class="line">数组的长度为 [1, 20,000]。</span><br><span class="line">数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><p>题目的意思比较明确，要求找到 <code>n</code> 个连续的子数组，并且这些连续子数组的和为 <code>k</code></p><ul><li>子数组求和</li><li>子数组求和可以使用前缀和，那么如何知道它能够满足需求? 前缀和可以知道具体区间的和，那么区间终点的值 -k，就是这段区间的起点。</li><li>需要一个哈希表，来记录上次出现该值得地方，找到 <code>cur-k</code> 就是找到了和位 <code>k</code> 的区间起点。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">int</span> <span class="title">subArraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, pre = <span class="number">0</span>;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; memo_;</span><br><span class="line">    memo_[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;num : nums) &#123;</span><br><span class="line">      pre += num;</span><br><span class="line">      <span class="keyword">if</span> (memo_.<span class="built_in">find</span>(pre - k) != memo_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        ans += memo_[pre - k];</span><br><span class="line">      &#125;</span><br><span class="line">      memo_[pre]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;今天做了一道题，&lt;a href=&quot;https://leetcode.com/problems/subarray-sum-equals-k/&quot;&gt;LeetCode 560. Subarray Sum Equals K&lt;/a&gt;，有点蒙蔽，看了答案发现比较简单，记录一下&lt;/p&gt;
&lt;p&gt;给定一个整数数组和一个整数 &lt;code&gt;k&lt;/code&gt;，你需要找到该数组中和为 &lt;code&gt;k&lt;/code&gt; 的连续的子数组的个数。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;示例 1 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:nums = [1,1,1], k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;说明 :&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数组的长度为 [1, 20,000]。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://bapuqln.github.io/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>位操作</title>
    <link href="https://bapuqln.github.io/2020/08/11/BitManupulate/"/>
    <id>https://bapuqln.github.io/2020/08/11/BitManupulate/</id>
    <published>2020-08-11T06:36:46.000Z</published>
    <updated>2025-01-15T07:01:21.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"> <span id="more"></span><h1 id="位操作总结"><a href="#位操作总结" class="headerlink" title="位操作总结"></a>位操作总结</h1><p>基本上位操作就那么几个:</p><h2 id="异或的特性"><a href="#异或的特性" class="headerlink" title="异或的特性"></a>异或的特性</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x ^ <span class="number">0</span> = x</span><br><span class="line"></span><br><span class="line">x ^ <span class="number">11111</span>……<span class="number">1111</span> = ~x</span><br><span class="line"></span><br><span class="line">x ^ (~x) = <span class="number">11111</span>……<span class="number">1111</span></span><br><span class="line"></span><br><span class="line">x ^ x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">a ^ b = c =&gt; a ^ c = b =&gt; b ^ c = <span class="built_in">a</span> (交换律) a ^ b ^ c = a ^ (b ^ c) = (a ^ b）^ <span class="built_in">c</span> (结合律)</span><br></pre></td></tr></table></figure><h2 id="构造特殊的Mask"><a href="#构造特殊的Mask" class="headerlink" title="构造特殊的Mask"></a>构造特殊的Mask</h2><ul><li>将 <code>x</code> 最右边的 <code>n</code> 位清零， <code>x &amp; ( ~0 &lt;&lt; n )</code></li><li>获取 <code>x</code> 的第 <code>n</code> 位值(0 或者 1)，<code>(x &gt;&gt; n) &amp; 1</code></li><li>获取 <code>x</code> 的第 <code>n</code> 位的幂值，<code>x &amp; (1 &lt;&lt; (n - 1))</code></li><li>仅将第 <code>n</code> 位置为 <code>1</code>，<code>x | (1 &lt;&lt; n)</code></li><li>仅将第 <code>n</code> 位置为 <code>0</code>，<code>x &amp; (~(1 &lt;&lt; n))</code></li><li>将 <code>x</code> 最⾼位⾄第 <code>n</code> 位(含)清零，<code>x &amp; ((1 &lt;&lt; n) - 1)</code></li><li>将第 <code>n</code> 位⾄第 <code>0</code> 位(含)清零，<code>x &amp; (~((1 &lt;&lt; (n + 1)) - 1)</code></li></ul><h1 id=""><a href="#" class="headerlink" title="#"></a>#</h1><p><code>X &amp; 1 == 1</code> 判断是否是奇数(偶数)<br><code>X &amp; = (X - 1)</code> 将最低位(LSB)的 1 清零<br><code>X &amp; -X</code> 得到最低位(LSB)的 1</p><p><code>X &amp; ~X = 0</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt; &lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h1 id=&quot;位操作总结&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Bit Manupulate" scheme="https://bapuqln.github.io/tags/Bit-Manupulate/"/>
    
  </entry>
  
  <entry>
    <title>Range Sum Query</title>
    <link href="https://bapuqln.github.io/2020/07/11/RangeSumQuery/"/>
    <id>https://bapuqln.github.io/2020/07/11/RangeSumQuery/</id>
    <published>2020-07-11T13:41:49.000Z</published>
    <updated>2025-01-15T07:01:21.142Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="Range-Sum-Query-Immutable"><a href="#Range-Sum-Query-Immutable" class="headerlink" title="Range Sum Query Immutable"></a>Range Sum Query Immutable</h2><p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p><p>Example:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [-2, 0, 3, -5, 2, -1]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br><span class="line">Note:</span><br><span class="line">You may assume that the array does not change.</span><br><span class="line">There are many calls to sumRange <span class="keyword">function</span>.</span><br></pre></td></tr></table></figure><br><span id="more"></span></p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>比较简单的 Range Sum Query，只要知道前缀和就可以计算出不变数组的任意区间的和。</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        v_.<span class="built_in">push_back</span>(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums) &#123;</span><br><span class="line">            v_.<span class="built_in">push_back</span>(v_.<span class="built_in">back</span>() + num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v_[j<span class="number">+1</span>] - v_[i]; <span class="comment">// O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Range-Sum-Query-2D-Immutable"><a href="#Range-Sum-Query-2D-Immutable" class="headerlink" title="Range Sum Query 2D - Immutable"></a>Range Sum Query 2D - Immutable</h2><p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p><p>Range Sum Query 2D<br>The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.</p><p>Example:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Given matrix = [</span><br><span class="line">  [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="built_in">sumRegion</span>(<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>) -&gt; <span class="number">8</span></span><br><span class="line"><span class="built_in">sumRegion</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>) -&gt; <span class="number">11</span></span><br><span class="line"><span class="built_in">sumRegion</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>) -&gt; <span class="number">12</span></span><br></pre></td></tr></table></figure><p>Note:<br>You may assume that the matrix does not change.<br>There are many calls to sumRegion function.<br>You may assume that row1 ≤ row2 and col1 ≤ col2.</p><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>参考之前Range Sum Query 的思想，肯定是要提前计算出需要的数据，最后计算和相当于查表。</li><li>那么 2D 数组如何计算使用类似的思想呢</li><li>矩形区域的和相当于多个矩形区域进行叠加后减去重复计算的区域，如下图所示，小矩形区域可以看做三个以左上角（0，0）为顶点的矩形区域与大的矩形区域的操作后的结果<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> a <span class="number">2</span>D array sum[row<span class="number">+1</span>][col<span class="number">+1</span>]</span><br><span class="line">sums[i<span class="number">+1</span>][j<span class="number">+1</span>] represents the sum of area from matrix[<span class="number">0</span>][<span class="number">0</span>] to matrix[i][j]</span><br><span class="line">(notice: we add additional blank row sums[<span class="number">0</span>][col<span class="number">+1</span>]=&#123;<span class="number">0</span>&#125; <span class="keyword">and</span> blank column sums[row<span class="number">+1</span>][<span class="number">0</span>]=&#123;<span class="number">0</span>&#125; to remove the edge <span class="keyword">case</span> checking), so, we can have the following definition</span><br><span class="line">+-----+-+-------+     +--------+-----+     +-----+---------+     +-----+--------+</span><br><span class="line">|     | |       |     |        |     |     |     |         |     |     |        |</span><br><span class="line">|     | |       |     |        |     |     |     |         |     |     |        |</span><br><span class="line">+-----+-+       |     +--------+     |     |     |         |     +-----+        |</span><br><span class="line">|     | |       |  =  |              |  +  |     |         |  -  |              |</span><br><span class="line">+-----+-+       |     |              |     +-----+         |     |              |</span><br><span class="line">|               |     |              |     |               |     |              |</span><br><span class="line">|               |     |              |     |               |     |              |</span><br><span class="line">+---------------+     +--------------+     +---------------+     +--------------+</span><br><span class="line"></span><br><span class="line">   sums[i][j]      =    sums[i<span class="number">-1</span>][j]    +     sums[i][j<span class="number">-1</span>]    -   sums[i<span class="number">-1</span>][j<span class="number">-1</span>]   +</span><br><span class="line"></span><br><span class="line">                        matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li><li>因此使用同样的思路计算区域如下</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br><span class="line">|               |   |         |    |   |   |           |   |         |    |   |   |          |</span><br><span class="line">|   (r1,c1)     |   |         |    |   |   |           |   |         |    |   |   |          |</span><br><span class="line">|   +------+    |   |         |    |   |   |           |   +---------+    |   +---+          |</span><br><span class="line">|   |      |    | = |         |    | - |   |           | - |      (r1,c2) | + |   (r1,c1)    |</span><br><span class="line">|   |      |    |   |         |    |   |   |           |   |              |   |              |</span><br><span class="line">|   +------+    |   +---------+    |   +---+           |   |              |   |              |</span><br><span class="line">|        (r2,c2)|   |       (r2,c2)|   |   (r2,c1)     |   |              |   |              |</span><br><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br></pre></td></tr></table></figure><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; sum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumMatrix</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = m &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].<span class="built_in">size</span>() : <span class="number">0</span>;</span><br><span class="line">        sum = vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;(m<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n<span class="number">+1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                sum[i][j] = sum[i<span class="number">-1</span>][j<span class="number">-1</span>] + sum[i][j<span class="number">-1</span>] - sum[i<span class="number">-1</span>][j<span class="number">-1</span>] + matrix[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[row2<span class="number">+1</span>][col2<span class="number">+1</span>] - sums[row2<span class="number">+1</span>][col1] - sums[row1][col2<span class="number">+1</span>] + sums[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Range-Sum-Query-Mutable"><a href="#Range-Sum-Query-Mutable" class="headerlink" title="Range Sum Query Mutable"></a>Range Sum Query Mutable</h2><p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p><p>The update(i, val) function modifies nums by updating the element at index i to val.</p><p>Example:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Given nums = [1, 3, 5]</span><br><span class="line">-</span><br><span class="line">sumRange(0, 2) -&gt; 9</span><br><span class="line">update(1, 2)</span><br><span class="line">sumRange(0, 2) -&gt; 8</span><br></pre></td></tr></table></figure><br>Note:</p><p>The array is only modifiable by the update function.<br>You may assume the number of calls to update and sumRange function is distributed evenly.</p><h3 id="Fenwick-Tree-Binary-Index-Tree"><a href="#Fenwick-Tree-Binary-Index-Tree" class="headerlink" title="Fenwick Tree (Binary Index Tree)"></a>Fenwick Tree (Binary Index Tree)</h3><p>树状数组，我们需要两个数组来存储，原始数组和 bit 数组</p><ul><li>假定 i 为左子节点，那么其父节点的坐标为 (i + lowbit(i))</li><li>假定 i 为右子节点，那么其父节点的坐标为 (i - lowbit(i))</li><li>update(int i, int delta) —&gt; 更新前缀和数组中每一个受影响前缀和，从 i 到 最后一个位置 O (n)</li><li>query(int) —&gt; 直接返回 idx + 1 的前缀和 O(1)</li><li>求 i 到 j 的前缀和 就可用 query(j+1) - query(i) 来计算</li><li>求和的基本思想，给定要求和的位置 i，可以用二级制表示法来分段求和，以 13 为例  13 = 2^3 + 2 ^2 + 2 ^ 0;</li><li>因此 prefixSum(13) = Range(1, 8) + Range(9, 12) + Range(13) // Range(i, j) 表示 i 到 j 的数字求和</li><li>arr = [1, 7, 3, 0, 5, 8, 3, 2, 6, 2, 1, 1, 4, 5]<br>prefixSum(13) = RANGE(1, 8) + RANGE(9, 12) + RANGE(13, 13)<br>= 29 + 10 + 4 = 43</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FenwickTree</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; sum_;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FenwickTree</span>(<span class="type">int</span> n) : <span class="built_in">sum</span>(n<span class="number">+1</span>, <span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// 更新一个值，坐标 为 i，需要修改 bit 数组中涵盖了 原始数组 arr[i] 的值 --&gt;  下标 i 以及所有的父节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; sum.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            sum_[i] += delta;</span><br><span class="line">            i += <span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间求和，假定求 i --&gt; j 的数值之和，可以求 0 --&gt; i-1 , 0 --&gt; j，再相减</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> i)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += sum_[i];</span><br><span class="line">            i -= <span class="built_in">lowbit</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间求和 和 更新数组 都是 O(logn)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums_;</span><br><span class="line">    FenwickTree tree_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt; nums): <span class="built_in">nums_</span>(<span class="built_in">move</span>(nums)), <span class="built_in">tree_</span>(nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            tree_.<span class="built_in">update</span>(i<span class="number">+1</span>, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        tree_.<span class="built_in">update</span>(i, val - nums[i]);</span><br><span class="line">        nums_[i] -= val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumQuery</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree_.<span class="built_in">query</span>(j<span class="number">+1</span>) - tree_.<span class="built_in">query</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Segment-Tree"><a href="#Segment-Tree" class="headerlink" title="Segment Tree"></a>Segment Tree</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentNode</span>&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="type">int</span> sum;</span><br><span class="line">    SegmentNode *left;</span><br><span class="line">    SegmentNode *right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SegmentNode</span>(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> sum, SegmentNode *left = <span class="literal">nullptr</span>, SegmentNode *right = <span class="literal">nullptr</span>):</span><br><span class="line">     <span class="built_in">start</span>(start), <span class="built_in">end</span>(end), <span class="built_in">sum</span>(sum), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right);</span><br><span class="line">    <span class="built_in">SegmentNode</span>(<span class="type">const</span> SegmentNode&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SegmentNode&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SegmentNode&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SegmentNode</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span> left;</span><br><span class="line">        <span class="keyword">delete</span> right;</span><br><span class="line">        left = right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Range-Sum-Query-Immutable&quot;&gt;&lt;a href=&quot;#Range-Sum-Query-Immutable&quot; class=&quot;headerlink&quot; title=&quot;Range Sum Query Immutable&quot;&gt;&lt;/a&gt;Range Sum Query Immutable&lt;/h2&gt;&lt;p&gt;Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.&lt;/p&gt;
&lt;p&gt;Example:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Given nums = [-2, 0, 3, -5, 2, -1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sumRange(0, 2) -&amp;gt; 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sumRange(2, 5) -&amp;gt; -1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sumRange(0, 5) -&amp;gt; -3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Note:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;You may assume that the array does not change.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;There are many calls to sumRange &lt;span class=&quot;keyword&quot;&gt;function&lt;/span&gt;.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>Find K-th Smallest Pair Distance</title>
    <link href="https://bapuqln.github.io/2020/07/04/FindKtheSmallestPairDistance/"/>
    <id>https://bapuqln.github.io/2020/07/04/FindKtheSmallestPairDistance/</id>
    <published>2020-07-04T08:07:08.000Z</published>
    <updated>2025-01-15T07:01:21.139Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/">Find K-th Smallest Pair Distance</a><br>Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">nums = [1,3,1]</span><br><span class="line">k = 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">Here are all the pairs:</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">Then the 1st smallest distance pair is (1,1), and its distance is 0.</span><br><span class="line">Note:</span><br><span class="line">2 &lt;= len(nums) &lt;= 10000.</span><br><span class="line">0 &lt;= nums[i] &lt; 1000000.</span><br><span class="line">1 &lt;= k &lt;= len(nums) * (len(nums) - 1) / 2.</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul><li>给定数组，让在所有的距离对中求第 k 个最小的距离，然后给出距离对的定义是 (a,b) —&gt; a 和 b 的差值</li></ul><h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><ul><li><code>&#123;1,3,1&#125;</code> 数组，可能有的距离对的个数为 n * (n - 1) / 2</li><li>所有的距离对为：(1, 3) (1, 1) (3, 1) 他们的距离值为: 2, 0 ,2</li><li>因此排在第 1 位的最小的距离对为 (1,1) 结果为 0</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>首先想到的就是暴力解法，我们得知道所有可能的距离对，然后计算每个对的差值，求第 k 个。</li><li>转念一想，其实没必要把距离对求出来，只要求出所有可能的差值就行。</li><li>但差值可能有好几个，模式点像桶排序，O(n)时间就可完成排序，那么就得知道需要多少个桶。</li><li>所以对输入数据进行排序后，最大的值，就知道了，也就知道桶的个数了。</li><li>每个桶里放差值的个数即可，就能知道排在第几位的桶有多少个，也就能回答问题</li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">smallestDistancePair</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">back</span>();</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">freq</span><span class="params">(n<span class="number">+1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">+1</span>; j &lt; m; j++)</span><br><span class="line">                <span class="built_in">freq</span>(nums[j]-nums[i])++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            k -= freq[i];</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p> \(\mathcal{O(n^2)}\)</p><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>因此空间复杂度也为 \(\mathcal{O(max(n))}\)</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ul><li>提交后通过了，但是所有的性能指标是在最后的最后，还是优化一下符合要求</li><li>桶排序的内存要求比较高，另外，在求所有元素对的地方耗费太多时间，那个地方也是优化点。</li><li>这道题目的步骤大概可以分为两个，首先的知道距离对的内容，然后就是找 k 个满足条件的距离对</li><li>距离对的内容，可以使用 dp 来解决，那么 dp 的状态转换方程应该怎么写呢？</li></ul><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><ul><li>由于题目让求排在第 k 位的最小的距离对。之前的 lower_bound 是查找≥某个数的第一个位置， upper_bound 是求＞某个数的第一个位置。因此这道题应该是让查：差值，这个差值还得满足至少有 k 个差值是小于等于它的。</li><li>因此如果要使用折半查找的数据内容是表示 以上内容的，就可以方便的使用折半查找了。</li><li>假定内容是升序排列，假定 <code>d_ij</code> 表示 对于<code>(i,j)</code> 距离对且 <code>i &lt; j</code>，那么 <code>d_id = nums[j] - nums[i]</code></li><li>如果 i 位置不变的话，<code>d_ij &lt;= num</code> 就等价于 <code>nums[j] &lt;= nums[i] + num</code></li><li>那么也就是说要去找最小的 <code>j</code> 保证 <code>nums[j] &gt; nums[i] + num</code></li><li>计数也可以使用双指针，在线性时间下完成<blockquote><ul><li>假定两个起点 l1 &lt; l2，满足 nums[j1] &gt; nums[i1] + num 和 nums[j2] &gt; nums[i2] + num —-&gt; j2 &gt; j1</li></ul></blockquote></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/find-k-th-smallest-pair-distance/&quot;&gt;Find K-th Smallest Pair Distance&lt;/a&gt;&lt;br&gt;Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Example 1:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Input:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;nums = [1,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;k = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Here are all the pairs:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(1,3) -&amp;gt; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(1,1) -&amp;gt; 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;(3,1) -&amp;gt; 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Then the 1st smallest distance pair is (1,1), and its distance is 0.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Note:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 &amp;lt;= len(nums) &amp;lt;= 10000.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;0 &amp;lt;= nums[i] &amp;lt; 1000000.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;= k &amp;lt;= len(nums) * (len(nums) - 1) / 2.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Hard" scheme="https://bapuqln.github.io/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList</title>
    <link href="https://bapuqln.github.io/2020/06/30/LinkedList/"/>
    <id>https://bapuqln.github.io/2020/06/30/LinkedList/</id>
    <published>2020-06-30T12:01:13.000Z</published>
    <updated>2025-01-15T07:01:21.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="链表总结"><a href="#链表总结" class="headerlink" title="链表总结"></a>链表总结</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> v) : <span class="built_in">value</span>(v), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h3><h4 id="给定链表，删除所有重复元素，使得每一个元素只出现一次"><a href="#给定链表，删除所有重复元素，使得每一个元素只出现一次" class="headerlink" title="给定链表，删除所有重复元素，使得每一个元素只出现一次"></a>给定链表，删除所有重复元素，使得每一个元素只出现一次</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *pre = &amp;dummy, pre-&gt;next = root;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root &amp;&amp; root-&gt;value == pre-&gt;next-&gt;value)</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            pre-&gt;next-&gt;next = root;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;value == cur-&gt;next-&gt;value)</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="给定链表，删除所有的重复元素"><a href="#给定链表，删除所有的重复元素" class="headerlink" title="给定链表，删除所有的重复元素"></a>给定链表，删除所有的重复元素</h4><ul><li>树是递归定义的，因此可以用递归求解</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next &amp;&amp; head-&gt;value == head-&gt;next-&gt;value) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head &amp;&amp; head-&gt;next &amp;&amp; head-&gt;value == head-&gt;next-&gt;value) &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">deleteDuplicates</span>(head-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = <span class="built_in">deleteDuplicates</span>(head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="翻转链表"><a href="#翻转链表" class="headerlink" title="翻转链表"></a>翻转链表</h4><ul><li><p>非递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *next = head-&gt;next;</span><br><span class="line">            head-&gt;next = cur;</span><br><span class="line">            cur = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>递归</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *node = <span class="built_in">reverseList</span>(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="Merge-Two-Lists"><a href="#Merge-Two-Lists" class="headerlink" title="Merge Two Lists"></a>Merge Two Lists</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoList</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            cur = l1;</span><br><span class="line">            cur-&gt;next = <span class="built_in">mergeTwoLists</span>(cur-&gt;next, l2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = l2;</span><br><span class="line">            cur-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, cur-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;链表总结&quot;&gt;&lt;a href=&quot;#链表总结&quot; class=&quot;headerlink&quot; title=&quot;链表总结&quot;&gt;&lt;/a&gt;链表总结&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;ListNode&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ListNode* next;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;ListNode&lt;/span&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; v) : &lt;span class=&quot;built_in&quot;&gt;value&lt;/span&gt;(v), &lt;span class=&quot;built_in&quot;&gt;next&lt;/span&gt;(&lt;span class=&quot;literal&quot;&gt;nullptr&lt;/span&gt;) &amp;#123; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://bapuqln.github.io/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>BinaryTree</title>
    <link href="https://bapuqln.github.io/2020/06/29/BinaryTree/"/>
    <id>https://bapuqln.github.io/2020/06/29/BinaryTree/</id>
    <published>2020-06-29T13:01:00.000Z</published>
    <updated>2025-01-15T07:01:21.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="二叉树总结"><a href="#二叉树总结" class="headerlink" title="二叉树总结"></a>二叉树总结</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    <span class="function">TreeNode *right</span></span><br><span class="line"><span class="function">    <span class="title">TreeNode</span><span class="params">(<span class="type">int</span> v)</span>: value(v),left(nullptr), right(nullptr) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><ul><li>递归</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">preOrderTraversal</span>(TreeNode* tree) &#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        function&lt;<span class="type">void</span>(TreeNode *)&gt; preOrderTraversalHelper = [&amp;](TreeNode *node)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            <span class="built_in">preOrderTraversalHelper</span>(node-&gt;left);</span><br><span class="line">            <span class="built_in">preOrderTraversalHelper</span>(node-&gt;right)</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">preOrderTraversalHelper</span>(tree);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>非递归</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">preOrderTraversal</span>(TreeNode *node)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk_;</span><br><span class="line">        stk_.<span class="built_in">push</span>(node);</span><br><span class="line">        <span class="keyword">while</span> (!stk_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *root = stk_.<span class="built_in">top</span>();</span><br><span class="line">            stk_.<span class="built_in">pop</span>();</span><br><span class="line">            ans.(root-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">                stk_.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">                stk_.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;push_back</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        TreeNode* cur = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                cur = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span> (cur-&gt;left &amp;&amp; cur-&gt;left != root) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left == root) &#123;</span><br><span class="line">                    cur-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                    cur-&gt;left = root;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul><li>递归</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inOrderTraversal</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        function&lt;<span class="type">void</span>(TreeNode *)&gt; inOrderTraversalHelper = [&amp;](TreeNode * root)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">inOrderTraversalHelper</span>(root-&gt;left)</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            <span class="built_in">inOrderTraversalHelper</span>(root-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">inOrderTraversalHelper</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>非递归</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;<span class="built_in">inOrderTraversal</span>(TreeNode *root)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk_;</span><br><span class="line">        <span class="keyword">while</span> (root || !stk_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                stk_.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk_.<span class="built_in">top</span>(); stk_.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root-&gt;value);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><ul><li>递归</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        function&lt;<span class="type">void</span>(TreeNode *)&gt;postOrderTraversalHelper = [&amp;](TreeNode *root)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">            <span class="built_in">postOrderTraversal</span>(root-&gt;left);</span><br><span class="line">            <span class="built_in">postOrderTraversal</span>(root-&gt;right);</span><br><span class="line">            ans.<span class="built_in">push_back</span>(root);</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">postOrderTraversal</span>(node);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>非递归<blockquote><p>two stack</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk_, _stk;</span><br><span class="line">        stk_.<span class="built_in">push</span>(root);</span><br><span class="line">        TreeNode *node = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            node = stk_.<span class="built_in">top</span>();stk_.<span class="built_in">pop</span>();</span><br><span class="line">            _stk.<span class="built_in">push</span>(node);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                stk_.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                stk_.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(_stk.<span class="built_in">top</span>());</span><br><span class="line">            _stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote></li></ul><blockquote><p>one stack, 需要记录上一个输出的节点的指针，<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        stack&lt;TreeNode *&gt;stk_;</span><br><span class="line">        TreeNode *last = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root || !stk_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root) &#123;</span><br><span class="line">                stk_.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode *node = stk_.<span class="built_in">top</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right &amp;&amp; last != node-&gt;right) &#123;</span><br><span class="line">                    root = node-&gt;right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(node-&gt;value);</span><br><span class="line">                    last = node;</span><br><span class="line">                    stk_.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>Morris Traversal O(n) time O(1) space</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nodes;</span><br><span class="line">        TreeNode* dummy = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummy -&gt; left = root;</span><br><span class="line">        TreeNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; left) &#123;</span><br><span class="line">                TreeNode* pre = cur -&gt; left;</span><br><span class="line">                <span class="keyword">while</span> (pre -&gt; right &amp;&amp; (pre -&gt; right != cur)) &#123;</span><br><span class="line">                    pre = pre -&gt; right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!(pre -&gt; right)) &#123;</span><br><span class="line">                    pre -&gt; right = cur;</span><br><span class="line">                    cur = cur -&gt; left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">reverseAddNodes</span>(cur -&gt; left, pre, nodes);</span><br><span class="line">                    pre -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">                    cur = cur -&gt; right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur -&gt; right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseNodes</span><span class="params">(TreeNode* start, TreeNode* end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* x = start;</span><br><span class="line">        TreeNode* y = start -&gt; right;</span><br><span class="line">        TreeNode* z;</span><br><span class="line">        <span class="keyword">while</span> (x != end) &#123;</span><br><span class="line">            z = y -&gt; right;</span><br><span class="line">            y -&gt; right = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseAddNodes</span><span class="params">(TreeNode* start, TreeNode* end, vector&lt;<span class="type">int</span>&gt;&amp; nodes)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverseNodes</span>(start, end);</span><br><span class="line">        TreeNode* node = end;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            nodes.<span class="built_in">push_back</span>(node -&gt; val);</span><br><span class="line">            <span class="keyword">if</span> (node == start) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverseNodes</span>(end, start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;二叉树总结&quot;&gt;&lt;a href=&quot;#二叉树总结&quot; class=&quot;headerlink&quot; title=&quot;二叉树总结&quot;&gt;&lt;/a&gt;二叉树总结&lt;/h2&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;TreeNode&lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; value;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode *left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;TreeNode *right&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;    &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;type&quot;&gt;int&lt;/span&gt; v)&lt;/span&gt;: value(v),left(nullptr), right(nullptr) &amp;#123;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://bapuqln.github.io/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>Find the Duplicated Number</title>
    <link href="https://bapuqln.github.io/2020/06/27/FindTheDuplicatedNumber/"/>
    <id>https://bapuqln.github.io/2020/06/27/FindTheDuplicatedNumber/</id>
    <published>2020-06-27T14:45:53.000Z</published>
    <updated>2025-01-15T07:01:21.139Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="http://bookshadow.com/weblog/2015/09/28/leetcode-find-duplicate-number/">Find the Duplicated Number</a><br>Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p><p>Example 1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><p>Example 2:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><br>Note:</p><p>You must not modify the array (assume the array is read only).<br>You must use only constant, O(1) extra space.<br>Your runtime complexity should be less than O(n2).<br>There is only one duplicate number in the array, but it could be repeated more than once.</p><span id="more"></span><h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul><li>给定一个大小为 <code>n+1</code> 的数组，其中每一个数字都是在 <code>1--N</code> 的区间内, 证明至少有一个重复数字是存在的，假定只有唯一的一个重复数字，找到他</li><li>不能修改数组, 排序也就不能用了。</li><li>常量空间</li><li>运行时间要比 N^2要小，那就只剩下 O(n) O(nlogn) O(logn) 的算法可用。</li></ul><h3 id="理解例子"><a href="#理解例子" class="headerlink" title="理解例子"></a>理解例子</h3><ul><li><code>2 -&gt; 4 -&gt; 3</code> = <code>342</code></li><li><code>5 -&gt; 6 -&gt; 4</code> = <code>465</code></li><li><code>342 + 465 = 807</code></li><li>答案 : <code>7 -&gt; 0 -&gt; 8</code></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>证明至少存在一个重复数字，如果元素是<code>[1,n]</code> 那么就存在 <code>n</code> 个不同的数字，分别将每一个位置都占据了，当数字个数为 <code>n+1</code> 时，那么最少有一个数字是重复的</li><li>由于数组的 <code>n+1</code> 个元素的取值范围为 <code>1..n</code>，假定映射关系为 <code>f</code>，那么就存在一个函数 <code>f(i) --&gt;</code> 可以取到 <code>nums[i]</code>，重复的情况就是说存在另一个数字 <code>j</code>，在<code>i != j</code>的前提下，存在 <code>f(i) == f(j)</code>， 那么剩下的问题就是如何将 <code>f</code> 表示出来</li><li>就是说使用函数 f。遍历整个数组，总会存在一个位置导致没有办法结束，走入无限循环，也就是类似链表存在环。</li><li>证明过程：<a href="http://bookshadow.com/weblog/2015/09/28/leetcode-find-duplicate-number/">证明过程</a></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findDubplicated</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> find = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            find = nums[find];</span><br><span class="line">            <span class="keyword">if</span> (slow == find)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;http://bookshadow.com/weblog/2015/09/28/leetcode-find-duplicate-number/&quot;&gt;Find the Duplicated Number&lt;/a&gt;&lt;br&gt;Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [1,3,4,2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example 2:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [3,1,3,4,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;Note:&lt;/p&gt;
&lt;p&gt;You must not modify the array (assume the array is read only).&lt;br&gt;You must use only constant, O(1) extra space.&lt;br&gt;Your runtime complexity should be less than O(n2).&lt;br&gt;There is only one duplicate number in the array, but it could be repeated more than once.&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://bapuqln.github.io/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>Basic Calculator</title>
    <link href="https://bapuqln.github.io/2020/06/12/BasicCalculator/"/>
    <id>https://bapuqln.github.io/2020/06/12/BasicCalculator/</id>
    <published>2020-06-12T14:12:23.000Z</published>
    <updated>2025-01-15T07:01:21.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/basic-calculator/">Basic Calculator</a><br>Implement a basic calculator to evaluate a simple expression string.</p><p>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p><p>Example 1:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">&quot;1 + 1&quot;</span></span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p><p>Example 2:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">&quot; 2-1 + 2 &quot;</span></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p><p>Example 3:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="string">&quot;(1+(4+5+2)-3)+(6+8)&quot;</span></span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></p><p>Note:<br>You may assume that the given expression is always valid.<br>Do not use the eval built-in library function.</p><span id="more"></span><h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>看到这种模式肯定要用到栈 <code>stack</code></li><li>会有括号的处理，这块可能会复杂点，因为有可能会导致计算优先级改变。</li><li>说白了就是将整个过程看为求和，每个数分配一个操作符，用来求和</li><li>分析例子可以知道<blockquote><ul><li>每一个数字都会消耗掉一个符号(+、-)</li><li>每一个数字都会产生一个新的符号(+, -)</li><li>每一个 <code>(</code> 都会复制当前的符号，这样的话他就能给该操作范围内的第一个数用，</li><li>每一个 <code>)</code> 都会关闭当前的操作范围，因此会丢弃掉当前的符号</li></ul></blockquote></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2 sign</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sign</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">length</span>();i++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; <span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">                    n = n * <span class="number">10</span> + (s[i++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                ans += sign.<span class="built_in">back</span>() * n;</span><br><span class="line">                sign.<span class="built_in">pop_back</span>();</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                sign.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sign.<span class="built_in">push_back</span>(sign.<span class="built_in">back</span>() * (c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> remaining   sign stack      total</span><br><span class="line"><span class="number">3</span>-(<span class="number">2</span>+(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">1</span>]            <span class="number">0</span></span><br><span class="line"> -(<span class="number">2</span>+(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>]               <span class="number">3</span></span><br><span class="line">  (<span class="number">2</span>+(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>]           <span class="number">3</span></span><br><span class="line">   <span class="number">2</span>+(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>]       <span class="number">3</span></span><br><span class="line">    +(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>]           <span class="number">1</span></span><br><span class="line">     (<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>]       <span class="number">1</span></span><br><span class="line">      <span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]   <span class="number">1</span></span><br><span class="line">       <span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>]      <span class="number">-8</span></span><br><span class="line">        <span class="number">4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>]   <span class="number">-8</span></span><br><span class="line">         ))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>]      <span class="number">-4</span></span><br><span class="line">          )   [<span class="number">1</span>, <span class="number">-1</span>]          <span class="number">-4</span></span><br><span class="line">              [<span class="number">1</span>]              <span class="number">-4</span></span><br></pre></td></tr></table></figure><h2 id="另一种解法"><a href="#另一种解法" class="headerlink" title="另一种解法"></a>另一种解法</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><ul><li>括号内优先计算</li><li>碰到 <code>(</code> ,将计算结果和操作符入栈</li><li>碰到数字就带着符号计算结果。</li></ul><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> l = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> sign = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk_;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="type">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                <span class="type">int</span> d = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span> (i<span class="number">+1</span> &lt; l &amp;&amp; <span class="built_in">isdigit</span>(s[i<span class="number">+1</span>])) &#123;</span><br><span class="line">                    d = d * <span class="number">10</span> + (s[++i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ans += d * sign;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stk_.<span class="built_in">push</span>(ans);</span><br><span class="line">                stk_.<span class="built_in">push</span>(sign);</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                ans *= stk_.<span class="built_in">top</span>(); stk_.<span class="built_in">pop</span>();</span><br><span class="line">                ans += stk_.<span class="built_in">top</span>(); stk_.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/basic-calculator/&quot;&gt;Basic Calculator&lt;/a&gt;&lt;br&gt;Implement a basic calculator to evaluate a simple expression string.&lt;/p&gt;
&lt;p&gt;The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &lt;span class=&quot;string&quot;&gt;&amp;quot;1 + 1&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Example 2:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &lt;span class=&quot;string&quot;&gt;&amp;quot; 2-1 + 2 &amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Example 3:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: &lt;span class=&quot;string&quot;&gt;&amp;quot;(1+(4+5+2)-3)+(6+8)&amp;quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 23&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may assume that the given expression is always valid.&lt;br&gt;Do not use the eval built-in library function.&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Hard" scheme="https://bapuqln.github.io/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>Best Time To Buy Sell Stock IV</title>
    <link href="https://bapuqln.github.io/2020/06/07/BestTimeToBuyAndSellStockIV/"/>
    <id>https://bapuqln.github.io/2020/06/07/BestTimeToBuyAndSellStockIV/</id>
    <published>2020-06-07T02:43:11.000Z</published>
    <updated>2025-01-15T07:01:21.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">Best Time to Buy and Sell Stock IV</a><br>Say you have an array for which the i-th element is the price of a given stock on day i.</p><p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p><p>Note:<br>You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p><p>Example 1:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,4,1], k = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</span><br></pre></td></tr></table></figure><br>Example 2:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,6,5,0,3], k = 2</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.</span><br><span class="line">             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>获取收益肯定应该在地点买入，高点卖出，假定 <code>vally</code> 表示低价格的索引，<code>peak</code> 表示高价格的索引，因此 <code>(v1, p1)</code> 和 <code>(v2, p2)</code> 表示两个连续的 <code>valley-peak</code> 的价格。考虑如下两个 case<br>*<code>prices[v1] &lt;= prices[v2] &amp;&amp; prices[p1] &lt;= prices[p2]</code>，在该条件下，如果只能交易一次，那就是<code>(v1, p2)</code>。 如果是两个交易，那就是<code>(v1, p1)</code> 和 <code>(v2, p2)</code>。为了省事，将<code>(v1, p2)</code>看做为第一个交易，<code>(v2, p1)</code> 看做第二个交易.</li><li><code>prices[v1] &gt;= prices[v2] || prices[p1] &gt;= prices[p2]</code>，在该条件下，如果只能交易一次，要么就用<code>(v1,p1)</code>，要么就用 <code>(v2,p2)</code>。如果是两次交易，就全部使用。</li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ul><li>找到全部的交易，并且记录每一笔的收益，使用 <code>stack</code> 记录每一对 <code>vally-peak</code> 。并且保证 <code>vally</code> 是按照升序排列。所有的收益都放在 <code>vector</code> 数组中，时间复杂度为 <code>O(n)</code>.</li><li>找到前 <code>k</code> 个交易收益，时间复杂度为 <code>O(n)</code></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = prices.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; profits;</span><br><span class="line">        stack&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt; vps; <span class="comment">// vally-peak pairs</span></span><br><span class="line">        <span class="type">int</span> v = <span class="number">0</span>, p = <span class="number">-1</span>; <span class="comment">// padding p , so not using p-1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// find next vally and peak</span></span><br><span class="line">            <span class="keyword">for</span> (v = p<span class="number">+1</span>; v<span class="number">+1</span> &lt; m &amp;&amp; (prices[v] &gt;= prices[v<span class="number">+1</span>]); v++);</span><br><span class="line">            <span class="keyword">for</span> (p = v;   p<span class="number">+1</span> &lt; m &amp;&amp; (prices[p] &gt;= prices[p<span class="number">-1</span>]); p++);</span><br><span class="line">            <span class="keyword">if</span> (v == p) <span class="keyword">break</span>; <span class="comment">// to the end of prices</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// v &lt; p</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// (v1,p1) (v2,p2)</span></span><br><span class="line">            <span class="comment">// if (prices[v1] &gt;= prices[v2]) no need to combine two transactions</span></span><br><span class="line">            <span class="comment">// after å top is (v1,p2), push p2-v1 into profit --&gt; step ∑</span></span><br><span class="line">            <span class="keyword">while</span> (!vps.<span class="built_in">empty</span>() &amp;&amp; (prices[v] &lt;= prics[vps.<span class="built_in">top</span>().first])) &#123;</span><br><span class="line">                profits.<span class="built_in">push_back</span>(prices[vps.<span class="built_in">top</span>().second] - prices[vps.<span class="built_in">top</span>().first]);</span><br><span class="line">                vps.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// (v1, p1) (v2,p2)</span></span><br><span class="line">            <span class="comment">// if (prices[v1] &lt; prices[v2] &amp;&amp; prices[p1] &lt; prices[p2]) we need to combine two transactions</span></span><br><span class="line">            <span class="comment">// update (v1,p1) --&gt; (v1, p2)</span></span><br><span class="line">            <span class="comment">// p2-v2 + p1-v1 == p2-v1 + p1-v2</span></span><br><span class="line">            <span class="comment">// after step ∑ top is (v1, p2)</span></span><br><span class="line">            <span class="keyword">while</span> (!vps.<span class="built_in">empty</span>() &amp;&amp; (prices[p] &gt;= prices[vps.<span class="built_in">top</span>().second])) &#123;</span><br><span class="line">                <span class="comment">// save profit (v2, p1)</span></span><br><span class="line">                profits.<span class="built_in">push_back</span>(prices[vps.<span class="built_in">top</span>().second] - prices[v]);</span><br><span class="line">                <span class="comment">// v1 --&gt; v</span></span><br><span class="line">                v = vps.<span class="built_in">top</span>()first;</span><br><span class="line">                vps.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="comment">// v is v1</span></span><br><span class="line">                <span class="comment">// p is p2</span></span><br><span class="line">                <span class="comment">// step å</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if step å  (v1, p2) is top of vps</span></span><br><span class="line">            vps.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(v, p));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate all the profits</span></span><br><span class="line">    <span class="keyword">while</span> (!vps.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        profits.<span class="built_in">push_back</span>(prices[vps.<span class="built_in">top</span>().second] - prices[vps.<span class="built_in">top</span>().first]);</span><br><span class="line">        vps.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate k highest profitœ</span></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> n = profits.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; = k) &#123;</span><br><span class="line">        <span class="built_in">accumulate</span>(profits.<span class="built_in">begin</span>(), profits.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">nth_element</span>(profits.<span class="built_in">begin</span>(), profits.<span class="built_in">end</span>() - k, profits.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">accumulate</span>(profits.<span class="built_in">end</span>() - k,profit.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/&quot;&gt;Best Time to Buy and Sell Stock IV&lt;/a&gt;&lt;br&gt;Say you have an array for which the i-th element is the price of a given stock on day i.&lt;/p&gt;
&lt;p&gt;Design an algorithm to find the maximum profit. You may complete at most k transactions.&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [2,4,1], k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;Example 2:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [3,2,6,5,0,3], k = 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Hard" scheme="https://bapuqln.github.io/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>DynamicProgramming</title>
    <link href="https://bapuqln.github.io/2020/06/04/DynamicProgramming/"/>
    <id>https://bapuqln.github.io/2020/06/04/DynamicProgramming/</id>
    <published>2020-06-04T15:57:23.000Z</published>
    <updated>2025-01-15T07:01:21.139Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="动态规划套路"><a href="#动态规划套路" class="headerlink" title="动态规划套路"></a>动态规划套路</h2><h4 id="有一个-m-n-大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法"><a href="#有一个-m-n-大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法" class="headerlink" title="有一个 m*n 大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法"></a>有一个 m*n 大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法</h4><h5 id="暴力解法"><a href="#暴力解法" class="headerlink" title="暴力解法"></a>暴力解法</h5><ul><li>从<code>(1,1)-&gt;(m,n)</code>的不同路径中有大量的重复，比如<code>(1,1)-&gt;(i,j)</code>有 <code>k</code> 条不同的路径，那么对于任何一条固定的路线<code>(i,j)-&gt;(m,n)</code>的路径，都需要走 <code>k</code> 遍来模拟。</li><li>不关心具体的走法，只关心状态，也就是走法的数量</li><li>同理，如果知道<code>(i,j)-&gt;(m,n)</code>有 <code>k</code> 条不同的路径，那么<code>(1,1)-&gt;(i,j)-&gt;(m,n)</code>的不同路径总数是<code>k*s</code><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5></li><li>令<code>(i,j)</code>表示从<code>(1,1)-&gt;(i,j)</code>的不同路径数量，<code>f(i,j) = f(i-1,j) + f(i,j-1)</code></li><li>如果要求出 <code>f(i,j)</code> 只需要上一个结果即可， 也就是求解<code>f(i,j)</code> 需要求出子问题<code>f(i&#39;,j&#39;)</code><h5 id="动态规划适用前提"><a href="#动态规划适用前提" class="headerlink" title="动态规划适用前提"></a>动态规划适用前提</h5><h6 id="无后效性"><a href="#无后效性" class="headerlink" title="无后效性"></a>无后效性</h6></li><li>一旦确定<code>f(i,j)</code>，就不用关心如何计算出<code>f(i,j)</code></li><li>想要确定<code>f(i,j)</code>，只要知道<code>f(i-1,j)</code>和<code>f(i,j-1)</code><h6 id="最优子结构"><a href="#最优子结构" class="headerlink" title="最优子结构"></a>最优子结构</h6></li><li><code>f(i,j)</code>的定义已经蕴含最优</li><li>大问题的最优解可以由若干小问题的最优解推出<code>(min, max, sum)</code><blockquote><p>DP 适用的问题：可以将大问题拆成几个小问题，且无后效性，具有最优子结构的性质</p><h6 id="记忆化递归"><a href="#记忆化递归" class="headerlink" title="记忆化递归"></a>记忆化递归</h6></blockquote></li><li>可以使用递归求解</li><li>有重复子问题，overlaping subproblem</li></ul><span id="more"></span><h2 id="套路一：基本类型（时间序列）"><a href="#套路一：基本类型（时间序列）" class="headerlink" title="套路一：基本类型（时间序列）"></a>套路一：基本类型（时间序列）</h2><h3 id="House-Robber"><a href="#House-Robber" class="headerlink" title="House Robber"></a>House Robber</h3><ul><li>给一排房子，相邻的房子不能抢，问最多能抢的价值</li><li>房子只有抢和不抢两个状态</li><li>和时间相关的为第 <code>i</code> 轮</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0 --&gt; max profit of not rob the i-th house</span></span><br><span class="line">        <span class="comment">// 1 --&gt; max profit of robbing the i-th house</span></span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>));</span><br><span class="line">        <span class="comment">// if not rob 0 max profit is 0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// if rob 0, max profit is nums[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="comment">// if not rob the i-th roby, so the max profit will be the max value of rob/non-rob on last house</span></span><br><span class="line">            <span class="comment">// because if rob on a low price house will not be a good choice</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// if decide to rob i-th , i-1-th must not be robbed</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">0</span>], dp[nums.<span class="built_in">size</span>() - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="House-Robber-II"><a href="#House-Robber-II" class="headerlink" title="House Robber II"></a>House Robber II</h3><ul><li>给一圈“首尾相连”的房子，相邻的房子不能抢，问最多能抢的价值</li><li>假定有 n 个房子，因为 0 和 n-1 为相邻的房子。因此可抢的范围为 <code>0 -&gt; n-2</code> 或者 <code>1 -&gt; n-1</code></li><li>因此结果就是两个中最大值。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; houses)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> m = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">2</span>) <span class="keyword">return</span> m ? nums[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>,<span class="type">int</span>)&gt; robHelper = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r)&#123;</span><br><span class="line">            vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m<span class="number">+1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">            dp[l][<span class="number">1</span>] = nums[l];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">max</span>(dp[r][<span class="number">0</span>], dp[r][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">robHelper</span>(<span class="number">1</span>, m<span class="number">-1</span>), <span class="built_in">robHelper</span>(<span class="number">0</span>, m<span class="number">-2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Best-Time-to-Buy-and-Sell-Stock-III"><a href="#Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="Best Time to Buy and Sell Stock III"></a>Best Time to Buy and Sell Stock III</h3><ul><li>给定一系列每日股票的价格，每日只能买入、卖出、不操作。最多交易两次，问最大的收益<br><img src="/images/best_time_to_buy_sell_stock.png" alt="BestTimeToBuySellStock.PNG"></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 表示这一轮我已经持有第一股的最大收益</span></span><br><span class="line"><span class="comment">    1 表示这一轮我已经售出第一股的最大收益</span></span><br><span class="line"><span class="comment">    2 表示这一轮我已经持有第二股的最大收益</span></span><br><span class="line"><span class="comment">    3 表示这一轮我已经售出第二股的最大收益</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>], -val[i]);</span><br><span class="line">      dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + val[i]);</span><br><span class="line">      dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] - val[i]);</span><br><span class="line">      dp[i][<span class="number">3</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">3</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>] + val[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  ans = max&#123;dp[n][i]&#125; (i = <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="Best-Time-to-buy-and-Sell-Stock-with-cooldown"><a href="#Best-Time-to-buy-and-Sell-Stock-with-cooldown" class="headerlink" title="Best Time to buy and Sell Stock with cooldown"></a>Best Time to buy and Sell Stock with cooldown</h3><ul><li>给定一系列股票的加个，每日只能买入、卖出、不操作。买入后要隔卖出，无总交易限制，问最大收益<br><img src="/images/best_time_to_buy_sell_stock_cool_down.png" alt="BestTimeToBuySellStockCoolDown.PNG"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 表示本轮刚持有股票的最大收益</span></span><br><span class="line"><span class="comment">    1 表示本轮持有一天以上的最大收益</span></span><br><span class="line"><span class="comment">    2 表示我已清空股票的最大收益</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">2</span>] - val[i];</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">    dp[i][<span class="number">2</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">2</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + val[i]);</span><br><span class="line">&#125;</span><br><span class="line">ans = max&#123;dp[i][n]&#125; (n = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="Wiggle-Subsequence"><a href="#Wiggle-Subsequence" class="headerlink" title="Wiggle Subsequence"></a>Wiggle Subsequence</h3><ul><li>给定一个序列 <code>s</code>， 求其最长的<code>wiggle pattern subsequence (.... &gt;s[i] &lt; s[j] &gt; s[j+1]...)</code><br><img src="/images/wiggle_subsequence.png" alt="wiggleSubsequence.PNG"></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 以当前元素结尾且上升</span></span><br><span class="line"><span class="comment">    1 一当前元素结尾且下降</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">max</span>(dp[N][i]) (i = <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Paint-Fence"><a href="#Paint-Fence" class="headerlink" title="Paint Fence"></a>Paint Fence</h3><ul><li>给出 <code>cost[i]</code> 表示第 <code>i</code> 个房子喷涂第 <code>j</code> 中 漆的价格，相邻的房子不能涂同一种颜色，求喷涂所有房子的最小价格</li></ul><p><img src="/images/paint_fence.png" alt="paintFence.PNG"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    dp[i][j] 表示第 i 间房子喷涂第 j 中颜色的代价</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j], cost[j]) <span class="comment">// j = 1,2,...,k</span></span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">min</span>(dp[N][j]) (j = <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,...,k)</span><br></pre></td></tr></table></figure><blockquote><p><code>To Do or Not To Do</code><br>很多不那么套路的 DP 题目，状态比较难以设计，某些题目会给你“行使某种策略的权利”，想买卖股票的题目，两个状态就分别为“行驶了某种权利”，“没有行使某种权利” 分别对应的价值</p></blockquote><h3 id="Max-Consecutive-One-II"><a href="#Max-Consecutive-One-II" class="headerlink" title="Max Consecutive One II"></a>Max Consecutive One II</h3><ul><li>给定一个数组<code>(0/1)</code>，有最多一次从 <code>0</code> 翻转到 <code>1</code> 的权利，问最多可以有多少连续的 <code>1</code><br><img src="/images/mac_consecutive_ones_ii.png" alt="maxConsecutive.PNG"></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 表示以当前元素结尾且没有行使翻转权利的最长连续 1</span></span><br><span class="line"><span class="comment">    1 表示以当前元素结尾且已经行驶翻转权利的最长连续 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[i], nums[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(dp[i][j]) (<span class="keyword">for</span> all possible i,j = <span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="套路二：基本类型-II（时间序列加强版）"><a href="#套路二：基本类型-II（时间序列加强版）" class="headerlink" title="套路二：基本类型 II（时间序列加强版）"></a>套路二：基本类型 II（时间序列加强版）</h2><ul><li>给定一个序列（数组/字符串），其中每个元素可以认为一天，但今天的状态和之前的某一天有关，需要挑选。</li><li>套路</li></ul><blockquote><p>定义 dp[i] 表示第 i 轮的状态，一般这个状态要求和元素 i 直接有关系。<br>千方百计将 dp[i] 与之前的状态 dp[i’] 产生关系比如 sum,max,min,<br>dp[i] 一定不能与大于 i 的轮次有关系，否则违反了 DP 的无后效性。</p><ul><li>最终的结果是 dp[i] 中的某一个<br><img src="/images/pattern_ii.png" alt="patternII"></li></ul></blockquote><h3 id="Longest-Increasing-Subsequence"><a href="#Longest-Increasing-Subsequence" class="headerlink" title="Longest Increasing Subsequence"></a>Longest Increasing Subsequence</h3><ul><li>给定一个数组 s，求最长的递增子序列的长度</li></ul><blockquote><p>状态定义： 照抄问题，dp[i]—&gt; s[1:i]里面以 s[i]为结尾的、最长的递增子序列的长度。<br>状态转移：寻找最优解的前驱状态 j，将 dp[i] 与 dp[j] 产生联系</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="comment">//i 表示 LIS 的最大元素，搜索该 LIS 的第二大元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[j])</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i], dp[j]<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(dp[i]), <span class="keyword">for</span> i in <span class="number">1</span>,...N</span><br></pre></td></tr></table></figure><h3 id="Largest-Divisible-Subset"><a href="#Largest-Divisible-Subset" class="headerlink" title="Largest Divisible Subset"></a>Largest Divisible Subset</h3><ul><li>给定一个数组 <code>s</code>，求最大子集，使得里面的所有元素之间都可以相互整除。</li></ul><blockquote><p>状态定义：照抄问题，dp[i]—&gt; s[1:i] 以 s[i]为结尾，满足题目要求的最大子集的数目。<br>状态转移：寻找最优的前驱状态 j，将 dp[i] 与 dp[j] 产生联系</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="comment">// i 表示该集合的最大元素，搜索该子集的第二大元素 j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span>)</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i], dp[j]<span class="number">+1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="built_in">max</span>(dp[i]) <span class="keyword">for</span> i in <span class="number">1</span>,...,N</span><br></pre></td></tr></table></figure><h3 id="Filling-Bookcase-Shelves"><a href="#Filling-Bookcase-Shelves" class="headerlink" title="Filling Bookcase Shelves"></a>Filling Bookcase Shelves</h3><ul><li>给定 <code>N</code> 本书（宽高各异）的序列要求按照所给的顺序摆放，相邻的若干本书可以放一层，但同一层的高度不能超过 <code>w</code>。问这个书架最矮可以有多高<br><img src="/images/book_shelf.png" alt="bookShelf"></li><li>将数组 S 分成若干个子数组，最小化“每个数组的最大值之和”，输出该值</li></ul><blockquote><p>状态定义：照抄问题 dp[i]—&gt;将数组S[1,…N] 分成若干个子数组，最小化“每个子数组的最大值之和”，保存该值<br>状态转移：寻找最优的前驱状态 j，将 dp[i] 与 dp[j] 产生联系<br>第 i 本书所在的这一层可能有多高？取决于上一层的最后一本书放在那里</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="comment">// i 表示本层最后一本书，搜索上一层最后一本的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (totalWidth[j<span class="number">+1</span>:i] &lt;= W)</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i], dp[j] + maxHeight[j<span class="number">+1</span>:i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = dp[N];</span><br></pre></td></tr></table></figure><h2 id="套路三：双序列类型"><a href="#套路三：双序列类型" class="headerlink" title="套路三：双序列类型"></a>套路三：双序列类型</h2><ul><li>给出两个序列 <code>s</code> 和 <code>t</code>（数组/字符串），对他们搞事情</li><li>套路</li></ul><blockquote><p>定义 dp[i][j]: 表示针对 s[1:i] 和 t[1:j] 的子问题求解答<br>千方百计将 dp[i][j] 与之前的状态之间转移 dp[i-1][j], dp[i][j-1] , dp[i-1][j-1]<br>最终的结果是 dp[m][n]</p></blockquote><h3 id="Longest-Common-subsequences"><a href="#Longest-Common-subsequences" class="headerlink" title="Longest Common subsequences"></a>Longest Common subsequences</h3><ul><li>求字符串 s 和 t 的 length of LCS</li></ul><blockquote><p>状态定义：照抄问题 dp[i][j]—&gt; s[1:i] t[1:j]的 length of LCS<br>状态转移：外面两大层循环编译 i 和 j，核心从 s[i] 与 t[j] 的关系作为突破口，往 dp[i-1][j], dp[i][j-1], dpp[i-1][j] 转移</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    s:XXXXXi</span></span><br><span class="line"><span class="comment">    t:YYYj</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Shortest-Common-Supersequence"><a href="#Shortest-Common-Supersequence" class="headerlink" title="Shortest Common Supersequence"></a>Shortest Common Supersequence</h3><ul><li>求字符串 <code>s</code> 和 <code>t</code> 的 <code>length of SCS</code></li></ul><blockquote><p>状态定义：照抄问题 dp[i][j]—&gt; s[1:i] 和 t[1:j] 的 length of SCS<br>状态转移：外面两层大循环遍历 i 和 j ：核心从 s[i] 与 t[j] 的关系作为突破口，拼命往 dp[i-1][j], dp[i][j-1], dp[i-1][j-1] 转移<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">min</span>(dp[i<span class="number">-1</span>][j] + <span class="number">1</span>, dp[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="Edit-Distance"><a href="#Edit-Distance" class="headerlink" title="Edit Distance"></a>Edit Distance</h3><ul><li>求字符串 <code>s</code> 和 <code>t</code> 的 <code>min edit distance</code></li></ul><blockquote><p>状态定义：照抄问题 dp[i][j]—&gt; s[1:i] 和 t[1:j] 的 min edit distance<br>状态转移：外面两层大循环遍历 i 和 j ：核心从 s[i] 与 t[j] 的关系作为突破口，拼命往 dp[i-1][j], dp[i][j-1], dp[i-1][j-1] 转移</p></blockquote><h2 id="套路四：第一类区间类型"><a href="#套路四：第一类区间类型" class="headerlink" title="套路四：第一类区间类型"></a>套路四：第一类区间类型</h2><h2 id="套路五：第二类取件类型"><a href="#套路五：第二类取件类型" class="headerlink" title="套路五：第二类取件类型"></a>套路五：第二类取件类型</h2><h2 id="套路六：背包入门"><a href="#套路六：背包入门" class="headerlink" title="套路六：背包入门"></a>套路六：背包入门</h2><h2 id="状态压缩"><a href="#状态压缩" class="headerlink" title="状态压缩"></a>状态压缩</h2>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;动态规划套路&quot;&gt;&lt;a href=&quot;#动态规划套路&quot; class=&quot;headerlink&quot; title=&quot;动态规划套路&quot;&gt;&lt;/a&gt;动态规划套路&lt;/h2&gt;&lt;h4 id=&quot;有一个-m-n-大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法&quot;&gt;&lt;a href=&quot;#有一个-m-n-大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法&quot; class=&quot;headerlink&quot; title=&quot;有一个 m*n 大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法&quot;&gt;&lt;/a&gt;有一个 m*n 大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法&lt;/h4&gt;&lt;h5 id=&quot;暴力解法&quot;&gt;&lt;a href=&quot;#暴力解法&quot; class=&quot;headerlink&quot; title=&quot;暴力解法&quot;&gt;&lt;/a&gt;暴力解法&lt;/h5&gt;&lt;ul&gt;
&lt;li&gt;从&lt;code&gt;(1,1)-&amp;gt;(m,n)&lt;/code&gt;的不同路径中有大量的重复，比如&lt;code&gt;(1,1)-&amp;gt;(i,j)&lt;/code&gt;有 &lt;code&gt;k&lt;/code&gt; 条不同的路径，那么对于任何一条固定的路线&lt;code&gt;(i,j)-&amp;gt;(m,n)&lt;/code&gt;的路径，都需要走 &lt;code&gt;k&lt;/code&gt; 遍来模拟。&lt;/li&gt;
&lt;li&gt;不关心具体的走法，只关心状态，也就是走法的数量&lt;/li&gt;
&lt;li&gt;同理，如果知道&lt;code&gt;(i,j)-&amp;gt;(m,n)&lt;/code&gt;有 &lt;code&gt;k&lt;/code&gt; 条不同的路径，那么&lt;code&gt;(1,1)-&amp;gt;(i,j)-&amp;gt;(m,n)&lt;/code&gt;的不同路径总数是&lt;code&gt;k*s&lt;/code&gt;&lt;h5 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h5&gt;&lt;/li&gt;
&lt;li&gt;令&lt;code&gt;(i,j)&lt;/code&gt;表示从&lt;code&gt;(1,1)-&amp;gt;(i,j)&lt;/code&gt;的不同路径数量，&lt;code&gt;f(i,j) = f(i-1,j) + f(i,j-1)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果要求出 &lt;code&gt;f(i,j)&lt;/code&gt; 只需要上一个结果即可， 也就是求解&lt;code&gt;f(i,j)&lt;/code&gt; 需要求出子问题&lt;code&gt;f(i&amp;#39;,j&amp;#39;)&lt;/code&gt;&lt;h5 id=&quot;动态规划适用前提&quot;&gt;&lt;a href=&quot;#动态规划适用前提&quot; class=&quot;headerlink&quot; title=&quot;动态规划适用前提&quot;&gt;&lt;/a&gt;动态规划适用前提&lt;/h5&gt;&lt;h6 id=&quot;无后效性&quot;&gt;&lt;a href=&quot;#无后效性&quot; class=&quot;headerlink&quot; title=&quot;无后效性&quot;&gt;&lt;/a&gt;无后效性&lt;/h6&gt;&lt;/li&gt;
&lt;li&gt;一旦确定&lt;code&gt;f(i,j)&lt;/code&gt;，就不用关心如何计算出&lt;code&gt;f(i,j)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;想要确定&lt;code&gt;f(i,j)&lt;/code&gt;，只要知道&lt;code&gt;f(i-1,j)&lt;/code&gt;和&lt;code&gt;f(i,j-1)&lt;/code&gt;&lt;h6 id=&quot;最优子结构&quot;&gt;&lt;a href=&quot;#最优子结构&quot; class=&quot;headerlink&quot; title=&quot;最优子结构&quot;&gt;&lt;/a&gt;最优子结构&lt;/h6&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f(i,j)&lt;/code&gt;的定义已经蕴含最优&lt;/li&gt;
&lt;li&gt;大问题的最优解可以由若干小问题的最优解推出&lt;code&gt;(min, max, sum)&lt;/code&gt;&lt;blockquote&gt;
&lt;p&gt;DP 适用的问题：可以将大问题拆成几个小问题，且无后效性，具有最优子结构的性质&lt;/p&gt;
&lt;h6 id=&quot;记忆化递归&quot;&gt;&lt;a href=&quot;#记忆化递归&quot; class=&quot;headerlink&quot; title=&quot;记忆化递归&quot;&gt;&lt;/a&gt;记忆化递归&lt;/h6&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;可以使用递归求解&lt;/li&gt;
&lt;li&gt;有重复子问题，overlaping subproblem&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://bapuqln.github.io/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>Majority Element</title>
    <link href="https://bapuqln.github.io/2020/06/04/MajorityElement/"/>
    <id>https://bapuqln.github.io/2020/06/04/MajorityElement/</id>
    <published>2020-06-04T04:15:28.000Z</published>
    <updated>2025-01-15T07:01:21.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/majority-element/">Majority Element</a><br>Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p><p>You may assume that the array is non-empty and the majority element always exist in the array.</p><p>Example 1:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure><br><span id="more"></span></p><h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>对每一个元素计数，找到大于 n/2 的元素返回即可</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map_;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++map_[num] &gt; numbers.<span class="built_in">size</span>() / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul><li>因为满足需求的个数是至少 n / 2， 因此只需要找到排序后处于一半位置的元素就是答案。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">nth_element</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">begin</span>() + numbers.<span class="built_in">size</span>() / <span class="number">2</span>, numbers.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> numbers[numbers.<span class="built_in">size</span>()/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Divide-and-Conquer"><a href="#Divide-and-Conquer" class="headerlink" title="Divide and Conquer"></a>Divide and Conquer</h3><ul><li>递归的找两部分的 majority，最后合并结果，递归出口就是单个元素</li><li><code>algorithm</code> 中有个 count 函数，类似于 find，主要是使用一对迭代器和一个值作为参数，返回值出现的次数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        function&lt;<span class="type">int</span>(vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span> ,<span class="type">int</span> )&gt; majorityElementHelper = [&amp;](vector&lt;<span class="type">int</span>&gt; element, <span class="type">int</span> l, <span class="type">int</span> r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> element[l];</span><br><span class="line">            <span class="type">int</span> m = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> lm = <span class="built_in">majorityElementHelper</span>(elements, l, m);</span><br><span class="line">            <span class="type">int</span> rm = <span class="built_in">majorityElementHelper</span>(elements, m<span class="number">+1</span>, r);</span><br><span class="line">            <span class="keyword">if</span> (lm == rm) <span class="keyword">return</span> lm;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">count</span>(nums.<span class="built_in">begin</span>() + l, nums.<span class="built_in">begin</span>() + r + <span class="number">1</span>, lm) &gt; <span class="built_in">count</span>(nums.<span class="built_in">begin</span>() + l, nums.<span class="built_in">begin</span>() + r + <span class="number">1</span>, rm) ? lm : rm;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">majorityElementHelper</span>(numbers,<span class="number">0</span>, numbers.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Moore-Voting-Algorithm"><a href="#Moore-Voting-Algorithm" class="headerlink" title="Moore Voting Algorithm"></a>Moore Voting Algorithm</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>, majority;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num:numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!count) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (num == majority) <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;numbers)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> majority = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">0</span>, mask = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++, mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> bits = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &amp; mask) &#123;</span><br><span class="line">                    bits++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bits &gt; numbers.<span class="built_in">size</span>() / <span class="number">2</span>) &#123;</span><br><span class="line">                majority |= mask;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/majority-element/&quot;&gt;Majority Element&lt;/a&gt;&lt;br&gt;Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.&lt;/p&gt;
&lt;p&gt;You may assume that the array is non-empty and the majority element always exist in the array.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [3,2,3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;Example 2:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [2,2,1,1,1,2,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://bapuqln.github.io/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>Single Number II</title>
    <link href="https://bapuqln.github.io/2020/05/30/SingleNumberII/"/>
    <id>https://bapuqln.github.io/2020/05/30/SingleNumberII/</id>
    <published>2020-05-30T14:57:34.000Z</published>
    <updated>2025-01-15T07:01:21.142Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/single-number-ii/">Single Number II</a><br>Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.</p><p>Note:</p><p>Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?</p><p>Example 1:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [2,2,3,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure><p>Example 2:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: [0,1,0,1,0,1,99]</span><br><span class="line">Output: 99</span><br></pre></td></tr></table></figure><br><span id="more"></span></p><h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul><li>给定一个数组，里面的元素均出现了 <code>K(K &gt; 1)</code> 次,出了一个元素出现 P(P&gt;=1 , P % K != 0) 次，让找到这个元素。<br>gi</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ul><li>首先构建一个计数器，可以实现对 01 数组进行计数，每次遇见1 counter 自增，如果自增至 K，则 counter 重至为 0<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counter</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">if</span> i:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> counter == k:</span><br><span class="line">            count = <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li>那么什么位操作遇到 0 不变，遇到 1 自增，也就是资深取反（因为自增碰到 1 会变成 0）</li><li>对于某一位数字 0 或者 1 来讲：</li><li>碰到 0 不变的操作有两个： <code>x = x | 0</code> 另一个是 <code>x = x ^ 0</code></li><li>但异或(<code>XOR</code>)操作明显更加合适: <code>1 ^ 1 = 0</code> , <code>0 ^ 1 = 1</code>, <code>0 ^ 0 = 0</code></li><li>因此对于 <code>counter</code> 来讲， <code>counter = counter ^ 1</code><br>*</li><li>但题目需要覆盖 K 位，那就是  <code>2 ^ m &gt;= K</code>，因此需要 最少 <code>logk</code> 个</li><li>因此 m 位从高到低为<code>C[m], C[m-1],... C[1]</code></li><li>对于最低位 : <code>C[1] = C[1] ^ i</code>;</li><li>对于<code>C[2]</code>，只有前一位为 1 的时候才进位，<code>C[2] = C[2] ^ (C[1] &amp; i)</code></li><li>对于<code>C[k]</code>, 进位条件 <code>i == 1 &amp;&amp; C[j] == 1 for all j &lt; k</code><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> array:</span><br><span class="line">        C[m] ^= (c[m-<span class="number">1</span>] &amp; c[m-<span class="number">2</span>] &amp; .... C[<span class="number">1</span>] &amp; i)</span><br><span class="line">        ...</span><br><span class="line">        C[<span class="number">2</span>] ^= C[<span class="number">1</span>] &amp; i</span><br><span class="line">        C[<span class="number">1</span>] ^= i</span><br><span class="line">        // 要从最高位开始更新</span><br></pre></td></tr></table></figure></li><li>但更新策略还不完整，需要达到阈值的时候变成 0</li><li>因此需要一个 <code>mask = 0 if counter == k else 1</code></li><li>于是每次更新的时候 <code>C[i] &amp; mask</code></li><li>假设 k 的二进制形式为 k[m], k[m-1]…k[1]</li><li>那么 <code>mask =  ~(y1 &amp; y2 ... &amp; ym) where yj = cj if kj = 1 else yj = ~ cj</code></li><li>这样子的话当c == k时，yj全部等于1，mask值为0，而 c != k时，yj必不全为1，则mask值必为1.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i in array:</span><br><span class="line"> c[m] ^= (c[m<span class="number">-1</span>] &amp; c[m<span class="number">-2</span>] &amp; ... &amp; c[<span class="number">1</span>] &amp; i)</span><br><span class="line">   ...</span><br><span class="line">   c[<span class="number">2</span>] ^= (c[<span class="number">1</span>] &amp; i)</span><br><span class="line">   c[<span class="number">1</span>] ^= i  # 注意要先从高位开始更新</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> j in <span class="built_in">range</span>(m):</span><br><span class="line">     y[j] = c[j] <span class="keyword">if</span> k[j] <span class="keyword">else</span> ~c[j]</span><br><span class="line">   mask = ~(y[<span class="number">1</span>] &amp; y[<span class="number">2</span>] ... &amp; y[m])</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> j in <span class="built_in">range</span>(m):</span><br><span class="line">     c[m] &amp;= mask</span><br><span class="line">       ...</span><br><span class="line">       c[<span class="number">1</span>] &amp;= mask</span><br></pre></td></tr></table></figure></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c1 = <span class="number">0</span></span><br><span class="line">c2 = <span class="number">0</span></span><br><span class="line">m = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i in nums:</span><br><span class="line">  c2 ^= c1 &amp; i</span><br><span class="line">    c1 ^= i</span><br><span class="line">    mask = ~(c1 &amp; c2) <span class="meta"># k = 3, 二进制形式为11，则c1和c2都不用取反</span></span><br><span class="line">    c1 &amp;= mask</span><br><span class="line">    c2 &amp;= mask</span><br><span class="line"><span class="keyword">return</span> c1 <span class="meta"># p = 1, 则最后c1 = single</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/single-number-ii/&quot;&gt;Single Number II&lt;/a&gt;&lt;br&gt;Given a non-empty array of integers, every element appears three times except for one, which appears exactly once. Find that single one.&lt;/p&gt;
&lt;p&gt;Note:&lt;/p&gt;
&lt;p&gt;Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?&lt;/p&gt;
&lt;p&gt;Example 1:&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [2,2,3,2]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Example 2:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: [0,1,0,1,0,1,99]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: 99&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://bapuqln.github.io/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>Construct Binary Tree from Preorder and Postorder Traversal</title>
    <link href="https://bapuqln.github.io/2020/05/24/ConstructBinaryTreeFromPreorderAndPostorderTraversal/"/>
    <id>https://bapuqln.github.io/2020/05/24/ConstructBinaryTreeFromPreorderAndPostorderTraversal/</id>
    <published>2020-05-24T12:16:25.000Z</published>
    <updated>2025-01-15T07:01:21.139Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">Construct Binary Tree from Preorder and Postorder Traversal</a><br>Return any binary tree that matches the given preorder and postorder traversals.</p><p>Values in the traversals pre and post are distinct positive integers.</p><p>Example 1:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]</span><br><span class="line">Output: [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure></p><p>Note:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 &lt;= pre.length == post.length &lt;= 30</span><br><span class="line">pre[] and post[] are both permutations of 1, 2, ..., pre.length.</span><br><span class="line">It is guaranteed an answer exists. If there exists multiple answers, you can <span class="built_in">return</span> any of them.</span><br></pre></td></tr></table></figure></p><span id="more"></span><h2 id="解题报告"><a href="#解题报告" class="headerlink" title="解题报告"></a>解题报告</h2><h3 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h3><ul><li>给定两个数组，分别表示先序遍历和后序遍历</li><li>要求根据两个遍历结果构造出原来的二叉树</li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><ul><li>创建一个节点 <code>TreeNode[pre[preIndex]]</code> 作为根节点</li><li>由于后序遍历中根节点是最后访问的，因此构造结束的条件就是：<code>root-&gt;val == post[postIndex]</code></li><li>那么，如果还没有创建完二叉树，我们就递归的对于左子树和右子树调用构造函数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> preIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> postIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">constructFromPrePost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pre, vector&lt;<span class="type">int</span>&gt;&amp; post)</span> </span>&#123;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[preIndex++]);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val != post[postIndex])</span><br><span class="line">            root-&gt;left = <span class="built_in">constructFromPrePost</span>(pre, post);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val != post[postIndex]) &#123;</span><br><span class="line">            root-&gt;right = <span class="built_in">constructFromPrePost</span>(pre, post);</span><br><span class="line">        &#125;</span><br><span class="line">        postIndex++;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="非递归解法"><a href="#非递归解法" class="headerlink" title="非递归解法"></a>非递归解法</h4><ul><li>使用栈，前序生成二叉树，将生成的结果 <code>push</code> 到 <code>stack</code> 中，然后使用后续 <code>pop</code> 出来</li><li><code>stack</code> 保存的是当前的树</li><li><code>node == new TreeNode(pre[i])</code> ，如果没有左子节点，就把它作为左子节点，否则就是右子节点。</li><li>如果在前序遍历和后序遍历碰到了相同的值，那么就说明当前子树构造结束，将其 <code>pop</code> 出来</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode * <span class="title">constructFromPrePost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;pre, vector&lt;<span class="type">int</span>&gt; &amp;post)</span> </span>&#123;</span><br><span class="line">        vector&lt;TreeNode*&gt; stk_;</span><br><span class="line">        stk_.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; pre.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(pre[i]);</span><br><span class="line">            <span class="keyword">while</span> (stk_.<span class="built_in">back</span>()-&gt;val == post[j]) &#123;</span><br><span class="line">                stk_.<span class="built_in">pop_back</span>();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stk_.<span class="built_in">back</span>()-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk_.<span class="built_in">back</span>()-&gt;left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk_.<span class="built_in">back</span>()-&gt;right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            stk_.<span class="built_in">push_back</span>(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk_[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>遍历次数：<code>O(n)</code>，因此是线性时间，每个元素只遍历一次</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><code>O(n)</code> 表示栈的大小</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/&quot;&gt;Construct Binary Tree from Preorder and Postorder Traversal&lt;/a&gt;&lt;br&gt;Return any binary tree that matches the given preorder and postorder traversals.&lt;/p&gt;
&lt;p&gt;Values in the traversals pre and post are distinct positive integers.&lt;/p&gt;
&lt;p&gt;Example 1:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Output: [1,2,3,4,5,6,7]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Note:&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 &amp;lt;= pre.length == post.length &amp;lt;= 30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;pre[] and post[] are both permutations of 1, 2, ..., pre.length.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;It is guaranteed an answer exists. If there exists multiple answers, you can &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; any of them.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://bapuqln.github.io/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>Gray Code Conversion</title>
    <link href="https://bapuqln.github.io/2020/05/22/GrayCode-Conversion/"/>
    <id>https://bapuqln.github.io/2020/05/22/GrayCode-Conversion/</id>
    <published>2020-05-22T03:02:36.000Z</published>
    <updated>2025-01-15T07:01:21.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="来自维基百科"><a href="#来自维基百科" class="headerlink" title="来自维基百科"></a>来自维基百科</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        The purpose of this function is to convert an unsigned</span></span><br><span class="line"><span class="comment">        binary number to reflected binary Gray code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        The operator &gt;&gt; is shift right. The operator ^ is exclusive or.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">binaryToGray</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num &gt;&gt; <span class="number">1</span>) ^ num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        The purpose of this function is to convert a reflected binary</span></span><br><span class="line"><span class="comment">        Gray code number to a binary number.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">int</span> <span class="title">grayToBinary</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mask;</span><br><span class="line">    <span class="keyword">for</span> (mask = num &gt;&gt; <span class="number">1</span>; mask != <span class="number">0</span>; mask = mask &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num = num ^ mask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;h2 id=&quot;来自维基百科&quot;&gt;&lt;a href=&quot;#来自维基百科&quot; class=&quot;</summary>
      
    
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="https://bapuqln.github.io/tags/LeetCode/"/>
    
    <category term="Medium" scheme="https://bapuqln.github.io/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>LowerBound</title>
    <link href="https://bapuqln.github.io/2020/04/25/LowerBound/"/>
    <id>https://bapuqln.github.io/2020/04/25/LowerBound/</id>
    <published>2020-04-25T11:49:35.000Z</published>
    <updated>2025-01-15T07:01:21.140Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="LowerBound"><a href="#LowerBound" class="headerlink" title="LowerBound"></a>LowerBound</h2><p>Lower Bound 是使用二分查找的办法求 大于等于 i 的第一个位置<br><span id="more"></span></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lowerBound</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= i) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>O(logn)</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>O(1)</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;LowerBound&quot;&gt;&lt;a href=&quot;#LowerBound&quot; class=&quot;headerlink&quot; title=&quot;LowerBound&quot;&gt;&lt;/a&gt;LowerBound&lt;/h2&gt;&lt;p&gt;Lower Bound 是使用二分查找的办法求 大于等于 i 的第一个位置&lt;br&gt;</summary>
    
    
    
    <category term="C++" scheme="https://bapuqln.github.io/categories/C/"/>
    
    
    <category term="Algorithm" scheme="https://bapuqln.github.io/tags/Algorithm/"/>
    
  </entry>
  
</feed>
