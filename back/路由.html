<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>路由 - ACE_xW</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="ACE_xW"><meta name="msapplication-TileImage" content="https://octodex.github.com/images/heisencat.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="ACE_xW"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="APP 内组件路由设计APP内部主要为了解决两个问题  各个页面和组件之间的跳转问题 各个组件之间的相互调用.  各个页面和组件之间的跳转问题 在iOS开发的过程中，经常会遇到以下的场景，点击按钮跳转Push到另外一个界面，或者点击一个cell Present一个新的ViewController。在MVC模式中，一般都是新建一个VC，然后Push &amp;#x2F; Present到下一个VC。但是在MVVM中，"><meta property="og:type" content="blog"><meta property="og:title" content="ACE_xW"><meta property="og:url" content="https://bapuqln.github.io/"><meta property="og:site_name" content="小布布的家"><meta property="og:description" content="APP 内组件路由设计APP内部主要为了解决两个问题  各个页面和组件之间的跳转问题 各个组件之间的相互调用.  各个页面和组件之间的跳转问题 在iOS开发的过程中，经常会遇到以下的场景，点击按钮跳转Push到另外一个界面，或者点击一个cell Present一个新的ViewController。在MVC模式中，一般都是新建一个VC，然后Push &amp;#x2F; Present到下一个VC。但是在MVVM中，"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://octodex.github.com/images/heisencat.png"><meta property="article:published_time" content="2019-12-04T07:01:12.000Z"><meta property="article:modified_time" content="2025-01-15T07:01:21.146Z"><meta property="article:author" content="ACE_xW"><meta property="article:tag" content="iOS"><meta property="article:tag" content="架构"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://octodex.github.com/images/heisencat.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://bapuqln.github.io"},"headline":"ACE_xW","image":["https://octodex.github.com/images/heisencat.png"],"datePublished":"2019-12-04T07:01:12.000Z","dateModified":"2025-01-15T07:01:21.146Z","author":{"@type":"Person","name":"ACE_xW"},"publisher":{"@type":"Organization","name":"ACE_xW","logo":{"@type":"ImageObject","url":"https://octodex.github.com/images/heisencat.png"}},"description":"APP 内组件路由设计APP内部主要为了解决两个问题  各个页面和组件之间的跳转问题 各个组件之间的相互调用.  各个页面和组件之间的跳转问题 在iOS开发的过程中，经常会遇到以下的场景，点击按钮跳转Push到另外一个界面，或者点击一个cell Present一个新的ViewController。在MVC模式中，一般都是新建一个VC，然后Push &#x2F; Present到下一个VC。但是在MVVM中，"}</script><link rel="canonical" href="https://bapuqln.github.io/back/%E8%B7%AF%E7%94%B1.html"><link rel="icon" href="https://octodex.github.com/images/heisencat.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/dracula.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css"><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><script data-ad-client="ca-pub-6519518696903770" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js" async></script><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="ACE_xW" type="application/atom+xml">
<!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://octodex.github.com/images/heisencat.png" alt="ACE_xW" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/bapuqln"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-3 is-size-4-mobile">路由</h1><div class="content"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="APP-内组件路由设计"><a href="#APP-内组件路由设计" class="headerlink" title="APP 内组件路由设计"></a>APP 内组件路由设计</h1><p>APP内部主要为了解决两个问题</p>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><ol>
<li>各个页面和组件之间的跳转问题</li>
<li>各个组件之间的相互调用.</li>
</ol>
<h2 id="各个页面和组件之间的跳转问题"><a href="#各个页面和组件之间的跳转问题" class="headerlink" title="各个页面和组件之间的跳转问题"></a>各个页面和组件之间的跳转问题</h2><p><img src="media/15197188413184/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-27%20%E4%B8%8B%E5%8D%884.11.24.png" alt="屏幕快照 2018-02-27 下午4.11.24"></p>
<p>在iOS开发的过程中，经常会遇到以下的场景，点击按钮跳转<code>Push</code>到另外一个界面，或者点击一个<code>cell Present</code>一个新的<code>ViewController</code>。在<code>MVC</code>模式中，一般都是新建一个<code>VC</code>，然后<code>Push / Present</code>到下一个<code>VC</code>。但是在<code>MVVM</code>中，会有一些不合适的情况。</p>
<p><img src="media/15197188413184/40_17.gif" alt="40_17"></p>
<p>众所周知，<code>MVVM</code>把<code>MVC</code>拆成了上图演示的样子，原来<code>View</code>对应的与数据相关的代码都移到<code>ViewModel</code>中，相应的<code>C</code>也变瘦了，演变成了<code>M-VM-C-V</code>的结构。这里的<code>C</code>里面的代码可以只剩下页面跳转相关的逻辑。如果用代码表示就是下面这样子：</p>
<p>假设一个按钮的执行逻辑都封装成了command。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@weakify</span>(<span class="keyword">self</span>);</span><br><span class="line">  [[[_viewModel.someCommand executionSignals] flatten] subscribeNext:<span class="operator">^</span>(id x) &#123;</span><br><span class="line">      <span class="meta">@strongify</span>(<span class="keyword">self</span>);</span><br><span class="line">      <span class="comment">// 跳转逻辑</span></span><br><span class="line">      [<span class="keyword">self</span>.navigationController pushViewController:targetViewController animated:<span class="type">YES</span>];</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>MVVM框架的目的除去解耦以外，还有2个很重要的目的：</p>
<ol>
<li>代码复用率高</li>
<li>方便进行单元测试</li>
</ol>
<p>如果需要测试一个业务是否正确，我们只要对<code>ViewModel</code>进行单元测试即可。前提是假定我们使用<code>ReactiveCocoa</code>进行<code>UI</code>绑定的过程是准确无误的。目前绑定是正确的。所以我们只需要单元测试到<code>ViewModel</code>即可完成业务逻辑的测试。</p>
<p>页面跳转也属于业务逻辑，所以应该放在<code>ViewModel</code>中一起单元测试，保证业务逻辑测试的覆盖率。</p>
<p>把页面跳转放到ViewModel中，有2种做法，第一种就是用路由来实现，第二种由于和路由没有关系，所以这里就不多阐述，有兴趣的可以看lpd-mvvm-kit这个库关于页面跳转的具体实现。</p>
<p>页面跳转相互的耦合性也就体现出来了：</p>
<ol>
<li>由于pushViewController或者presentViewController，后面都需要带一个待操作的ViewController，那么就必须要引入该类，import头文件也就引入了耦合性。 </li>
<li>由于跳转这里写死了跳转操作，如果线上一旦出现了bug，这里是不受我们控制的。 </li>
<li>推送消息或者是3D-Touch需求，要求直接跳转到内部第10级界面，那么就需要写一个入口跳转到指定界面。</li>
</ol>
<h2 id="各个组件之间的相互调用"><a href="#各个组件之间的相互调用" class="headerlink" title="各个组件之间的相互调用"></a>各个组件之间的相互调用</h2><p><img src="media/15197188413184/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-02-27%20%E4%B8%8B%E5%8D%884.24.18.png" alt="屏幕快照 2018-02-27 下午4.24.18"></p>
<p>关于组件间的调用，也需要解耦。随着业务越来越复杂，我们封装的组件越来越多，要是封装的粒度拿捏不准，就会出现大量组件之间耦合度高的问题。组件的粒度可以随着业务的调整，不断的调整组件职责的划分。但是组件之间的调用依旧不可避免，相互调用对方组件暴露的接口。如何减少各个组件之间的耦合度，是一个设计优秀的路由的职责所在。</p>
<h1 id="如何设计一个路由"><a href="#如何设计一个路由" class="headerlink" title="如何设计一个路由"></a>如何设计一个路由</h1><h2 id="方案调研"><a href="#方案调研" class="headerlink" title="方案调研"></a>方案调研</h2><h3 id="JLRoutes"><a href="#JLRoutes" class="headerlink" title="JLRoutes"></a>JLRoutes</h3><p><code>JLRoutes</code> 使用 <code>URL Scheme</code> 的方式，将所有的资源看成是一个<code>URL</code>。</p>
<p><img src="media/15197188413184/15197210161244.png" alt=""></p>
<p><code>JLRoutes</code> 将传入的 <code>URL Scheme</code> 按照上面的样子进行分割，并获取<code>NSURLComponent</code></p>
<p><img src="media/15197188413184/15197210988620.png" alt=""></p>
<p><code>JLRoutes</code>全局会保存一个<code>Map</code>，这个<code>Map</code>会以<code>scheme</code>为<code>Key</code>，<code>JLRoutes</code>为<code>Value</code>。所以在<code>routeControllerMap</code>里面每个<code>scheme</code>都是唯一的。</p>
<p>在每个<code>JLRoutes</code>里面都保存了一个数组，这个数组里面保存了每个路由规则<code>JLRRouteDefinition</code>里面会保存外部传进来的<code>block</code>闭包，<code>pattern</code>，和拆分之后的<code>pattern</code>。</p>
<p>在每个<code>JLRoutes</code>的数组里面，会按照路由的优先级进行排列，优先级高的排列在前面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)_registerRoute:(<span class="type">NSString</span> <span class="operator">*</span>)routePattern priority:(<span class="type">NSUInteger</span>)priority handler:(<span class="type">BOOL</span> (<span class="operator">^</span>)(<span class="type">NSDictionary</span> <span class="operator">*</span>parameters))handlerBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">JLRRouteDefinition</span> <span class="operator">*</span>route <span class="operator">=</span> [[<span class="type">JLRRouteDefinition</span> alloc] initWithScheme:<span class="keyword">self</span>.scheme pattern:routePattern priority:priority handlerBlock:handlerBlock];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (priority <span class="operator">==</span> <span class="number">0</span> <span class="operator">||</span> <span class="keyword">self</span>.routes.count <span class="operator">==</span> <span class="number">0</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.routes addObject:route];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">NSUInteger</span> index <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">BOOL</span> addedRoute <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到当前已经存在的一条优先级比当前待插入的路由低的路由</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">JLRRouteDefinition</span> <span class="operator">*</span>existingRoute <span class="keyword">in</span> [<span class="keyword">self</span>.routes <span class="keyword">copy</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (existingRoute.priority <span class="operator">&lt;</span> priority) &#123;</span><br><span class="line">                <span class="comment">// 如果找到，就插入数组</span></span><br><span class="line">                [<span class="keyword">self</span>.routes insertObject:route atIndex:index];</span><br><span class="line">                addedRoute <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index<span class="operator">++</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有找到任何一条路由比当前待插入的路由低的路由，或者最后一条路由优先级和当前路由一样，那么就只能插入到最后。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>addedRoute) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.routes addObject:route];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于这个数组里面的路由是一个单调队列，所以查找优先级的时候只用从高往低遍历即可。</p>
<p>具体查找路由的过程如下</p>
<p><img src="media/15197188413184/15197247249258.png" alt=""></p>
<p>首先根据外部传进来的<code>URL</code>初始化一个<code>JLRRouteRequest</code>，然后用这个<code>JLRRouteRequest</code>在当前的路由数组里面依次<code>request</code>，每个规则都会生成一个<code>response</code>，但是只有符合条件的<code>response</code>才会match，最后取出匹配的JLRRouteResponse拿出其字典parameters里面对应的参数就可以了。查找和匹配过程中重要的代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">BOOL</span>)_routeURL:(<span class="type">NSURL</span> <span class="operator">*</span>)<span class="type">URL</span> withParameters:(<span class="type">NSDictionary</span> <span class="operator">*</span>)parameters executeRouteBlock:(<span class="type">BOOL</span>)executeRouteBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span><span class="type">URL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> _verboseLog:@<span class="string">&quot;Trying to route URL %@&quot;</span>, <span class="type">URL</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">BOOL</span> didRoute <span class="operator">=</span> <span class="type">NO</span>;</span><br><span class="line">    <span class="type">JLRRouteRequest</span> <span class="operator">*</span>request <span class="operator">=</span> [[<span class="type">JLRRouteRequest</span> alloc] initWithURL:<span class="type">URL</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">JLRRouteDefinition</span> <span class="operator">*</span>route <span class="keyword">in</span> [<span class="keyword">self</span>.routes <span class="keyword">copy</span>]) &#123;</span><br><span class="line">        <span class="comment">// 检查每一个route，生成对应的response</span></span><br><span class="line">        <span class="type">JLRRouteResponse</span> <span class="operator">*</span>response <span class="operator">=</span> [route routeResponseForRequest:request decodePlusSymbols:shouldDecodePlusSymbols];</span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>response.isMatch) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> _verboseLog:@<span class="string">&quot;Successfully matched %@&quot;</span>, route];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>executeRouteBlock) &#123;</span><br><span class="line">            <span class="comment">// 如果我们被要求不允许执行，但是又找了匹配的路由response。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 装配最后的参数</span></span><br><span class="line">        <span class="type">NSMutableDictionary</span> <span class="operator">*</span>finalParameters <span class="operator">=</span> [<span class="type">NSMutableDictionary</span> dictionary];</span><br><span class="line">        [finalParameters addEntriesFromDictionary:response.parameters];</span><br><span class="line">        [finalParameters addEntriesFromDictionary:parameters];</span><br><span class="line">        [<span class="keyword">self</span> _verboseLog:@<span class="string">&quot;Final parameters are %@&quot;</span>, finalParameters];</span><br><span class="line"></span><br><span class="line">        didRoute <span class="operator">=</span> [route callHandlerBlockWithParameters:finalParameters];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (didRoute) &#123;</span><br><span class="line">            <span class="comment">// 调用Handler成功</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>didRoute) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _verboseLog:@<span class="string">&quot;Could not find a matching route&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果在当前路由规则里面没有找到匹配的路由，当前路由不是global 的，并且允许降级到global里面去查找，那么我们继续在global的路由规则里面去查找。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>didRoute <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>.shouldFallbackToGlobalRoutes <span class="operator">&amp;&amp;</span> <span class="operator">!</span>[<span class="keyword">self</span> _isGlobalRoutesController]) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _verboseLog:@<span class="string">&quot;Falling back to global routes...&quot;</span>];</span><br><span class="line">        didRoute <span class="operator">=</span> [[<span class="type">JLRoutes</span> globalRoutes] _routeURL:<span class="type">URL</span> withParameters:parameters executeRouteBlock:executeRouteBlock];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后，依旧没有找到任何能匹配的，如果有unmatched URL handler，调用这个闭包进行最后的处理。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>, after everything, we did not route anything and we have an unmatched <span class="type">URL</span> handler, then call it  </span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>didRoute <span class="operator">&amp;&amp;</span> executeRouteBlock <span class="operator">&amp;&amp;</span> <span class="keyword">self</span>.unmatchedURLHandler) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _verboseLog:@<span class="string">&quot;Falling back to the unmatched URL handler&quot;</span>];</span><br><span class="line">        <span class="keyword">self</span>.unmatchedURLHandler(<span class="keyword">self</span>, <span class="type">URL</span>, parameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> didRoute;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>举个例子</p>
</li>
<li><p>先注册一个Router，规则如下:</p>
</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="type">JLRoutes</span> globalRoutes] addRoute:@<span class="string">&quot;/:object/:action&quot;</span> handler:<span class="operator">^</span><span class="type">BOOL</span>(<span class="type">NSDictionary</span> <span class="operator">*</span>parameters) &#123;</span><br><span class="line">  <span class="type">NSString</span> <span class="operator">*</span>object <span class="operator">=</span> parameters[@<span class="string">&quot;object&quot;</span>];</span><br><span class="line">  <span class="type">NSString</span> <span class="operator">*</span>action <span class="operator">=</span> parameters[@<span class="string">&quot;action&quot;</span>];</span><br><span class="line">  <span class="comment">// stuff</span></span><br><span class="line">  <span class="keyword">return</span> <span class="type">YES</span>;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<ul>
<li>传入一个<code>URL</code>， 让 <code>Route</code> 处理</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSURL</span> <span class="operator">*</span>editPost <span class="operator">=</span> [<span class="type">NSURL</span> <span class="type">URLWithString</span>:@<span class="string">&quot;ele://post/halfrost?debug=true&amp;foo=bar&quot;</span>];  </span><br><span class="line">[[<span class="type">UIApplication</span> sharedApplication] openURL:editPost];</span><br></pre></td></tr></table></figure>
<ul>
<li>匹配之后，得到如下的字典</li>
</ul>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;object&quot;</span>: <span class="string">&quot;post&quot;</span>,</span><br><span class="line">  <span class="string">&quot;action&quot;</span>: <span class="string">&quot;halfrost&quot;</span>,</span><br><span class="line">  <span class="string">&quot;debug&quot;</span>: <span class="string">&quot;true&quot;</span>,</span><br><span class="line">  <span class="string">&quot;foo&quot;</span>: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">  <span class="string">&quot;JLRouteURL&quot;</span>: <span class="string">&quot;ele://post/halfrost?debug=true&amp;foo=bar&quot;</span>,</span><br><span class="line">  <span class="string">&quot;JLRoutePattern&quot;</span>: <span class="string">&quot;/:object/:action&quot;</span>,</span><br><span class="line">  <span class="string">&quot;JLRouteScheme&quot;</span>: <span class="string">&quot;JLRoutesGlobalRoutesScheme&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>详细过程<br><img src="media/15197188413184/15197260287382.png" alt=""></p>
</li>
<li><p>JLRoutes还可以支持Optional的路由规则，假如定义一条路由规则：</p>
</li>
</ul>
<p><code>Swift/the(/foo/:a)(/bar/:b)</code></p>
<p>JLRoutes 会帮我们默认注册如下4条路由规则：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/the/</span>foo<span class="regexp">/:a/</span>bar<span class="operator">/</span>:b</span><br><span class="line"><span class="regexp">/the/</span>foo<span class="operator">/</span>:a</span><br><span class="line"><span class="regexp">/the/</span>bar<span class="operator">/</span>:b</span><br><span class="line"><span class="operator">/</span>the</span><br></pre></td></tr></table></figure>
<h3 id="routable-ios"><a href="#routable-ios" class="headerlink" title="routable-ios"></a>routable-ios</h3><p><code>Routable</code>路由是用在<code>in-app native</code>端的 <code>URL router</code>, 它可以用在<code>iOS</code>上也可以用在 <code>Android</code></p>
<p><img src="media/15197188413184/15197262030002.png" alt=""></p>
<p><code>UPRouter</code>里面保存了2个字典。</p>
<ul>
<li><code>routes</code>字典里面存储的<code>Key</code>是路由规则，<code>Value</code>存储的是<code>UPRouterOptions</code>。</li>
<li><code>cachedRoutes</code>里面存储的<code>Key</code>是最终的<code>URL</code>，带传参的，<code>Value</code>存储的是<code>RouterParams</code>。<code>RouterParams</code>里面会包含在<code>routes</code>匹配的到的<code>UPRouterOptions</code>，还有额外的打开参数<code>openParams</code>和一些额外参数<code>extraParams</code>。</li>
</ul>
<p>这一段代码里面重点在干一件事情，遍历routes字典，然后找到参数匹配的字符串，封装成RouterParams返回。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">RouterParams</span> <span class="operator">*</span>)routerParamsForUrl:(<span class="type">NSString</span> <span class="operator">*</span>)url extraParams: (<span class="type">NSDictionary</span> <span class="operator">*</span>)extraParams &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>url) &#123;</span><br><span class="line">        <span class="comment">//if we wait, caching this as key would throw an exception</span></span><br><span class="line">        <span class="keyword">if</span> (_ignoresExceptions) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@throw</span> [<span class="type">NSException</span> exceptionWithName:@<span class="string">&quot;RouteNotFoundException&quot;</span></span><br><span class="line">                                       reason:[<span class="type">NSString</span> stringWithFormat:<span class="type">ROUTE_NOT_FOUND_FORMAT</span>, url]</span><br><span class="line">                                     userInfo:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.cachedRoutes objectForKey:url] <span class="operator">&amp;&amp;</span> <span class="operator">!</span>extraParams) &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span>.cachedRoutes objectForKey:url];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 比对url通过/分割之后的参数个数和pathComponents的个数是否一样</span></span><br><span class="line">    <span class="type">NSArray</span> <span class="operator">*</span>givenParts <span class="operator">=</span> url.pathComponents;</span><br><span class="line">    <span class="type">NSArray</span> <span class="operator">*</span>legacyParts <span class="operator">=</span> [url componentsSeparatedByString:@<span class="string">&quot;/&quot;</span>];</span><br><span class="line">    <span class="keyword">if</span> ([legacyParts count] <span class="operator">!=</span> [givenParts count]) &#123;</span><br><span class="line">        <span class="type">NSLog</span>(@<span class="string">&quot;Routable Warning - your URL %@ has empty path components - this will throw an error in an upcoming release&quot;</span>, url);</span><br><span class="line">        givenParts <span class="operator">=</span> legacyParts;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __block <span class="type">RouterParams</span> <span class="operator">*</span>openParams <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span>.routes enumerateKeysAndObjectsUsingBlock:</span><br><span class="line">     <span class="operator">^</span>(<span class="type">NSString</span> <span class="operator">*</span>routerUrl, <span class="type">UPRouterOptions</span> <span class="operator">*</span>routerOptions, <span class="type">BOOL</span> <span class="operator">*</span>stop) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="type">NSArray</span> <span class="operator">*</span>routerParts <span class="operator">=</span> [routerUrl pathComponents];</span><br><span class="line">         <span class="keyword">if</span> ([routerParts count] <span class="operator">==</span> [givenParts count]) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="type">NSDictionary</span> <span class="operator">*</span>givenParams <span class="operator">=</span> [<span class="keyword">self</span> paramsForUrlComponents:givenParts routerUrlComponents:routerParts];</span><br><span class="line">             <span class="keyword">if</span> (givenParams) &#123;</span><br><span class="line">                 openParams <span class="operator">=</span> [[<span class="type">RouterParams</span> alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams];</span><br><span class="line">                 <span class="operator">*</span>stop <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>openParams) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ignoresExceptions) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@throw</span> [<span class="type">NSException</span> exceptionWithName:@<span class="string">&quot;RouteNotFoundException&quot;</span></span><br><span class="line">                                       reason:[<span class="type">NSString</span> stringWithFormat:<span class="type">ROUTE_NOT_FOUND_FORMAT</span>, url]</span><br><span class="line">                                     userInfo:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.cachedRoutes setObject:openParams forKey:url];</span><br><span class="line">    <span class="keyword">return</span> openParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这段函数，第一个参数是外部传进来URL带有各个入参的分割数组。第二个参数是路由规则分割开的数组。routerComponent由于规定：号后面才是参数，所以routerComponent的第1个位置就是对应的参数名。params字典里面以参数名为Key，参数为Value。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">NSDictionary</span> <span class="operator">*</span>)paramsForUrlComponents:(<span class="type">NSArray</span> <span class="operator">*</span>)givenUrlComponents routerUrlComponents:(<span class="type">NSArray</span> <span class="operator">*</span>)routerUrlComponents &#123;</span><br><span class="line"></span><br><span class="line">    __block <span class="type">NSMutableDictionary</span> <span class="operator">*</span>params <span class="operator">=</span> [<span class="type">NSMutableDictionary</span> dictionary];</span><br><span class="line">    [routerUrlComponents enumerateObjectsUsingBlock:</span><br><span class="line">     <span class="operator">^</span>(<span class="type">NSString</span> <span class="operator">*</span>routerComponent, <span class="type">NSUInteger</span> idx, <span class="type">BOOL</span> <span class="operator">*</span>stop) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="type">NSString</span> <span class="operator">*</span>givenComponent <span class="operator">=</span> givenUrlComponents[idx];</span><br><span class="line">         <span class="keyword">if</span> ([routerComponent hasPrefix:@<span class="string">&quot;:&quot;</span>]) &#123;</span><br><span class="line">             <span class="type">NSString</span> <span class="operator">*</span>key <span class="operator">=</span> [routerComponent substringFromIndex:<span class="number">1</span>];</span><br><span class="line">             [params setObject:givenComponent forKey:key];</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (<span class="operator">!</span>[routerComponent isEqualToString:givenComponent]) &#123;</span><br><span class="line">             params <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">             <span class="operator">*</span>stop <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;];</span><br><span class="line">    <span class="keyword">return</span> params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过RouterParams的初始化方法，把路由规则对应的UPRouterOptions，上一步封装好的参数字典givenParams，还有 routerParamsForUrl: extraParams: 方法的第二个入参，这3个参数作为初始化参数，生成了一个RouterParams</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">NSDictionary</span> <span class="operator">*</span>givenParams <span class="operator">=</span> [<span class="keyword">self</span> paramsForUrlComponents:givenParts routerUrlComponents:routerParts];</span><br><span class="line"><span class="keyword">if</span> (givenParams) &#123;  </span><br><span class="line">       openParams <span class="operator">=</span> [[<span class="type">RouterParams</span> alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams];</span><br><span class="line">       <span class="operator">*</span>stop <span class="operator">=</span> <span class="type">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步self.cachedRoutes的字典里面Key为带参数的URL，Value是RouterParams。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span>.cachedRoutes setObject:openParams forKey:url];</span><br></pre></td></tr></table></figure>
<p><img src="media/15197188413184/15197265372336.png" alt=""></p>
<p>最后将匹配封装出来的RouterParams转换成对应的Controller。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">UIViewController</span> <span class="operator">*</span>)controllerForRouterParams:(<span class="type">RouterParams</span> <span class="operator">*</span>)params &#123;</span><br><span class="line">    <span class="type">SEL</span> <span class="type">CONTROLLER_CLASS_SELECTOR</span> <span class="operator">=</span> sel_registerName(<span class="string">&quot;allocWithRouterParams:&quot;</span>);</span><br><span class="line">    <span class="type">SEL</span> <span class="type">CONTROLLER_SELECTOR</span> <span class="operator">=</span> sel_registerName(<span class="string">&quot;initWithRouterParams:&quot;</span>);</span><br><span class="line">    <span class="type">UIViewController</span> <span class="operator">*</span>controller <span class="operator">=</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="type">Class</span> controllerClass <span class="operator">=</span> params.routerOptions.openClass;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored <span class="string">&quot;-Warc-performSelector-leaks&quot;</span></span><br><span class="line">    <span class="keyword">if</span> ([controllerClass respondsToSelector:<span class="type">CONTROLLER_CLASS_SELECTOR</span>]) &#123;</span><br><span class="line">        controller <span class="operator">=</span> [controllerClass performSelector:<span class="type">CONTROLLER_CLASS_SELECTOR</span> withObject:[params controllerParams]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([params.routerOptions.openClass instancesRespondToSelector:<span class="type">CONTROLLER_SELECTOR</span>]) &#123;</span><br><span class="line">        controller <span class="operator">=</span> [[params.routerOptions.openClass alloc] performSelector:<span class="type">CONTROLLER_SELECTOR</span> withObject:[params controllerParams]];</span><br><span class="line">    &#125;</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    <span class="keyword">if</span> (<span class="operator">!</span>controller) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_ignoresExceptions) &#123;</span><br><span class="line">            <span class="keyword">return</span> controller;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@throw</span> [<span class="type">NSException</span> exceptionWithName:@<span class="string">&quot;RoutableInitializerNotFound&quot;</span></span><br><span class="line">                                       reason:[<span class="type">NSString</span> stringWithFormat:<span class="type">INVALID_CONTROLLER_FORMAT</span>, <span class="type">NSStringFromClass</span>(controllerClass), <span class="type">NSStringFromSelector</span>(<span class="type">CONTROLLER_CLASS_SELECTOR</span>),  <span class="type">NSStringFromSelector</span>(<span class="type">CONTROLLER_SELECTOR</span>)]</span><br><span class="line">                                     userInfo:<span class="literal">nil</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    controller.modalTransitionStyle <span class="operator">=</span> params.routerOptions.transitionStyle;</span><br><span class="line">    controller.modalPresentationStyle <span class="operator">=</span> params.routerOptions.presentationStyle;</span><br><span class="line">    <span class="keyword">return</span> controller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Controller是一个类，那么就调用allocWithRouterParams:方法去初始化。如果Controller已经是一个实例了，那么就调用initWithRouterParams:方法去初始化。</p>
<p>将Routable的大致流程图解如下：</p>
<p><img src="media/15197188413184/15197265940832.png" alt=""></p>
<h2 id="HHRouter"><a href="#HHRouter" class="headerlink" title="HHRouter"></a>HHRouter</h2><p>ViewController提供了2个方法。map是用来设置路由规则，matchController是用来匹配路由规则的，匹配争取之后返回对应的UIViewController。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)map:(<span class="type">NSString</span> <span class="operator">*</span>)route toControllerClass:(<span class="type">Class</span>)controllerClass;</span><br><span class="line"><span class="operator">-</span> (<span class="type">UIViewController</span> <span class="operator">*</span>)matchController:(<span class="type">NSString</span> <span class="operator">*</span>)route;</span><br></pre></td></tr></table></figure>
<p>block闭包提供了三个方法，map也是设置路由规则，matchBlock：是用来匹配路由，找到指定的block，但是不会调用该block。callBlock:是找到指定的block，找到以后就立即调用。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)map:(<span class="type">NSString</span> <span class="operator">*</span>)route toBlock:(<span class="type">HHRouterBlock</span>)block;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">HHRouterBlock</span>)matchBlock:(<span class="type">NSString</span> <span class="operator">*</span>)route;</span><br><span class="line"><span class="operator">-</span> (id)callBlock:(<span class="type">NSString</span> <span class="operator">*</span>)route;</span><br></pre></td></tr></table></figure>
<p>matchBlock:和callBlock:的区别就在于前者不会自动调用闭包。所以matchBlock:方法找到对应的block之后，如果想调用，需要手动调用一次。</p>
<p>除去上面这些方法，HHRouter还为我们提供了一个特殊的方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">HHRouteType</span>)canRoute:(<span class="type">NSString</span> <span class="operator">*</span>)route;</span><br></pre></td></tr></table></figure>
<p>这个方法就是用来找到执行路由规则对应的RouteType，RouteType总共就3种:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef <span class="type">NS_ENUM</span> (<span class="type">NSInteger</span>, <span class="type">HHRouteType</span>) &#123;  </span><br><span class="line">    <span class="type">HHRouteTypeNone</span> <span class="operator">=</span> <span class="number">0</span>,</span><br><span class="line">    <span class="type">HHRouteTypeViewController</span> <span class="operator">=</span> <span class="number">1</span>,</span><br><span class="line">    <span class="type">HHRouteTypeBlock</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>再来看看HHRouter是如何管理路由规则的。整个HHRouter就是由一个NSMutableDictionary *routes控制的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">HHRouter</span> ()</span><br><span class="line"><span class="meta">@property</span> (strong, nonatomic) <span class="type">NSMutableDictionary</span> <span class="operator">*</span>routes;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>
<p> <img src="media/15197188413184/15211892591766.png" alt=""></p>
<p>别看只有这一个看似“简单”的字典数据结构，但是HHRouter路由设计的还是很精妙的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)map:(<span class="type">NSString</span> <span class="operator">*</span>)route toBlock:(<span class="type">HHRouterBlock</span>)block</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">NSMutableDictionary</span> <span class="operator">*</span>subRoutes <span class="operator">=</span> [<span class="keyword">self</span> subRoutesToRoute:route];</span><br><span class="line">    subRoutes[@<span class="string">&quot;_&quot;</span>] <span class="operator">=</span> [block <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)map:(<span class="type">NSString</span> <span class="operator">*</span>)route toControllerClass:(<span class="type">Class</span>)controllerClass</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">NSMutableDictionary</span> <span class="operator">*</span>subRoutes <span class="operator">=</span> [<span class="keyword">self</span> subRoutesToRoute:route];</span><br><span class="line">    subRoutes[@<span class="string">&quot;_&quot;</span>] <span class="operator">=</span> controllerClass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两个方法分别是block闭包和ViewController设置路由规则调用的方法实体。不管是ViewController还是block闭包，设置规则的时候都会调用subRoutesToRoute:方法。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">NSMutableDictionary</span> <span class="operator">*</span>)subRoutesToRoute:(<span class="type">NSString</span> <span class="operator">*</span>)route</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">NSArray</span> <span class="operator">*</span>pathComponents <span class="operator">=</span> [<span class="keyword">self</span> pathComponentsFromRoute:route];</span><br><span class="line"></span><br><span class="line">    <span class="type">NSInteger</span> index <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">NSMutableDictionary</span> <span class="operator">*</span>subRoutes <span class="operator">=</span> <span class="keyword">self</span>.routes;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (index <span class="operator">&lt;</span> pathComponents.count) &#123;</span><br><span class="line">        <span class="type">NSString</span> <span class="operator">*</span>pathComponent <span class="operator">=</span> pathComponents[index];</span><br><span class="line">        <span class="keyword">if</span> (<span class="operator">!</span>[subRoutes objectForKey:pathComponent]) &#123;</span><br><span class="line">            subRoutes[pathComponent] <span class="operator">=</span> [[<span class="type">NSMutableDictionary</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        subRoutes <span class="operator">=</span> subRoutes[pathComponent];</span><br><span class="line">        index<span class="operator">++</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> subRoutes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段函数就是来构造路由匹配规则的字典。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="type">HHRouter</span> shared] map:@<span class="string">&quot;/user/:userId/&quot;</span></span><br><span class="line">         toControllerClass:[<span class="type">UserViewController</span> <span class="keyword">class</span>]];</span><br><span class="line">[[<span class="type">HHRouter</span> shared] map:@<span class="string">&quot;/story/:storyId/&quot;</span></span><br><span class="line">         toControllerClass:[<span class="type">StoryViewController</span> <span class="keyword">class</span>]];</span><br><span class="line">[[<span class="type">HHRouter</span> shared] map:@<span class="string">&quot;/user/:userId/story/?a=0&quot;</span></span><br><span class="line">         toControllerClass:[<span class="type">StoryListViewController</span> <span class="keyword">class</span>]];</span><br></pre></td></tr></table></figure>
<p>设置3条规则以后，按照上面构造路由匹配规则的字典的方法，该路由规则字典就会变成这个样子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    story <span class="operator">=</span>     &#123;</span><br><span class="line">        <span class="string">&quot;:storyId&quot;</span> <span class="operator">=</span>         &#123;</span><br><span class="line">            <span class="string">&quot;_&quot;</span> <span class="operator">=</span> <span class="type">StoryViewController</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    user <span class="operator">=</span>     &#123;</span><br><span class="line">        <span class="string">&quot;:userId&quot;</span> <span class="operator">=</span>         &#123;</span><br><span class="line">            <span class="string">&quot;_&quot;</span> <span class="operator">=</span> <span class="type">UserViewController</span>;</span><br><span class="line">            story <span class="operator">=</span>             &#123;</span><br><span class="line">                <span class="string">&quot;_&quot;</span> <span class="operator">=</span> <span class="type">StoryListViewController</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>路由规则字典生成之后，等到匹配的时候就会遍历这个字典。</p>
<p>假设这时候有一条路由过来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[[HHRouter shared] matchController:@<span class="string">&quot;hhrouter20://user/1/&quot;</span>] class],</span><br></pre></td></tr></table></figure>
<p>HHRouter对这条路由的处理方式是先匹配前面的scheme，如果连scheme都不正确的话，会直接导致后面匹配失败。</p>
<p>然后再进行路由匹配，最后生成的参数字典如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;controller_class&quot;</span> = UserViewController;</span><br><span class="line">    route = <span class="string">&quot;/user/1/&quot;</span>;</span><br><span class="line">    userId = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的路由参数匹配的函数在</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">NSDictionary</span> <span class="operator">*</span>)paramsInRoute:(<span class="type">NSString</span> <span class="operator">*</span>)route</span><br></pre></td></tr></table></figure>
<p>个方法里面实现的。这个方法就是按照路由匹配规则，把传进来的URL的参数都一一解析出来，带？号的也都会解析成字典。这个方法没什么难度，就不在赘述了。</p>
<p>ViewController 的字典里面默认还会加上2项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;controller_class&quot;</span> <span class="operator">=</span> </span><br><span class="line">route <span class="operator">=</span> </span><br></pre></td></tr></table></figure>
<p>route里面都会保存传过来的完整的URL。</p>
<p>如果传进来的路由后面带访问字符串呢？那我们再来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[HHRouter shared] matchController:@<span class="string">&quot;/user/1/?a=b&amp;c=d&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>那么解析出所有的参数字典会是下面的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    a = b;</span><br><span class="line">    c = d;</span><br><span class="line">    <span class="string">&quot;controller_class&quot;</span> = UserViewController;</span><br><span class="line">    route = <span class="string">&quot;/user/1/?a=b&amp;c=d&quot;</span>;</span><br><span class="line">    userId = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理，如果是一个block闭包的情况呢？</p>
<p>还是先添加一条block闭包的路由规则：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="type">HHRouter</span> shared] map:@<span class="string">&quot;/user/add/&quot;</span> toBlock:<span class="operator">^</span>id(<span class="type">NSDictionary</span><span class="operator">*</span> params) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p>这条规则对应的会生成一个路由规则的字典。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    story <span class="operator">=</span>     &#123;</span><br><span class="line">        <span class="string">&quot;:storyId&quot;</span> <span class="operator">=</span>         &#123;</span><br><span class="line">            <span class="string">&quot;_&quot;</span> <span class="operator">=</span> <span class="type">StoryViewController</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">    user <span class="operator">=</span>     &#123;</span><br><span class="line">        <span class="string">&quot;:userId&quot;</span> <span class="operator">=</span>         &#123;</span><br><span class="line">            <span class="string">&quot;_&quot;</span> <span class="operator">=</span> <span class="type">UserViewController</span>;</span><br><span class="line">            story <span class="operator">=</span>             &#123;</span><br><span class="line">                <span class="string">&quot;_&quot;</span> <span class="operator">=</span> <span class="type">StoryListViewController</span>;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;;</span><br><span class="line">        add <span class="operator">=</span>         &#123;</span><br><span class="line">            <span class="string">&quot;_&quot;</span> <span class="operator">=</span> <span class="string">&quot;&lt;__NSMallocBlock__: 0x600000240480&gt;&quot;</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意”_”后面跟着是一个block。</p>
<p>匹配block闭包的方式有两种。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.第一种方式匹配到对应的block之后，还需要手动调用一次闭包。</span></span><br><span class="line">    <span class="type">HHRouterBlock</span> block <span class="operator">=</span> [[<span class="type">HHRouter</span> shared] matchBlock:@<span class="string">&quot;/user/add/?a=1&amp;b=2&quot;</span>];</span><br><span class="line">    block(<span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.第二种方式匹配block之后自动会调用改闭包。</span></span><br><span class="line">    [[<span class="type">HHRouter</span> shared] callBlock:@<span class="string">&quot;/user/add/?a=1&amp;b=2&quot;</span>];</span><br></pre></td></tr></table></figure>
<p>匹配出来的参数字典是如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    a <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    b <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    block <span class="operator">=</span> <span class="string">&quot;&lt;__NSMallocBlock__: 0x600000056b90&gt;&quot;</span>;</span><br><span class="line">    route <span class="operator">=</span> <span class="string">&quot;/user/add/?a=1&amp;b=2&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>block的字典里面会默认加上下面这2项：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">block <span class="operator">=</span>  </span><br><span class="line">route <span class="operator">=</span> </span><br></pre></td></tr></table></figure>
<p>route里面都会保存传过来的完整的URL。</p>
<p>生成的参数字典最终会被绑定到ViewController的Associated Object关联对象上。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)setParams:(<span class="type">NSDictionary</span> <span class="operator">*</span>)paramsDictionary</span><br><span class="line">&#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span>kAssociatedParamsObjectKey, paramsDictionary, <span class="type">OBJC_ASSOCIATION_RETAIN_NONATOMIC</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">NSDictionary</span> <span class="operator">*</span>)params</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="operator">&amp;</span>kAssociatedParamsObjectKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个绑定的过程是在match匹配完成的时候进行的。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">UIViewController</span> <span class="operator">*</span>)matchController:(<span class="type">NSString</span> <span class="operator">*</span>)route</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">NSDictionary</span> <span class="operator">*</span>params <span class="operator">=</span> [<span class="keyword">self</span> paramsInRoute:route];</span><br><span class="line">    <span class="type">Class</span> controllerClass <span class="operator">=</span> params[@<span class="string">&quot;controller_class&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">UIViewController</span> <span class="operator">*</span>viewController <span class="operator">=</span> [[controllerClass alloc] <span class="keyword">init</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([viewController respondsToSelector:<span class="meta">@selector</span>(setParams:)]) &#123;</span><br><span class="line">        [viewController performSelector:<span class="meta">@selector</span>(setParams:)</span><br><span class="line">                             withObject:[params <span class="keyword">copy</span>]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> viewController;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终得到的ViewController也是我们想要的。相应的参数都在它绑定的params属性的字典里面。</p>
<p>将上述过程图解出来，如下：<br><img src="media/15197188413184/15211899308460.png" alt=""></p>
<h2 id="MGJRouter"><a href="#MGJRouter" class="headerlink" title="MGJRouter"></a>MGJRouter</h2><p>JLRoutes 的问题主要在于查找 URL 的实现不够高效，通过遍历而不是匹配。还有就是功能偏多。</p>
<p>HHRouter 的 URL 查找是基于匹配，所以会更高效，MGJRouter 也是采用的这种方法，但它跟 ViewController 绑定地过于紧密，一定程度上降低了灵活性。</p>
<p>于是就有了 MGJRouter。</p>
<p>从数据结构来看，MGJRouter还是和HHRouter一模一样的</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">MGJRouter</span> ()</span><br><span class="line"><span class="meta">@property</span> (nonatomic) <span class="type">NSMutableDictionary</span> <span class="operator">*</span>routes;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>
<p><img src="media/15197188413184/15211900629238.png" alt=""></p>
<p>那么我们就来看看它对HHRouter做了哪些优化改进。</p>
<p>1.MGJRouter支持openURL时，可以传一些 userinfo 过去</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">MGJRouter</span> openURL:@<span class="string">&quot;mgj://category/travel&quot;</span> withUserInfo:@&#123;@<span class="string">&quot;user_id&quot;</span>: @<span class="number">1900</span>&#125; completion:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>
<p>这个对比HHRouter，仅仅只是写法上的一个语法糖，在HHRouter中虽然不支持带字典的参数，但是在URL后面可以用URL Query Parameter来弥补。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="type">MGJRouterHandler</span> handler <span class="operator">=</span> parameters[@<span class="string">&quot;block&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            parameters[<span class="type">MGJRouterParameterCompletion</span>] <span class="operator">=</span> completion;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (userInfo) &#123;</span><br><span class="line">            parameters[<span class="type">MGJRouterParameterUserInfo</span>] <span class="operator">=</span> userInfo;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">            [parameters removeObjectForKey:@<span class="string">&quot;block&quot;</span>];</span><br><span class="line">            handler(parameters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>MGJRouter对userInfo的处理是直接把它封装到Key = MGJRouterParameterUserInfo对应的Value里面。</p>
<p>2.支持中文的URL。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[parameters enumerateKeysAndObjectsUsingBlock:<span class="operator">^</span>(id key, <span class="type">NSString</span> <span class="operator">*</span>obj, <span class="type">BOOL</span> <span class="operator">*</span>stop) &#123;</span><br><span class="line">     <span class="keyword">if</span> ([obj isKindOfClass:[<span class="type">NSString</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">         parameters[key] <span class="operator">=</span> [obj stringByReplacingPercentEscapesUsingEncoding:<span class="type">NSUTF8StringEncoding</span>];</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;];</span><br></pre></td></tr></table></figure>
<p>这里就是需要注意一下编码。</p>
<p>3.定义一个全局的 URL Pattern 作为 Fallback。<br>这一点是模仿的JLRoutes的匹配不到会自动降级到global的思想。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="type">MGJRouterHandler</span> handler <span class="operator">=</span> parameters[@<span class="string">&quot;block&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span> (handler) &#123;</span><br><span class="line">            [parameters removeObjectForKey:@<span class="string">&quot;block&quot;</span>];</span><br><span class="line">            handler(parameters);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>parameters字典里面会先存储下一个路由规则，存在block闭包中，在匹配的时候会取出这个handler，降级匹配到这个闭包中，进行最终的处理。</p>
<p>4.当 OpenURL 结束时，可以执行 Completion Block。<br>在MGJRouter里面，作者对原来的HHRouter字典里面存储的路由规则的结构进行了改造。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NSString</span> <span class="operator">*</span>const <span class="type">MGJRouterParameterURL</span> <span class="operator">=</span> @<span class="string">&quot;MGJRouterParameterURL&quot;</span>;  </span><br><span class="line"><span class="type">NSString</span> <span class="operator">*</span>const <span class="type">MGJRouterParameterCompletion</span> <span class="operator">=</span> @<span class="string">&quot;MGJRouterParameterCompletion&quot;</span>;  </span><br><span class="line"><span class="type">NSString</span> <span class="operator">*</span>const <span class="type">MGJRouterParameterUserInfo</span> <span class="operator">=</span> @<span class="string">&quot;MGJRouterParameterUserInfo&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>这3个key会分别保存一些信息：</p>
<p>MGJRouterParameterURL保存的传进来的完整的URL信息。<br>MGJRouterParameterCompletion保存的是completion闭包。<br>MGJRouterParameterUserInfo保存的是UserInfo字典。</p>
<p>举个例子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="type">MGJRouter</span> registerURLPattern:@<span class="string">&quot;ele://name/:name&quot;</span> toHandler:<span class="operator">^</span>(<span class="type">NSDictionary</span> <span class="operator">*</span>routerParameters) &#123;</span><br><span class="line">       void (<span class="operator">^</span>completion)(<span class="type">NSString</span> <span class="operator">*</span>) <span class="operator">=</span> routerParameters[<span class="type">MGJRouterParameterCompletion</span>];</span><br><span class="line">       <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">           completion(@<span class="string">&quot;完成了&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;];</span><br><span class="line"></span><br><span class="line">   [<span class="type">MGJRouter</span> openURL:@<span class="string">&quot;ele://name/halfrost/?age=20&quot;</span> withUserInfo:@&#123;@<span class="string">&quot;user_id&quot;</span>: @<span class="number">1900</span>&#125; completion:<span class="operator">^</span>(id result) &#123;</span><br><span class="line">       <span class="type">NSLog</span>(@<span class="string">&quot;result = %@&quot;</span>,result);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
<p>上面的URL会匹配成功，那么生成的参数字典结构如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">MGJRouterParameterCompletion</span> <span class="operator">=</span> <span class="string">&quot;&lt;__NSGlobalBlock__: 0x107ffe680&gt;&quot;</span>;</span><br><span class="line">    <span class="type">MGJRouterParameterURL</span> <span class="operator">=</span> <span class="string">&quot;ele://name/halfrost/?age=20&quot;</span>;</span><br><span class="line">    <span class="type">MGJRouterParameterUserInfo</span> <span class="operator">=</span>     &#123;</span><br><span class="line">        <span class="string">&quot;user_id&quot;</span> <span class="operator">=</span> <span class="number">1900</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    age <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">    block <span class="operator">=</span> <span class="string">&quot;&lt;__NSMallocBlock__: 0x608000252120&gt;&quot;</span>;</span><br><span class="line">    name <span class="operator">=</span> halfrost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>5.可以统一管理URL<br>这个功能非常有用。</p>
<p>URL 的处理一不小心，就容易散落在项目的各个角落，不容易管理。比如注册时的 pattern 是 mgj://beauty/:id，然后 open 时就是 mgj://beauty/123，这样到时候 url 有改动，处理起来就会很麻烦，不好统一管理。</p>
<p>所以 MGJRouter 提供了一个类方法来处理这个问题。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define <span class="type">TEMPLATE_URL</span> @<span class="string">&quot;qq://name/:name&quot;</span></span><br><span class="line"></span><br><span class="line">[<span class="type">MGJRouter</span> registerURLPattern:<span class="type">TEMPLATE_URL</span>  toHandler:<span class="operator">^</span>(<span class="type">NSDictionary</span> <span class="operator">*</span>routerParameters) &#123;</span><br><span class="line">    <span class="type">NSLog</span>(@<span class="string">&quot;routerParameters[name]:%@&quot;</span>, routerParameters[@<span class="string">&quot;name&quot;</span>]); <span class="comment">// halfrost</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[<span class="type">MGJRouter</span> openURL:[<span class="type">MGJRouter</span> generateURLWithPattern:<span class="type">TEMPLATE_URL</span> parameters:@[@<span class="string">&quot;halfrost&quot;</span>]]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>generateURLWithPattern:函数会对我们定义的宏里面的所有的:进行替换，替换成后面的字符串数组，依次赋值。</p>
<p>将上述过程图解出来，如下：<img src="media/15197188413184/15211903226048.png" alt=""></p>
<p>蘑菇街为了区分开页面间调用和组件间调用，于是想出了一种新的方法。用Protocol的方法来进行组件间的调用。</p>
<p>每个组件之间都有一个 Entry，这个 Entry，主要做了三件事：</p>
<ul>
<li>注册这个组件关心的 URL</li>
<li>注册这个组件能够被调用的方法/属性</li>
<li>在 App 生命周期的不同阶段做不同的响应<br>页面间的openURL调用就是如下的样子：</li>
</ul>
<p><img src="media/15197188413184/15211903551026.png" alt=""></p>
<p>每个组件间都会向MGJRouter注册，组件间相互调用或者是其他的App都可以通过openURL:方法打开一个界面或者调用一个组件。</p>
<p>在组件间的调用，蘑菇街采用了Protocol的方式。<img src="media/15197188413184/15211903976359.png" alt=""></p>
<p>[ModuleManager registerClass:ClassA forProtocol:ProtocolA] 的结果就是在 MM 内部维护的 dict 里新加了一个映射关系。</p>
<p>[ModuleManager classForProtocol:ProtocolA] 的返回结果就是之前在 MM 内部 dict 里 protocol 对应的 class，使用方不需要关心这个 class 是个什么东东，反正实现了 ProtocolA 协议，拿来用就行。</p>
<p>这里需要有一个公共的地方来容纳这些 public protocl，也就是图中的 PublicProtocl.h。</p>
<p>我猜测，大概实现可能是下面的样子：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">ModuleProtocolManager</span> : <span class="type">NSObject</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span> (void)registServiceProvide:(id)provide forProtocol:(<span class="type">Protocol</span><span class="operator">*</span>)<span class="keyword">protocol</span>;</span><br><span class="line"><span class="operator">+</span> (id)serviceProvideForProtocol:(<span class="type">Protocol</span> <span class="operator">*</span>)<span class="keyword">protocol</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>
<p>然后这是一个单例，在这里注册各个协议</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> <span class="type">ModuleProtocolManager</span> ()</span><br><span class="line"></span><br><span class="line"><span class="meta">@property</span> (nonatomic, strong) <span class="type">NSMutableDictionary</span> <span class="operator">*</span>serviceProvideSource;</span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">ModuleProtocolManager</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span> (<span class="type">ModuleProtocolManager</span> <span class="operator">*</span>)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">ModuleProtocolManager</span> <span class="operator">*</span> instance;</span><br><span class="line">    <span class="keyword">static</span> dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(<span class="operator">&amp;</span>onceToken, <span class="operator">^</span>&#123;</span><br><span class="line">        instance <span class="operator">=</span> [[<span class="keyword">self</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (instancetype)<span class="keyword">init</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> <span class="operator">=</span> [<span class="keyword">super</span> <span class="keyword">init</span>];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _serviceProvideSource <span class="operator">=</span> [[<span class="type">NSMutableDictionary</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span> (void)registServiceProvide:(id)provide forProtocol:(<span class="type">Protocol</span><span class="operator">*</span>)<span class="keyword">protocol</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (provide <span class="operator">==</span> <span class="literal">nil</span> <span class="operator">||</span> <span class="keyword">protocol</span> <span class="operator">==</span> <span class="literal">nil</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    [[<span class="keyword">self</span> sharedInstance].serviceProvideSource setObject:provide forKey:<span class="type">NSStringFromProtocol</span>(<span class="keyword">protocol</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">+</span> (id)serviceProvideForProtocol:(<span class="type">Protocol</span> <span class="operator">*</span>)<span class="keyword">protocol</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> sharedInstance].serviceProvideSource objectForKey:<span class="type">NSStringFromProtocol</span>(<span class="keyword">protocol</span>)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在ModuleProtocolManager中用一个字典保存每个注册的protocol。现在再来猜猜ModuleEntry的实现。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#<span class="keyword">import</span> &lt;UIKit/UIKit.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@protocol</span> <span class="type">DetailModuleEntryProtocol</span> <span class="operator">&lt;</span><span class="type">NSObject</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@required</span>;</span><br><span class="line"><span class="operator">-</span> (<span class="type">UIViewController</span> <span class="operator">*</span>)detailViewControllerWithId:(<span class="type">NSString</span><span class="operator">*</span>)<span class="type">Id</span> <span class="type">Name</span>:(<span class="type">NSString</span> <span class="operator">*</span>)name;</span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>
<p>然后每个模块内都有一个和暴露到外面的协议相连接的“接头”。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">DetailModuleEntry</span> : <span class="type">NSObject</span></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>
<p>在它的实现中，需要引入3个外部文件，一个是ModuleProtocolManager，一个是DetailModuleEntryProtocol，最后一个是所在模块需要跳转或者调用的组件或者页面。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#<span class="keyword">import</span> &quot;DetailModuleEntry.h&quot;</span><br><span class="line"></span><br><span class="line">#<span class="keyword">import</span> &lt;DetailModuleEntryProtocol/DetailModuleEntryProtocol.h&gt;</span><br><span class="line">#<span class="keyword">import</span> &lt;ModuleProtocolManager/ModuleProtocolManager.h&gt;</span><br><span class="line">#<span class="keyword">import</span> &quot;DetailViewController.h&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">@interface</span> <span class="type">DetailModuleEntry</span>()<span class="operator">&lt;</span><span class="type">DetailModuleEntryProtocol</span><span class="operator">&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@implementation</span> <span class="type">DetailModuleEntry</span></span><br><span class="line"></span><br><span class="line"><span class="operator">+</span> (void)load</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="type">ModuleProtocolManager</span> registServiceProvide:[[<span class="keyword">self</span> alloc] <span class="keyword">init</span>] forProtocol:<span class="meta">@protocol</span>(<span class="type">DetailModuleEntryProtocol</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (<span class="type">UIViewController</span> <span class="operator">*</span>)detailViewControllerWithId:(<span class="type">NSString</span><span class="operator">*</span>)<span class="type">Id</span> <span class="type">Name</span>:(<span class="type">NSString</span> <span class="operator">*</span>)name</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">DetailViewController</span> <span class="operator">*</span>detailVC <span class="operator">=</span> [[<span class="type">DetailViewController</span> alloc] initWithId:id <span class="type">Name</span>:name];</span><br><span class="line">    <span class="keyword">return</span> detailVC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@end</span></span><br></pre></td></tr></table></figure>
<p>至此基于Protocol的方案就完成了。如果需要调用某个组件或者跳转某个页面，只要先从ModuleProtocolManager的字典里面根据对应的ModuleEntryProtocol找到对应的DetailModuleEntry，找到了DetailModuleEntry就是找到了组件或者页面的“入口”了。再把参数传进去即可。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (void)didClickDetailButton:(<span class="type">UIButton</span> <span class="operator">*</span>)button</span><br><span class="line">&#123;</span><br><span class="line">    id<span class="operator">&lt;</span> <span class="type">DetailModuleEntryProtocol</span> <span class="operator">&gt;</span> <span class="type">DetailModuleEntry</span> <span class="operator">=</span> [<span class="type">ModuleProtocolManager</span> serviceProvideForProtocol:<span class="meta">@protocol</span>(<span class="type">DetailModuleEntryProtocol</span>)];</span><br><span class="line">    <span class="type">UIViewController</span> <span class="operator">*</span>detailVC <span class="operator">=</span> [<span class="type">DetailModuleEntry</span> detailViewControllerWithId:@“详情界面” <span class="type">Name</span>:@“我的购物车”];</span><br><span class="line">    [<span class="keyword">self</span>.navigationController pushViewController:detailVC animated:<span class="type">YES</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以调用到组件或者界面了。</p>
<p>如果组件之间有相同的接口，那么还可以进一步的把这些接口都抽离出来。这些抽离出来的接口变成“元接口”，它们是可以足够支撑起整个组件一层的。</p>
<p><img src="media/15197188413184/15211905453729.png" alt=""></p>
<h2 id="CTMediator"><a href="#CTMediator" class="headerlink" title="CTMediator"></a>CTMediator</h2><p>这方案是基于Mediator的。</p>
<p>传统的中间人Mediator的模式是这样的</p>
<p><img src="media/15197188413184/15211905959980.png" alt=""></p>
<p>这种模式每个页面或者组件都会依赖中间者，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator还是会依赖其他组件。那么这是最终方案了么？</p>
<p>主要思想是利用了Target-Action简单粗暴的思想，利用Runtime解决解耦的问题。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (id)performTarget:(<span class="type">NSString</span> <span class="operator">*</span>)targetName action:(<span class="type">NSString</span> <span class="operator">*</span>)actionName params:(<span class="type">NSDictionary</span> <span class="operator">*</span>)params shouldCacheTarget:(<span class="type">BOOL</span>)shouldCacheTarget</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>targetClassString <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;Target_%@&quot;</span>, targetName];</span><br><span class="line">    <span class="type">NSString</span> <span class="operator">*</span>actionString <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;Action_%@:&quot;</span>, actionName];</span><br><span class="line">    <span class="type">Class</span> targetClass;</span><br><span class="line"></span><br><span class="line">    <span class="type">NSObject</span> <span class="operator">*</span>target <span class="operator">=</span> <span class="keyword">self</span>.cachedTarget[targetClassString];</span><br><span class="line">    <span class="keyword">if</span> (target <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        targetClass <span class="operator">=</span> <span class="type">NSClassFromString</span>(targetClassString);</span><br><span class="line">        target <span class="operator">=</span> [[targetClass alloc] <span class="keyword">init</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">SEL</span> action <span class="operator">=</span> <span class="type">NSSelectorFromString</span>(actionString);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target <span class="operator">==</span> <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (shouldCacheTarget) &#123;</span><br><span class="line">        <span class="keyword">self</span>.cachedTarget[targetClassString] <span class="operator">=</span> target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([target respondsToSelector:action]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored <span class="string">&quot;-Warc-performSelector-leaks&quot;</span></span><br><span class="line">        <span class="keyword">return</span> [target performSelector:action withObject:params];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 有可能target是Swift对象</span></span><br><span class="line">        actionString <span class="operator">=</span> [<span class="type">NSString</span> stringWithFormat:@<span class="string">&quot;Action_%@WithParams:&quot;</span>, actionName];</span><br><span class="line">        action <span class="operator">=</span> <span class="type">NSSelectorFromString</span>(actionString);</span><br><span class="line">        <span class="keyword">if</span> ([target respondsToSelector:action]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored <span class="string">&quot;-Warc-performSelector-leaks&quot;</span></span><br><span class="line">            <span class="keyword">return</span> [target performSelector:action withObject:params];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理</span></span><br><span class="line">            <span class="type">SEL</span> action <span class="operator">=</span> <span class="type">NSSelectorFromString</span>(@<span class="string">&quot;notFound:&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> ([target respondsToSelector:action]) &#123;</span><br><span class="line">#pragma clang diagnostic push</span><br><span class="line">#pragma clang diagnostic ignored <span class="string">&quot;-Warc-performSelector-leaks&quot;</span></span><br><span class="line">                <span class="keyword">return</span> [target performSelector:action withObject:params];</span><br><span class="line">#pragma clang diagnostic pop</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。</span></span><br><span class="line">                [<span class="keyword">self</span>.cachedTarget removeObjectForKey:targetClassString];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>targetName就是调用接口的Object，actionName就是调用方法的SEL，params是参数，shouldCacheTarget代表是否需要缓存，如果需要缓存就把target存起来，Key是targetClassString，Value是target。</p>
<p>通过这种方式进行改造的，外面调用的方法都很统一，都是调用performTarget: action: params: shouldCacheTarget:。第三个参数是一个字典，这个字典里面可以传很多参数，只要Key-Value写好就可以了。处理错误的方式也统一在一个地方了，target没有，或者是target无法响应相应的方法，都可以在Mediator这里进行统一出错处理。</p>
<p>但是在实际开发过程中，不管是界面调用，组件间调用，在Mediator中需要定义很多方法。于是作者又想出了建议我们用Category的方法，对Mediator的所有方法进行拆分，这样就就可以不会导致Mediator这个类过于庞大了。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">-</span> (<span class="type">UIViewController</span> <span class="operator">*</span>)<span class="type">CTMediator_viewControllerForDetail</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">UIViewController</span> <span class="operator">*</span>viewController <span class="operator">=</span> [<span class="keyword">self</span> performTarget:kCTMediatorTargetA</span><br><span class="line">                                                    action:kCTMediatorActionNativFetchDetailViewController</span><br><span class="line">                                                    params:@&#123;@<span class="string">&quot;key&quot;</span>:@<span class="string">&quot;value&quot;</span>&#125;</span><br><span class="line">                                         shouldCacheTarget:<span class="type">NO</span></span><br><span class="line">                                        ];</span><br><span class="line">    <span class="keyword">if</span> ([viewController isKindOfClass:[<span class="type">UIViewController</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">// view controller 交付出去之后，可以由外界选择是push还是present</span></span><br><span class="line">        <span class="keyword">return</span> viewController;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里处理异常场景，具体如何处理取决于产品</span></span><br><span class="line">        <span class="keyword">return</span> [[<span class="type">UIViewController</span> alloc] <span class="keyword">init</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="operator">-</span> (void)<span class="type">CTMediator_presentImage</span>:(<span class="type">UIImage</span> <span class="operator">*</span>)image</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (image) &#123;</span><br><span class="line">        [<span class="keyword">self</span> performTarget:kCTMediatorTargetA</span><br><span class="line">                     action:kCTMediatorActionNativePresentImage</span><br><span class="line">                     params:@&#123;@<span class="string">&quot;image&quot;</span>:image&#125;</span><br><span class="line">          shouldCacheTarget:<span class="type">NO</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 这里处理image为nil的场景，如何处理取决于产品</span></span><br><span class="line">        [<span class="keyword">self</span> performTarget:kCTMediatorTargetA</span><br><span class="line">                     action:kCTMediatorActionNativeNoImage</span><br><span class="line">                     params:@&#123;@<span class="string">&quot;image&quot;</span>:[<span class="type">UIImage</span> imageNamed:@<span class="string">&quot;noImage&quot;</span>]&#125;</span><br><span class="line">          shouldCacheTarget:<span class="type">NO</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把这些具体的方法一个个的都写在Category里面就好了，调用的方式都非常的一致，都是调用performTarget: action: params: shouldCacheTarget:方法。</p>
<p>最终去掉了中间者Mediator对组件的依赖，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator不依赖其他任何组件。</p>
<p><img src="media/15197188413184/15211907578592.png" alt=""></p>
<h1 id="没有开源的解决方案"><a href="#没有开源的解决方案" class="headerlink" title="没有开源的解决方案"></a>没有开源的解决方案</h1><p>Uber在发现MVC的一些弊端之后：比如动辄上万行巨胖无比的VC，无法进行单元测试等缺点后，于是考虑把架构换成VIPER。但是VIPER也有一定的弊端。因为它的iOS特定的结构，意味着iOS必须为Android做出一些妥协的权衡。以视图为驱动的应用程序逻辑，代表应用程序状态由视图驱动，整个应用程序都锁定在视图树上。由操作应用程序状态所关联的业务逻辑的改变，就必须经过Presenter。因此会暴露业务逻辑。最终导致了视图树和业务树进行了紧紧的耦合。这样想实现一个紧紧只有业务逻辑的Node节点或者紧紧只有视图逻辑的Node节点就非常的困难了。</p>
<p>通过改进VIPER架构，吸收其优秀的特点，改进其缺点，就形成了Uber 骑手App的全新架构——Riblets(肋骨)。</p>
<p><img src="media/15197188413184/15211908131541.png" alt=""><br>在这个新的架构中，即使是相似的逻辑也会被区分成很小很小，相互独立，可以单独进行测试的组件。每个组件都有非常明确的用途。使用这些一小块一小块的Riblets(肋骨)，最终把整个App拼接成一颗Riblets(肋骨)树。</p>
<p>通过抽象，一个Riblets(肋骨)被定义成一下6个更小的组件，这些组件各自有各自的职责。通过一个Riblets(肋骨)进一步的抽象业务逻辑和视图逻辑<img src="media/15197188413184/15211908356457.png" alt=""></p>
<p>一个Riblets(肋骨)被设计成这样，那和之前的VIPER和MVC有什么区别呢？最大的区别在路由上面。</p>
<p>Riblets(肋骨)内的Router不再是视图逻辑驱动的，现在变成了业务逻辑驱动。这一重大改变就导致了整个App不再是由表现形式驱动，现在变成了由数据流驱动。</p>
<p>每一个Riblet都是由一个路由Router，一个关联器Interactor，一个构造器Builder和它们相关的组件构成的。所以它的命名（Router - Interactor - Builder，Rib）也由此得来。当然还可以有可选的展示器Presenter和视图View。路由Router和关联器Interactor处理业务逻辑，展示器Presenter和视图View处理视图逻辑。</p>
<p>重点分析一下Riblet里面路由的职责。</p>
<h2 id="路由职责"><a href="#路由职责" class="headerlink" title="路由职责"></a>路由职责</h2><p>在整个App的结构树中，路由的职责是用来关联和取消关联其他子Riblet的。至于决定是由关联器Interactor传递过来的。在状态转换过程中，关联和取消关联子Riblet的时候，路由也会影响到关联器Interactor的生命周期。路由只包含2个业务逻辑：</p>
<p>1.提供关联和取消关联其他路由的方法。<br>2.在多个孩子之间决定最终状态的状态转换逻辑</p>
<h2 id="拼装"><a href="#拼装" class="headerlink" title="拼装"></a>拼装</h2><p>每一个Riblets只有一对Router路由和Interactor关联器。但是它们可以有多对视图。Riblets只处理业务逻辑，不处理视图相关的部分。Riblets可以拥有单一的视图（一个Presenter展示器和一个View视图），也可以拥有多个视图（一个Presenter展示器和多个View视图，或者多个Presenter展示器和多个View视图），甚至也可以能没有视图（没有Presenter展示器也没有View视图）。这种设计可以有助于业务逻辑树的构建，也可以和视图树做到很好的分离。</p>
<p>举个例子，骑手的Riblet是一个没有视图的Riblet，它用来检查当前用户是否有一个激活的路线。如果骑手确定了路线，那么这个Riblet就会关联到路线的Riblet上面。路线的Riblet会在地图上显示出路线图。如果没有确定路线，骑手的Riblet就会被关联到请求的Riblet上。请求的Riblet会在屏幕上显示等待被呼叫。像骑手的Riblet这样没有任何视图逻辑的Riblet，它分开了业务逻辑，在驱动App和支撑模块化架构起了重大作用。</p>
<p><img src="media/15197188413184/15211910716650.png" alt=""><br>在这个新的架构中，数据流动是单向的。Data数据流从service服务流到Model Stream生成Model流。Model流再从Model Stream流动到Interactor关联器。Interactor关联器，scheduler调度器，远程推送都可以想Service触发变化来引起Model Stream的改动。Model Stream生成不可改动的models。这个强制的要求就导致关联器只能通过Service层改变App的状态。</p>
<p>举两个例子：</p>
<ul>
<li><p>数据从后台到视图View上<br>一个状态的改变，引起服务器后台触发推送到App。数据就被Push到App，然后生成不可变的数据流。关联器收到model之后，把它传递给展示器Presenter。展示器Presenter把model转换成view model传递给视图View。</p>
</li>
<li><p>数据从视图到服务器后台<br>当用户点击了一个按钮，比如登录按钮。视图View就会触发UI事件传递给展示器Presenter。展示器Presenter调用关联器Interactor登录方法。关联器Interactor又会调用Service call的实际登录方法。请求网络之后会把数据pull到后台服务器。</p>
</li>
</ul>
<p>Riblet间的数据流<img src="media/15197188413184/15211910963069.png" alt=""></p>
<p>当一个关联器Interactor在处理业务逻辑的工程中，需要调用其他Riblet的事件的时候，关联器Interactor需要和子关联器Interactor进行关联。见上图5个步骤。</p>
<p>如果调用方法是从子调用父类，父类的Interactor的接口通常被定义成监听者listener。如果调用方法是从父类调用到子类，那么子类的接口通常是一个delegate，实现父类的一些Protocol。</p>
<p>在Riblet的方案中，路由Router仅仅只是用来维护一个树型关系，而关联器Interactor才担当的是用来决定触发组件间的逻辑跳转的角色。</p>
<h1 id="各个方案对比"><a href="#各个方案对比" class="headerlink" title="各个方案对比"></a>各个方案对比</h1><ul>
<li>APP间跳转<ul>
<li>URL Scheme方式</li>
<li>Universal Link方式      </li>
</ul>
</li>
<li>APP内路由跳转<ul>
<li>URLRoute注册</li>
<li>Protocol-Class 注册</li>
<li>Target-Action</li>
</ul>
</li>
</ul>
<p>经过上面的分析，可以发现，路由的设计思路是从URLRoute -&gt;Protocol-class -&gt;Target-Action一步步的深入的过程。这也是逐渐深入本质的过程。</p>
<h2 id="1-URLRoute注册方案的优缺点"><a href="#1-URLRoute注册方案的优缺点" class="headerlink" title="1. URLRoute注册方案的优缺点"></a>1. URLRoute注册方案的优缺点</h2><p>首先URLRoute也许是借鉴前端Router和系统App内跳转的方式想出来的方法。它通过URL来请求资源。不管是H5，RN，Weex，iOS界面或者组件请求资源的方式就都统一了。URL里面也会带上参数，这样调用什么界面或者组件都可以。所以这种方式是最容易，也是最先可以想到的。</p>
<p>URLRoute的优点很多，最大的优点就是服务器可以动态的控制页面跳转，可以统一处理页面出问题之后的错误处理，可以统一三端，iOS，Android，H5 / RN / Weex 的请求方式。</p>
<p>但是这种方式也需要看不同公司的需求。如果公司里面已经完成了服务器端动态下发的脚手架工具，前端也完成了Native端如果出现错误了，可以随时替换相同业务界面的需求，那么这个时候可能选择URLRoute的几率会更大。</p>
<p>但是如果公司里面H5没有做相关出现问题后能替换的界面，H5开发人员觉得这是给他们增添负担。如果公司也没有完成服务器动态下发路由规则的那套系统，那么公司可能就不会采用URLRoute的方式。因为URLRoute带来的少量动态性，公司是可以用JSPatch来做到。线上出现bug了，可以立即用JSPatch修掉，而不采用URLRoute去做。</p>
<p>所以选择URLRoute这种方案，也要看公司的发展情况和人员分配，技术选型方面。</p>
<p>URLRoute方案也是存在一些缺点的，首先URL的map规则是需要注册的，它们会在load方法里面写。写在load方法里面是会影响App启动速度的。</p>
<p>其次是大量的硬编码。URL链接里面关于组件和页面的名字都是硬编码，参数也都是硬编码。而且每个URL参数字段都必须要一个文档进行维护，这个对于业务开发人员也是一个负担。而且URL短连接散落在整个App四处，维护起来实在有点麻烦，虽然蘑菇街想到了用宏统一管理这些链接，但是还是解决不了硬编码的问题。</p>
<p>真正一个好的路由是在无形当中服务整个App的，是一个无感知的过程，从这一点来说，略有点缺失。</p>
<p>最后一个缺点是，对于传递NSObject的参数，URL是不够友好的，它最多是传递一个字典。</p>
<h2 id="2-Protocol-Class注册方案的优缺点"><a href="#2-Protocol-Class注册方案的优缺点" class="headerlink" title="2. Protocol-Class注册方案的优缺点"></a>2. Protocol-Class注册方案的优缺点</h2><p>Protocol-Class方案的优点，这个方案没有硬编码。</p>
<p>Protocol-Class方案也是存在一些缺点的，每个Protocol都要向ModuleManager进行注册。</p>
<p>这种方案ModuleEntry是同时需要依赖ModuleManager和组件里面的页面或者组件两者的。当然ModuleEntry也是会依赖ModuleEntryProtocol的，但是这个依赖是可以去掉的，比如用Runtime的方法NSProtocolFromString，加上硬编码是可以去掉对Protocol的依赖的。但是考虑到硬编码的方式对出现bug，后期维护都是不友好的，所以对Protocol的依赖还是不要去除。</p>
<p>最后一个缺点是组件方法的调用是分散在各处的，没有统一的入口，也就没法做组件不存在时或者出现错误时的统一处理。</p>
<h2 id="3-Target-Action方案的优缺点"><a href="#3-Target-Action方案的优缺点" class="headerlink" title="3. Target-Action方案的优缺点"></a>3. Target-Action方案的优缺点</h2><p>Target-Action方案的优点，充分的利用Runtime的特性，无需注册这一步。Target-Action方案只有存在组件依赖Mediator这一层依赖关系。在Mediator中维护针对Mediator的Category，每个category对应一个Target，Categroy中的方法对应Action场景。Target-Action方案也统一了所有组件间调用入口。</p>
<p>Target-Action方案也能有一定的安全保证，它对url中进行Native前缀进行验证。</p>
<p>Target-Action方案的缺点，Target_Action在Category中将常规参数打包成字典，在Target处再把字典拆包成常规参数，这就造成了一部分的硬编码。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>路由</p><p><a href="https://bapuqln.github.io/back/路由.html">https://bapuqln.github.io/back/路由.html</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>shouyi.www</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2019-12-04</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-01-15</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/"></a><a class="link-muted mr-2" rel="tag" href="/"></a></div><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5f6a3085d629232a" defer></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="/images/alipay.JPG" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="/images/wechatpay.JPG" alt="微信"></span></a></div></div></div><div class="card"><div class="card-content"><h3 class="title is-5">评论</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "a17b3374fbcd63bf4983d42f0365e325",
            repo: "bapuqln.github.io.reply",
            owner: "bapuqln",
            clientID: "6d20fefe8f6c9ee3daab",
            clientSecret: "6c6966f0af1581858ba187fb851eedc90ffb93e2",
            admin: ["bapuqln"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 20,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            language: "zh-CN",
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://octodex.github.com/images/heisencat.png" alt="ACE_xW"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">ACE_xW</p><p class="is-size-6 is-block">一个程序员</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Your location</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">39</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">21</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/bapuqln" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile is-multiline"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/bapuqln"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com/ACE_XW"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="StackOverflow" href="https://stackoverflow.com/users/2645274/ace-xw"><i class="fab fa-stack-overflow"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Instagram" href="https://instagram.com/acexw"><i class="fab fa-instagram"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://www.weibo.com/u/1575613965"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="E-Mail" href="mailto:bapuwang7@gmail.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Algorithm/"><span class="level-start"><span class="level-item">Algorithm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Algorithm/Swift/"><span class="level-start"><span class="level-item">Swift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Binary-Tree/"><span class="level-start"><span class="level-item">Binary Tree</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/C/"><span class="level-start"><span class="level-item">C++</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/categories/Groking-The-Coding-Interview/"><span class="level-start"><span class="level-item">Groking The Coding Interview</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/LeetCode/"><span class="level-start"><span class="level-item">LeetCode</span></span><span class="level-end"><span class="level-item tag">24</span></span></a></li><li><a class="level is-mobile" href="/categories/Mac-Develop/"><span class="level-start"><span class="level-item">Mac Develop</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul><li><a class="level is-mobile" href="/categories/Mac-Develop/Swift/"><span class="level-start"><span class="level-item">Swift</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Super-Sign/"><span class="level-start"><span class="level-item">Super Sign</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/VSCode/"><span class="level-start"><span class="level-item">VSCode</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/iOS/"><span class="level-start"><span class="level-item">iOS</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%9E%8E%E9%80%BC%E9%80%BC/"><span class="level-start"><span class="level-item">瞎逼逼</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"><span class="level-start"><span class="level-item">背包问题</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2025-01-15T07:01:21.143Z">2025-01-15</time></p><p class="title"><a href="/2025/01/15/VIPER%E6%9E%B6%E6%9E%84%E8%90%BD%E5%9C%B0%E5%88%B0IM/">VIPER架构落地IM</a></p><p class="categories"><a href="/categories/Mac-Develop/">Mac Develop</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-16T02:33:32.000Z">2020-11-16</time></p><p class="title"><a href="/2020/11/16/GrokingTheCodeInterview/">Groking The coding Interview</a></p><p class="categories"><a href="/categories/Groking-The-Coding-Interview/">Groking The Coding Interview</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-11-08T02:40:18.000Z">2020-11-08</time></p><p class="title"><a href="/2020/11/08/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">背包九讲</a></p><p class="categories"><a href="/categories/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/">背包问题</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-10-05T02:57:04.000Z">2020-10-05</time></p><p class="title"><a href="/2020/10/05/Mac-NSTextView-%E4%B8%AD%E8%8B%B1%E6%B7%B7%E8%BE%93%E6%83%85%E5%86%B5%E4%B8%8B-inline-%E4%B8%8A%E4%B8%8B%E6%8A%96%E5%8A%A8/">Mac_NSTextView_中英混输情况下_inline_上下抖动</a></p><p class="categories"><a href="/categories/Mac-Develop/">Mac Develop</a> / <a href="/categories/Mac-Develop/Swift/">Swift</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2020-10-03T05:04:54.000Z">2020-10-03</time></p><p class="title"><a href="/2020/10/03/VSCode-C/">VSCode C++ 配置</a></p><p class="categories"><a href="/categories/VSCode/">VSCode</a></p></div></article></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2025/01/"><span class="level-start"><span class="level-item">一月 2025</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/11/"><span class="level-start"><span class="level-item">十一月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/10/"><span class="level-start"><span class="level-item">十月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/09/"><span class="level-start"><span class="level-item">九月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/08/"><span class="level-start"><span class="level-item">八月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/07/"><span class="level-start"><span class="level-item">七月 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/06/"><span class="level-start"><span class="level-item">六月 2020</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/05/"><span class="level-start"><span class="level-item">五月 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/04/"><span class="level-start"><span class="level-item">四月 2020</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile" href="/archives/2020/02/"><span class="level-start"><span class="level-item">二月 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/12/"><span class="level-start"><span class="level-item">十二月 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile" href="/archives/2019/11/"><span class="level-start"><span class="level-item">十一月 2019</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li></ul></div></div></div><div class="card widget" data-type="tags"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Algorithm/"><span class="tag">Algorithm</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Bit-Manupulate/"><span class="tag">Bit Manupulate</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C/"><span class="tag">C++</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Dynamic-Programming/"><span class="tag">Dynamic Programming</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Easy/"><span class="tag">Easy</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/FishHook/"><span class="tag">FishHook</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hard/"><span class="tag">Hard</span><span class="tag">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/LeetCode/"><span class="tag">LeetCode</span><span class="tag">24</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Mac-Develop/"><span class="tag">Mac Develop</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Medium/"><span class="tag">Medium</span><span class="tag">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/NSDictionary/"><span class="tag">NSDictionary</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/SuperSign/"><span class="tag">SuperSign</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Swift/"><span class="tag">Swift</span><span class="tag">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/VSCode/"><span class="tag">VSCode</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Weakly-Contest/"><span class="tag">Weakly Contest</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/educative-io/"><span class="tag">educative.io</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/iOS/"><span class="tag">iOS</span><span class="tag">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E4%BE%8B/"><span class="tag">单例</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%90%AF%E5%8A%A8%E9%80%9F%E5%BA%A6/"><span class="tag">启动速度</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"><span class="tag">背包问题</span><span class="tag">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B6%85%E7%BA%A7%E7%AD%BE%E5%90%8D/"><span class="tag">超级签名</span><span class="tag">1</span></a></div></div></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><div class="card widget" data-type="adsense"><div class="card-content"><div class="menu"><h3 class="menu-label">广告</h3><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6519518696903770" data-ad-slot="7559310723" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://octodex.github.com/images/heisencat.png" alt="ACE_xW" height="28"></a><p class="is-size-7"><span>&copy; 2025 shouyi.www</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/bapuqln"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/mhchem.min.js" defer></script><script>window.addEventListener("load", function() {
            document.querySelectorAll('[role="article"] > .content').forEach(function(element) {
                renderMathInElement(element);
            });
        });</script><div id="outdated"><h6>Your browser is out-of-date!</h6><p>Update your browser to view this website correctly.&amp;npsb;<a id="btnUpdateBrowser" target="_blank" rel="noopener" href="http://outdatedbrowser.com/">Update my browser now </a></p><p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">×</a></p></div><script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script><script>window.addEventListener("load", function () {
            outdatedBrowser({
                bgColor: '#f25648',
                color: '#ffffff',
                lowerThan: 'object-fit' // display on IE11 or below
            });
        });</script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>